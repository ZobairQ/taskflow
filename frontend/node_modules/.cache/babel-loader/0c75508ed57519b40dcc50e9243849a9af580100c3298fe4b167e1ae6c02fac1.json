{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"partial\"];\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n */\n/**  */\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { asapScheduler, observeOn } from \"rxjs\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport { maybeDeepFreeze, mergeOptions, variablesUnknownSymbol } from \"@apollo/client/utilities/internal\";\nimport { skipToken } from \"./constants.js\";\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nconst lastWatchOptions = Symbol();\nexport function useQuery(query) {\n  \"use no memo\";\n\n  for (var _len = arguments.length, _ref = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    _ref[_key - 1] = arguments[_key];\n  }\n  let [options] = _ref;\n  return wrapHook(\"useQuery\", useQuery_, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\nfunction useQuery_(query) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = useApolloClient(typeof options === \"object\" ? options.client : undefined);\n  const {\n    ssr\n  } = typeof options === \"object\" ? options : {};\n  const watchQueryOptions = useOptions(query, options, client.defaultOptions.watchQuery);\n  function createState(previous) {\n    const observable = client.watchQuery(watchQueryOptions);\n    return {\n      client,\n      query,\n      observable,\n      resultData: {\n        current: observable.getCurrentResult(),\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: previous === null || previous === void 0 ? void 0 : previous.resultData.current.data,\n        variables: observable.variables\n      }\n    };\n  }\n  let [state, setState] = React.useState(createState);\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    setState(state = createState(state));\n  }\n  const {\n    observable,\n    resultData\n  } = state;\n  useInitialFetchPolicyIfNecessary(watchQueryOptions, observable);\n  useResubscribeIfNecessary(resultData,\n  // might get mutated during render\n  observable,\n  // might get mutated during render\n  watchQueryOptions);\n  const result = useResult(observable, resultData, ssr);\n  const obsQueryFields = React.useMemo(() => ({\n    refetch: observable.refetch.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable)\n  }), [observable]);\n  const previousData = resultData.previousData;\n  return React.useMemo(() => {\n    const {\n        partial\n      } = result,\n      rest = _objectWithoutProperties(result, _excluded);\n    return _objectSpread(_objectSpread({}, rest), {}, {\n      client,\n      observable,\n      variables: observable.variables,\n      previousData\n    }, obsQueryFields);\n  }, [result, client, observable, previousData, obsQueryFields]);\n}\nconst fromSkipToken = Symbol();\nfunction useOptions(query, options, defaultOptions) {\n  return useDeepMemo(() => {\n    if (options === skipToken) {\n      const opts = _objectSpread(_objectSpread({}, mergeOptions(defaultOptions, {\n        query,\n        fetchPolicy: \"standby\"\n      })), {}, {\n        [variablesUnknownSymbol]: true\n      });\n      opts[fromSkipToken] = true;\n      return opts;\n    }\n    const watchQueryOptions = mergeOptions(defaultOptions, _objectSpread(_objectSpread({}, options), {}, {\n      query\n    }));\n    if (options.skip) {\n      watchQueryOptions.initialFetchPolicy = options.initialFetchPolicy || options.fetchPolicy;\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n    return watchQueryOptions;\n  }, [query, options, defaultOptions]);\n}\nfunction useInitialFetchPolicyIfNecessary(watchQueryOptions, observable) {\n  \"use no memo\";\n\n  if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = observable.options.initialFetchPolicy;\n  }\n}\nfunction useResult(observable, resultData, ssr) {\n  \"use no memo\";\n\n  return useSyncExternalStore(React.useCallback(handleStoreChange => {\n    const subscription = observable\n    // We use the asapScheduler here to prevent issues with trying to\n    // update in the middle of a render. `reobserve` is kicked off in the\n    // middle of a render and because RxJS emits values synchronously,\n    // its possible for this `handleStoreChange` to be called in that same\n    // render. This allows the render to complete before trying to emit a\n    // new value.\n    .pipe(observeOn(asapScheduler)).subscribe(result => {\n      const previous = resultData.current;\n      if (\n      // Avoid rerendering if the result is the same\n      equal(previous, result) &&\n      // Force rerender if the value was emitted because variables\n      // changed, such as when calling `refetch(newVars)` which returns\n      // the same data when `notifyOnNetworkStatusChange` is `false`.\n      equal(resultData.variables, observable.variables)) {\n        return;\n      }\n      resultData.variables = observable.variables;\n      if (previous.data && !equal(previous.data, result.data)) {\n        resultData.previousData = previous.data;\n      }\n      resultData.current = result;\n      handleStoreChange();\n    });\n    // Do the \"unsubscribe\" with a short delay.\n    // This way, an existing subscription can be reused without an additional\n    // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n    // happen in very fast succession.\n    return () => {\n      setTimeout(() => subscription.unsubscribe());\n    };\n  }, [observable, resultData]), () => resultData.current, () => ssr === false ? useQuery.ssrDisabledResult : resultData.current);\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(/** this hook will mutate properties on `resultData` */\nresultData, /** this hook will mutate properties on `observable` */\nobservable, watchQueryOptions) {\n  \"use no memo\";\n\n  if (observable[lastWatchOptions] && !equal(observable[lastWatchOptions], watchQueryOptions)) {\n    // If skipToken was used to generate options, we won't know the correct\n    // initialFetchPolicy until the hook is rerendered with real options, so we\n    // set it the next time we get real options\n    if (observable[lastWatchOptions][fromSkipToken] && !watchQueryOptions.initialFetchPolicy) {\n      watchQueryOptions.initialFetchPolicy = watchQueryOptions.fetchPolicy;\n    }\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    if (shouldReobserve(observable[lastWatchOptions], watchQueryOptions)) {\n      observable.reobserve(watchQueryOptions);\n    } else {\n      observable.applyOptions(watchQueryOptions);\n    }\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    const result = observable.getCurrentResult();\n    if (!equal(result.data, resultData.current.data)) {\n      resultData.previousData = resultData.current.data || resultData.previousData;\n    }\n    resultData.current = result;\n    resultData.variables = observable.variables;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\nfunction shouldReobserve(previousOptions, options) {\n  return previousOptions.query !== options.query || !equal(previousOptions.variables, options.variables) || previousOptions.fetchPolicy !== options.fetchPolicy && (options.fetchPolicy === \"standby\" || previousOptions.fetchPolicy === \"standby\");\n}\nuseQuery.ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0,\n  dataState: \"empty\",\n  error: void 0,\n  networkStatus: NetworkStatus.loading,\n  partial: true\n});","map":{"version":3,"names":["equal","React","asapScheduler","observeOn","NetworkStatus","maybeDeepFreeze","mergeOptions","variablesUnknownSymbol","skipToken","useDeepMemo","wrapHook","useApolloClient","useSyncExternalStore","lastWatchOptions","Symbol","useQuery","query","_len","arguments","length","_ref","Array","_key","options","useQuery_","client","undefined","ssr","watchQueryOptions","useOptions","defaultOptions","watchQuery","createState","previous","observable","resultData","current","getCurrentResult","previousData","data","variables","state","setState","useState","useInitialFetchPolicyIfNecessary","useResubscribeIfNecessary","result","useResult","obsQueryFields","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","partial","rest","_objectWithoutProperties","_excluded","_objectSpread","fromSkipToken","opts","fetchPolicy","skip","initialFetchPolicy","useCallback","handleStoreChange","subscription","pipe","subscribe","setTimeout","unsubscribe","ssrDisabledResult","shouldReobserve","reobserve","applyOptions","previousOptions","loading","dataState","error","networkStatus"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/react/hooks/useQuery.ts"],"sourcesContent":["/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n */\n/**  */\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { asapScheduler, observeOn } from \"rxjs\";\n\nimport type {\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  InternalTypes,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  SubscribeToMoreFunction,\n  TypedDocumentNode,\n  UpdateQueryMapFn,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { ApolloClient } from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  mergeOptions,\n  variablesUnknownSymbol,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { SkipToken } from \"./constants.js\";\nimport { skipToken } from \"./constants.js\";\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useQuery {\n  import _self = useQuery;\n  export namespace Base {\n    export interface Options<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: WatchQueryFetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n      nextFetchPolicy?:\n        | WatchQueryFetchPolicy\n        | ((\n            this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n            currentFetchPolicy: WatchQueryFetchPolicy,\n            context: InternalTypes.NextFetchPolicyContext<TData, TVariables>\n          ) => WatchQueryFetchPolicy);\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n\n      initialFetchPolicy?: WatchQueryFetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n      pollInterval?: number;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n      notifyOnNetworkStatusChange?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n      skipPollAttempt?: () => boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#ssr:member} */\n      ssr?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip:member} */\n      skip?: boolean;\n    }\n  }\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useQuery {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TData, TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export namespace Base {\n    export interface Result<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n      TReturnVariables extends OperationVariables = TVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#observable:member} */\n      observable: ObservableQuery<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#previousData:member} */\n      previousData?: MaybeMasked<TData>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error?: ErrorLike;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n      loading: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#startPolling:member} */\n      startPolling: (pollInterval: number) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#stopPolling:member} */\n      stopPolling: () => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#updateQuery:member} */\n      updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n      refetch: (\n        variables?: Partial<TVariables>\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n      variables: TReturnVariables;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n      fetchMore: <\n        TFetchData = TData,\n        TFetchVars extends OperationVariables = TVariables,\n      >(\n        fetchMoreOptions: ObservableQuery.FetchMoreOptions<\n          TData,\n          TVariables,\n          TFetchData,\n          TFetchVars\n        >\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TFetchData>>>;\n    }\n  }\n  export type Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n    TReturnVariables extends OperationVariables = TVariables,\n  > = Base.Result<TData, TVariables, TReturnVariables> &\n    GetDataState<MaybeMasked<TData>, TStates>;\n\n  export namespace DocumentationTypes {\n    namespace useQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\n    export function useQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useQuery.Options<TData, TVariables>\n    ): useQuery.Result<TData, TVariables>;\n  }\n}\n\nconst lastWatchOptions = Symbol();\n\ninterface ObsQueryWithMeta<TData, TVariables extends OperationVariables>\n  extends ObservableQuery<TData, TVariables> {\n  [lastWatchOptions]?: Readonly<\n    ApolloClient.WatchQueryOptions<TData, TVariables>\n  >;\n}\n\ninterface InternalResult<TData> {\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  current: ObservableQuery.Result<TData>;\n  previousData?: undefined | MaybeMasked<TData>;\n\n  // Track current variables separately in case a call to e.g. `refetch(newVars)`\n  // causes an emit that is deeply equal to the current result. This lets us\n  // compare if we should force rerender due to changed variables\n  variables: OperationVariables;\n}\n\ninterface InternalState<TData, TVariables extends OperationVariables> {\n  client: ReturnType<typeof useApolloClient>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  observable: ObsQueryWithMeta<TData, TVariables>;\n  resultData: InternalResult<TData>;\n}\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, `dataState`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql } from \"@apollo/client\";\n * import { useQuery } from \"@apollo/client/react\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: \"english\" },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): useQuery.Result<TData, TVariables, \"empty\", Record<string, never>>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\",\n  Partial<TVariables>\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: boolean;\n      })\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\",\n  Partial<TVariables>\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n  : [options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<TData, TVariables, \"empty\" | \"complete\" | \"streaming\">;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [\n      options?:\n        | SkipToken\n        | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>,\n    ]\n  : [options: SkipToken | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\",\n  Partial<TVariables>\n>;\n\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [\n      options?:\n        | SkipToken\n        | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>,\n    ]\n  : [options: SkipToken | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<TData, TVariables> {\n  \"use no memo\";\n  return wrapHook(\n    \"useQuery\",\n    useQuery_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction useQuery_<TData, TVariables extends OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | useQuery.Options<\n        NoInfer<TData>,\n        NoInfer<TVariables>\n      > = {} as useQuery.Options<TData, TVariables>\n): useQuery.Result<TData, TVariables> {\n  const client = useApolloClient(\n    typeof options === \"object\" ? options.client : undefined\n  );\n  const { ssr } = typeof options === \"object\" ? options : {};\n\n  const watchQueryOptions = useOptions(\n    query,\n    options,\n    client.defaultOptions.watchQuery\n  );\n\n  function createState(\n    previous?: InternalState<TData, TVariables>\n  ): InternalState<TData, TVariables> {\n    const observable = client.watchQuery(watchQueryOptions);\n\n    return {\n      client,\n      query,\n      observable,\n      resultData: {\n        current: observable.getCurrentResult(),\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: previous?.resultData.current.data as TData,\n        variables: observable.variables,\n      },\n    };\n  }\n\n  let [state, setState] = React.useState(createState);\n\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    setState((state = createState(state)));\n  }\n\n  const { observable, resultData } = state;\n\n  useInitialFetchPolicyIfNecessary<TData, TVariables>(\n    watchQueryOptions,\n    observable\n  );\n\n  useResubscribeIfNecessary<TData, TVariables>(\n    resultData, // might get mutated during render\n    observable, // might get mutated during render\n    watchQueryOptions\n  );\n\n  const result = useResult<TData, TVariables>(observable, resultData, ssr);\n\n  const obsQueryFields = React.useMemo(\n    () => ({\n      refetch: observable.refetch.bind(observable),\n      fetchMore: observable.fetchMore.bind(observable),\n      updateQuery: observable.updateQuery.bind(observable),\n      startPolling: observable.startPolling.bind(observable),\n      stopPolling: observable.stopPolling.bind(observable),\n      subscribeToMore: observable.subscribeToMore.bind(observable),\n    }),\n    [observable]\n  );\n\n  const previousData = resultData.previousData;\n  return React.useMemo(() => {\n    const { partial, ...rest } = result;\n\n    return {\n      ...rest,\n      client,\n      observable,\n      variables: observable.variables,\n      previousData,\n      ...obsQueryFields,\n    };\n  }, [result, client, observable, previousData, obsQueryFields]);\n}\n\nconst fromSkipToken = Symbol();\n\nfunction useOptions<TData, TVariables extends OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>,\n  defaultOptions: Partial<ApolloClient.WatchQueryOptions<any, any>> | undefined\n): ApolloClient.WatchQueryOptions<TData, TVariables> {\n  return useDeepMemo<ApolloClient.WatchQueryOptions<TData, TVariables>>(() => {\n    if (options === skipToken) {\n      const opts: ApolloClient.WatchQueryOptions<TData, TVariables> = {\n        ...mergeOptions(defaultOptions as any, {\n          query,\n          fetchPolicy: \"standby\",\n        }),\n        [variablesUnknownSymbol]: true,\n      };\n      (opts as any)[fromSkipToken] = true;\n\n      return opts;\n    }\n\n    const watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables> =\n      mergeOptions(defaultOptions as any, { ...options, query });\n\n    if (options.skip) {\n      watchQueryOptions.initialFetchPolicy =\n        options.initialFetchPolicy || options.fetchPolicy;\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [query, options, defaultOptions]);\n}\n\nfunction useInitialFetchPolicyIfNecessary<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables>,\n  observable: ObsQueryWithMeta<TData, TVariables>\n) {\n  \"use no memo\";\n  if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = observable.options.initialFetchPolicy;\n  }\n}\n\nfunction useResult<TData, TVariables extends OperationVariables>(\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  resultData: InternalResult<TData>,\n  ssr: boolean | undefined\n) {\n  \"use no memo\";\n  return useSyncExternalStore(\n    React.useCallback(\n      (handleStoreChange) => {\n        const subscription = observable\n          // We use the asapScheduler here to prevent issues with trying to\n          // update in the middle of a render. `reobserve` is kicked off in the\n          // middle of a render and because RxJS emits values synchronously,\n          // its possible for this `handleStoreChange` to be called in that same\n          // render. This allows the render to complete before trying to emit a\n          // new value.\n          .pipe(observeOn(asapScheduler))\n          .subscribe((result) => {\n            const previous = resultData.current;\n\n            if (\n              // Avoid rerendering if the result is the same\n              equal(previous, result) &&\n              // Force rerender if the value was emitted because variables\n              // changed, such as when calling `refetch(newVars)` which returns\n              // the same data when `notifyOnNetworkStatusChange` is `false`.\n              equal(resultData.variables, observable.variables)\n            ) {\n              return;\n            }\n\n            resultData.variables = observable.variables;\n\n            if (previous.data && !equal(previous.data, result.data)) {\n              resultData.previousData = previous.data as TData;\n            }\n\n            resultData.current = result;\n            handleStoreChange();\n          });\n\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return () => {\n          setTimeout(() => subscription.unsubscribe());\n        };\n      },\n\n      [observable, resultData]\n    ),\n    () => resultData.current,\n    () => (ssr === false ? useQuery.ssrDisabledResult : resultData.current)\n  );\n}\n\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  /** this hook will mutate properties on `resultData` */\n  resultData: InternalResult<TData>,\n  /** this hook will mutate properties on `observable` */\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  watchQueryOptions: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>\n) {\n  \"use no memo\";\n  if (\n    observable[lastWatchOptions] &&\n    !equal(observable[lastWatchOptions], watchQueryOptions)\n  ) {\n    // If skipToken was used to generate options, we won't know the correct\n    // initialFetchPolicy until the hook is rerendered with real options, so we\n    // set it the next time we get real options\n    if (\n      (observable[lastWatchOptions] as any)[fromSkipToken] &&\n      !watchQueryOptions.initialFetchPolicy\n    ) {\n      (watchQueryOptions.initialFetchPolicy as any) =\n        watchQueryOptions.fetchPolicy;\n    }\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    if (shouldReobserve(observable[lastWatchOptions], watchQueryOptions)) {\n      observable.reobserve(watchQueryOptions);\n    } else {\n      observable.applyOptions(watchQueryOptions);\n    }\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    const result = observable.getCurrentResult();\n\n    if (!equal(result.data, resultData.current.data)) {\n      resultData.previousData = (resultData.current.data ||\n        (resultData.previousData as TData)) as TData;\n    }\n    resultData.current = result;\n    resultData.variables = observable.variables;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\n\nfunction shouldReobserve<TData, TVariables extends OperationVariables>(\n  previousOptions: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>,\n  options: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>\n) {\n  return (\n    previousOptions.query !== options.query ||\n    !equal(previousOptions.variables, options.variables) ||\n    (previousOptions.fetchPolicy !== options.fetchPolicy &&\n      (options.fetchPolicy === \"standby\" ||\n        previousOptions.fetchPolicy === \"standby\"))\n  );\n}\n\nuseQuery.ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0 as any,\n  dataState: \"empty\",\n  error: void 0,\n  networkStatus: NetworkStatus.loading,\n  partial: true,\n}) satisfies ObservableQuery.Result<any> as ObservableQuery.Result<any>;\n"],"mappings":";;;AAAA;;;;;;;;;;;;AAYA;AACA,SAASA,KAAK,QAAQ,eAAe;AACrC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,aAAa,EAAEC,SAAS,QAAQ,MAAM;AAmB/C,SAASC,aAAa,QAAQ,gBAAgB;AAO9C,SACEC,eAAe,EACfC,YAAY,EACZC,sBAAsB,QACjB,mCAAmC;AAG1C,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,WAAW,EAAEC,QAAQ,QAAQ,qBAAqB;AAC3D,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,oBAAoB,QAAQ,2BAA2B;AA+JhE,MAAMC,gBAAgB,GAAGC,MAAM,EAAE;AAyKjC,OAAM,SAAUC,QAAQA,CAItBC,KAA0D,EAOoB;EAE9E,aAAa;;EAAC,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAAC,IAAA,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAAF,IAAA,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;EAAA;EAAA,IARX,CAACC,OAAO,CAMmE,GAAAH,IAAA;EAG9E,OAAOV,QAAQ,CACb,UAAU,EACVc,SAAS,EACTb,eAAe,CAAC,OAAOY,OAAO,KAAK,QAAQ,GAAGA,OAAO,CAACE,MAAM,GAAGC,SAAS,CAAC,CAC1E,CAACV,KAAK,EAAEO,OAAO,CAAC;AACnB;AAEA,SAASC,SAASA,CAChBR,KAA0D,EAMT;EAAA,IALjDO,OAAA,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAQ,SAAA,GAAAR,SAAA,MAKQ,EAAyC;EAEjD,MAAMO,MAAM,GAAGd,eAAe,CAC5B,OAAOY,OAAO,KAAK,QAAQ,GAAGA,OAAO,CAACE,MAAM,GAAGC,SAAS,CACzD;EACD,MAAM;IAAEC;EAAG,CAAE,GAAG,OAAOJ,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAG,EAAE;EAE1D,MAAMK,iBAAiB,GAAGC,UAAU,CAClCb,KAAK,EACLO,OAAO,EACPE,MAAM,CAACK,cAAc,CAACC,UAAU,CACjC;EAED,SAASC,WAAWA,CAClBC,QAA2C;IAE3C,MAAMC,UAAU,GAAGT,MAAM,CAACM,UAAU,CAACH,iBAAiB,CAAC;IAEvD,OAAO;MACLH,MAAM;MACNT,KAAK;MACLkB,UAAU;MACVC,UAAU,EAAE;QACVC,OAAO,EAAEF,UAAU,CAACG,gBAAgB,EAAE;QACtC;QACA;QACAC,YAAY,EAAEL,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,UAAU,CAACC,OAAO,CAACG,IAAa;QACxDC,SAAS,EAAEN,UAAU,CAACM;;KAEzB;EACH;EAEA,IAAI,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGzC,KAAK,CAAC0C,QAAQ,CAACX,WAAW,CAAC;EAEnD,IAAIP,MAAM,KAAKgB,KAAK,CAAChB,MAAM,IAAIT,KAAK,KAAKyB,KAAK,CAACzB,KAAK,EAAE;IACpD;IACA;IACA;IACA;IACA;IACA;IACA0B,QAAQ,CAAED,KAAK,GAAGT,WAAW,CAACS,KAAK,CAAE,CAAC;EACxC;EAEA,MAAM;IAAEP,UAAU;IAAEC;EAAU,CAAE,GAAGM,KAAK;EAExCG,gCAAgC,CAC9BhB,iBAAiB,EACjBM,UAAU,CACX;EAEDW,yBAAyB,CACvBV,UAAU;EAAE;EACZD,UAAU;EAAE;EACZN,iBAAiB,CAClB;EAED,MAAMkB,MAAM,GAAGC,SAAS,CAAoBb,UAAU,EAAEC,UAAU,EAAER,GAAG,CAAC;EAExE,MAAMqB,cAAc,GAAG/C,KAAK,CAACgD,OAAO,CAClC,OAAO;IACLC,OAAO,EAAEhB,UAAU,CAACgB,OAAO,CAACC,IAAI,CAACjB,UAAU,CAAC;IAC5CkB,SAAS,EAAElB,UAAU,CAACkB,SAAS,CAACD,IAAI,CAACjB,UAAU,CAAC;IAChDmB,WAAW,EAAEnB,UAAU,CAACmB,WAAW,CAACF,IAAI,CAACjB,UAAU,CAAC;IACpDoB,YAAY,EAAEpB,UAAU,CAACoB,YAAY,CAACH,IAAI,CAACjB,UAAU,CAAC;IACtDqB,WAAW,EAAErB,UAAU,CAACqB,WAAW,CAACJ,IAAI,CAACjB,UAAU,CAAC;IACpDsB,eAAe,EAAEtB,UAAU,CAACsB,eAAe,CAACL,IAAI,CAACjB,UAAU;GAC5D,CAAC,EACF,CAACA,UAAU,CAAC,CACb;EAED,MAAMI,YAAY,GAAGH,UAAU,CAACG,YAAY;EAC5C,OAAOrC,KAAK,CAACgD,OAAO,CAAC,MAAK;IACxB,MAAM;QAAEQ;MAAgB,CAAE,GAAGX,MAAM;MAAfY,IAAI,GAAAC,wBAAA,CAAKb,MAAM,EAAAc,SAAA;IAEnC,OAAAC,aAAA,CAAAA,aAAA,KACKH,IAAI;MACPjC,MAAM;MACNS,UAAU;MACVM,SAAS,EAAEN,UAAU,CAACM,SAAS;MAC/BF;IAAY,GACTU,cAAc;EAErB,CAAC,EAAE,CAACF,MAAM,EAAErB,MAAM,EAAES,UAAU,EAAEI,YAAY,EAAEU,cAAc,CAAC,CAAC;AAChE;AAEA,MAAMc,aAAa,GAAGhD,MAAM,EAAE;AAE9B,SAASe,UAAUA,CACjBb,KAA0D,EAC1DO,OAA0E,EAC1EO,cAA6E;EAE7E,OAAOrB,WAAW,CAAoD,MAAK;IACzE,IAAIc,OAAO,KAAKf,SAAS,EAAE;MACzB,MAAMuD,IAAI,GAAAF,aAAA,CAAAA,aAAA,KACLvD,YAAY,CAACwB,cAAqB,EAAE;QACrCd,KAAK;QACLgD,WAAW,EAAE;OACd,CAAC;QACF,CAACzD,sBAAsB,GAAG;MAAI,EAC/B;MACAwD,IAAY,CAACD,aAAa,CAAC,GAAG,IAAI;MAEnC,OAAOC,IAAI;IACb;IAEA,MAAMnC,iBAAiB,GACrBtB,YAAY,CAACwB,cAAqB,EAAA+B,aAAA,CAAAA,aAAA,KAAOtC,OAAO;MAAEP;IAAK,EAAE,CAAC;IAE5D,IAAIO,OAAO,CAAC0C,IAAI,EAAE;MAChBrC,iBAAiB,CAACsC,kBAAkB,GAClC3C,OAAO,CAAC2C,kBAAkB,IAAI3C,OAAO,CAACyC,WAAW;MACnDpC,iBAAiB,CAACoC,WAAW,GAAG,SAAS;IAC3C;IAEA,OAAOpC,iBAAiB;EAC1B,CAAC,EAAE,CAACZ,KAAK,EAAEO,OAAO,EAAEO,cAAc,CAAC,CAAC;AACtC;AAEA,SAASc,gCAAgCA,CAIvChB,iBAAoE,EACpEM,UAA+C;EAE/C,aAAa;;EACb,IAAI,CAACN,iBAAiB,CAACoC,WAAW,EAAE;IAClCpC,iBAAiB,CAACoC,WAAW,GAAG9B,UAAU,CAACX,OAAO,CAAC2C,kBAAkB;EACvE;AACF;AAEA,SAASnB,SAASA,CAChBb,UAA+C,EAC/CC,UAAiC,EACjCR,GAAwB;EAExB,aAAa;;EACb,OAAOf,oBAAoB,CACzBX,KAAK,CAACkE,WAAW,CACdC,iBAAiB,IAAI;IACpB,MAAMC,YAAY,GAAGnC;IACnB;IACA;IACA;IACA;IACA;IACA;IAAA,CACCoC,IAAI,CAACnE,SAAS,CAACD,aAAa,CAAC,CAAC,CAC9BqE,SAAS,CAAEzB,MAAM,IAAI;MACpB,MAAMb,QAAQ,GAAGE,UAAU,CAACC,OAAO;MAEnC;MACE;MACApC,KAAK,CAACiC,QAAQ,EAAEa,MAAM,CAAC;MACvB;MACA;MACA;MACA9C,KAAK,CAACmC,UAAU,CAACK,SAAS,EAAEN,UAAU,CAACM,SAAS,CAAC,EACjD;QACA;MACF;MAEAL,UAAU,CAACK,SAAS,GAAGN,UAAU,CAACM,SAAS;MAE3C,IAAIP,QAAQ,CAACM,IAAI,IAAI,CAACvC,KAAK,CAACiC,QAAQ,CAACM,IAAI,EAAEO,MAAM,CAACP,IAAI,CAAC,EAAE;QACvDJ,UAAU,CAACG,YAAY,GAAGL,QAAQ,CAACM,IAAa;MAClD;MAEAJ,UAAU,CAACC,OAAO,GAAGU,MAAM;MAC3BsB,iBAAiB,EAAE;IACrB,CAAC,CAAC;IAEJ;IACA;IACA;IACA;IACA,OAAO,MAAK;MACVI,UAAU,CAAC,MAAMH,YAAY,CAACI,WAAW,EAAE,CAAC;IAC9C,CAAC;EACH,CAAC,EAED,CAACvC,UAAU,EAAEC,UAAU,CAAC,CACzB,EACD,MAAMA,UAAU,CAACC,OAAO,EACxB,MAAOT,GAAG,KAAK,KAAK,GAAGZ,QAAQ,CAAC2D,iBAAiB,GAAGvC,UAAU,CAACC,OAAQ,CACxE;AACH;AAEA;AACA;AACA,SAASS,yBAAyBA,CAIhC;AACAV,UAAiC,EACjC;AACAD,UAA+C,EAC/CN,iBAA8E;EAE9E,aAAa;;EACb,IACEM,UAAU,CAACrB,gBAAgB,CAAC,IAC5B,CAACb,KAAK,CAACkC,UAAU,CAACrB,gBAAgB,CAAC,EAAEe,iBAAiB,CAAC,EACvD;IACA;IACA;IACA;IACA,IACGM,UAAU,CAACrB,gBAAgB,CAAS,CAACiD,aAAa,CAAC,IACpD,CAAClC,iBAAiB,CAACsC,kBAAkB,EACrC;MACCtC,iBAAiB,CAACsC,kBAA0B,GAC3CtC,iBAAiB,CAACoC,WAAW;IACjC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIW,eAAe,CAACzC,UAAU,CAACrB,gBAAgB,CAAC,EAAEe,iBAAiB,CAAC,EAAE;MACpEM,UAAU,CAAC0C,SAAS,CAAChD,iBAAiB,CAAC;IACzC,CAAC,MAAM;MACLM,UAAU,CAAC2C,YAAY,CAACjD,iBAAiB,CAAC;IAC5C;IAEA;IACA;IACA;IACA,MAAMkB,MAAM,GAAGZ,UAAU,CAACG,gBAAgB,EAAE;IAE5C,IAAI,CAACrC,KAAK,CAAC8C,MAAM,CAACP,IAAI,EAAEJ,UAAU,CAACC,OAAO,CAACG,IAAI,CAAC,EAAE;MAChDJ,UAAU,CAACG,YAAY,GAAIH,UAAU,CAACC,OAAO,CAACG,IAAI,IAC/CJ,UAAU,CAACG,YAAgC;IAChD;IACAH,UAAU,CAACC,OAAO,GAAGU,MAAM;IAC3BX,UAAU,CAACK,SAAS,GAAGN,UAAU,CAACM,SAAS;EAC7C;EACAN,UAAU,CAACrB,gBAAgB,CAAC,GAAGe,iBAAiB;AAClD;AAEA,SAAS+C,eAAeA,CACtBG,eAA4E,EAC5EvD,OAAoE;EAEpE,OACEuD,eAAe,CAAC9D,KAAK,KAAKO,OAAO,CAACP,KAAK,IACvC,CAAChB,KAAK,CAAC8E,eAAe,CAACtC,SAAS,EAAEjB,OAAO,CAACiB,SAAS,CAAC,IACnDsC,eAAe,CAACd,WAAW,KAAKzC,OAAO,CAACyC,WAAW,KACjDzC,OAAO,CAACyC,WAAW,KAAK,SAAS,IAChCc,eAAe,CAACd,WAAW,KAAK,SAAS,CAAE;AAEnD;AAEAjD,QAAQ,CAAC2D,iBAAiB,GAAGrE,eAAe,CAAC;EAC3C0E,OAAO,EAAE,IAAI;EACbxC,IAAI,EAAE,KAAK,CAAQ;EACnByC,SAAS,EAAE,OAAO;EAClBC,KAAK,EAAE,KAAK,CAAC;EACbC,aAAa,EAAE9E,aAAa,CAAC2E,OAAO;EACpCtB,OAAO,EAAE;CACV,CAAsE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}