{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { equal } from \"@wry/equality\";\nimport { wrap } from \"optimism\";\nimport { addTypenameToDocument, cacheSizes, canonicalStringify, DocumentTransform, isReference, print } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { getInMemoryCacheMemoryInternals } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { hasOwn, normalizeConfig } from \"./helpers.js\";\nimport { Policies } from \"./policies.js\";\nimport { forgetCache, makeVar, recallCache } from \"./reactiveVars.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nexport class InMemoryCache extends ApolloCache {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"data\", void 0);\n    _defineProperty(this, \"optimisticData\", void 0);\n    _defineProperty(this, \"config\", void 0);\n    _defineProperty(this, \"watches\", new Set());\n    _defineProperty(this, \"storeReader\", void 0);\n    _defineProperty(this, \"storeWriter\", void 0);\n    _defineProperty(this, \"addTypenameTransform\", new DocumentTransform(addTypenameToDocument));\n    _defineProperty(this, \"maybeBroadcastWatch\", void 0);\n    // Override the default value, since InMemoryCache result objects are frozen\n    // in development and expected to remain logically immutable in production.\n    _defineProperty(this, \"assumeImmutableResults\", true);\n    // Dynamically imported code can augment existing typePolicies or\n    // possibleTypes by calling cache.policies.addTypePolicies or\n    // cache.policies.addPossibletypes.\n    _defineProperty(this, \"policies\", void 0);\n    _defineProperty(this, \"makeVar\", makeVar);\n    _defineProperty(this, \"txCount\", 0);\n    this.config = normalizeConfig(config);\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies\n    });\n    this.init();\n  }\n  init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching\n    });\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n    this.resetResultCache();\n  }\n  resetResultCache() {\n    const {\n      fragments\n    } = this.config;\n    this.addTypenameTransform.resetCache();\n    fragments === null || fragments === void 0 || fragments.resetCaches();\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({\n      cache: this,\n      fragments\n    }), fragments);\n    this.maybeBroadcastWatch = wrap((c, options) => {\n      return this.broadcastWatch(c, options);\n    }, {\n      max: cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] || 5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */,\n      makeCacheKey: c => {\n        // Return a cache key (thus enabling result caching) only if we're\n        // currently using a data store that can track cache dependencies.\n        const store = c.optimistic ? this.optimisticData : this.data;\n        if (supportsResultCaching(store)) {\n          const {\n            optimistic,\n            id,\n            variables\n          } = c;\n          return store.makeCacheKey(c.query,\n          // Different watches can have the same query, optimistic\n          // status, rootId, and variables, but if their callbacks are\n          // different, the (identical) result needs to be delivered to\n          // each distinct callback. The easiest way to achieve that\n          // separation is to include c.callback in the cache key for\n          // maybeBroadcastWatch calls. See issue #5733.\n          c.callback, canonicalStringify({\n            optimistic,\n            id,\n            variables\n          }));\n        }\n      }\n    });\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach(group => group.resetCaching());\n  }\n  restore(data) {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n  extract() {\n    let optimistic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n  read(options) {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false\n    } = options;\n    return this.storeReader.diffQueryAgainstStore(_objectSpread(_objectSpread({}, options), {}, {\n      store: options.optimistic ? this.optimisticData : this.data,\n      config: this.config,\n      returnPartialData\n    })).result;\n  }\n  write(options) {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n  modify(options) {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store = options.optimistic // Defaults to false.\n    ? this.optimisticData : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields, false);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n  diff(options) {\n    return this.storeReader.diffQueryAgainstStore(_objectSpread(_objectSpread({}, options), {}, {\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config\n    }));\n  }\n  watch(watch) {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n  gc(options) {\n    canonicalStringify.reset();\n    print.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount && options.resetResultCache) {\n      this.resetResultCache();\n    }\n    return ids;\n  }\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  retain(rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  release(rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  identify(object) {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      __DEV__ && invariant.warn(e);\n    }\n  }\n  evict(options) {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        id: \"ROOT_QUERY\"\n      });\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n  reset(options) {\n    this.init();\n    canonicalStringify.reset();\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach(watch => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n    return Promise.resolve();\n  }\n  removeOptimistic(idToRemove) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n  /**\n  * Executes multiple cache operations as a single batch, ensuring that\n  * watchers are only notified once after all operations complete. This is\n  * useful for improving performance when making multiple cache updates, as it\n  * prevents unnecessary re-renders or query refetches between individual\n  * operations.\n  * \n  * The `batch` method supports both optimistic and non-optimistic updates, and\n  * provides fine-grained control over which cache layer receives the updates\n  * and when watchers are notified.\n  * \n  * For usage instructions, see [Interacting with cached data: `cache.batch`](https://www.apollographql.com/docs/react/caching/cache-interaction#using-cachebatch).\n  * \n  * @example\n  * \n  * ```js\n  * cache.batch({\n  *   update(cache) {\n  *     cache.writeQuery({\n  *       query: GET_TODOS,\n  *       data: { todos: updatedTodos },\n  *     });\n  *     cache.evict({ id: \"Todo:123\" });\n  *   },\n  * });\n  * ```\n  * \n  * @example\n  * \n  * ```js\n  * // Optimistic update with a custom layer ID\n  * cache.batch({\n  *   optimistic: \"add-todo-optimistic\",\n  *   update(cache) {\n  *     cache.modify({\n  *       fields: {\n  *         todos(existing = []) {\n  *           return [...existing, newTodoRef];\n  *         },\n  *       },\n  *     });\n  *   },\n  * });\n  * ```\n  * \n  * @returns The return value of the `update` function.\n  */\n  batch(options) {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated\n    } = options;\n    let updateResult;\n    const perform = layer => {\n      const {\n        data,\n        optimisticData\n      } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return updateResult = update(this);\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n    const alreadyDirty = new Set();\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches(_objectSpread(_objectSpread({}, options), {}, {\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        }\n      }));\n    }\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches(_objectSpread(_objectSpread({}, options), {}, {\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        }\n      }));\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(watch => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n    return updateResult;\n  }\n  performTransaction(update, optimisticId) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null\n    });\n  }\n  transformDocument(document) {\n    return this.addTypenameTransform.transformDocument(this.addFragmentsToDocument(document));\n  }\n  fragmentMatches(fragment, typename) {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n  lookupFragment(fragmentName) {\n    var _this$config$fragment;\n    return ((_this$config$fragment = this.config.fragments) === null || _this$config$fragment === void 0 ? void 0 : _this$config$fragment.lookup(fragmentName)) || null;\n  }\n  resolvesClientField(typename, fieldName) {\n    return !!this.policies.getReadFunction(typename, fieldName);\n  }\n  broadcastWatches(options) {\n    if (!this.txCount) {\n      const prevOnAfter = this.onAfterBroadcast;\n      const callbacks = new Set();\n      this.onAfterBroadcast = cb => {\n        callbacks.add(cb);\n      };\n      try {\n        this.watches.forEach(c => this.maybeBroadcastWatch(c, options));\n        callbacks.forEach(cb => cb());\n      } finally {\n        this.onAfterBroadcast = prevOnAfter;\n      }\n    }\n  }\n  addFragmentsToDocument(document) {\n    const {\n      fragments\n    } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  broadcastWatch(c, options) {\n    const {\n      lastDiff\n    } = c;\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff(c);\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  }\n}\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}","map":{"version":3,"names":["equal","wrap","addTypenameToDocument","cacheSizes","canonicalStringify","DocumentTransform","isReference","print","__DEV__","getInMemoryCacheMemoryInternals","invariant","ApolloCache","EntityStore","supportsResultCaching","hasOwn","normalizeConfig","Policies","forgetCache","makeVar","recallCache","StoreReader","StoreWriter","InMemoryCache","constructor","config","arguments","length","undefined","_defineProperty","Set","policies","cache","dataIdFromObject","possibleTypes","typePolicies","init","rootStore","data","Root","resultCaching","optimisticData","stump","resetResultCache","fragments","addTypenameTransform","resetCache","resetCaches","storeWriter","storeReader","maybeBroadcastWatch","c","options","broadcastWatch","max","makeCacheKey","store","optimistic","id","variables","query","callback","group","forEach","resetCaching","restore","replace","extract","read","returnPartialData","diffQueryAgainstStore","_objectSpread","result","write","txCount","writeToStore","broadcast","broadcastWatches","modify","call","fields","diff","rootId","watch","watches","size","add","immediate","delete","forget","gc","reset","ids","retain","release","identify","object","__ref","e","warn","evict","discardWatches","clear","Promise","resolve","removeOptimistic","idToRemove","newOptimisticData","removeLayer","batch","update","onWatchUpdated","updateResult","perform","layer","alreadyDirty","addLayer","dirty","performTransaction","optimisticId","transformDocument","document","addFragmentsToDocument","fragmentMatches","fragment","typename","lookupFragment","fragmentName","_this$config$fragment","lookup","resolvesClientField","fieldName","getReadFunction","prevOnAfter","onAfterBroadcast","callbacks","cb","transform","lastDiff","fromOptimisticTransaction","prototype","getMemoryInternals"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/cache/inmemory/inMemoryCache.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type { OperationVariables } from \"@apollo/client\";\nimport type {\n  DeepPartial,\n  Reference,\n  StoreObject,\n} from \"@apollo/client/utilities\";\nimport {\n  addTypenameToDocument,\n  cacheSizes,\n  canonicalStringify,\n  DocumentTransform,\n  isReference,\n  print,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { getInMemoryCacheMemoryInternals } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\n\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { hasOwn, normalizeConfig } from \"./helpers.js\";\nimport { Policies } from \"./policies.js\";\nimport { forgetCache, makeVar, recallCache } from \"./reactiveVars.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache {\n  private data!: EntityStore;\n  private optimisticData!: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions<any, any>>();\n\n  private storeReader!: StoreReader;\n  private storeWriter!: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch!: OptimisticWrapperFunction<\n    [Cache.WatchOptions<any, any>, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions<any, any>]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = normalizeConfig(config);\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache() {\n    const { fragments } = this.config;\n\n    this.addTypenameTransform.resetCache();\n    fragments?.resetCaches();\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({ cache: this, fragments })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max:\n          cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n          defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"],\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<TData = unknown>(\n    options: Cache.ReadOptions<TData, OperationVariables> & {\n      returnPartialData: true;\n    }\n  ): TData | DeepPartial<TData> | null;\n\n  public read<TData = unknown>(\n    options: Cache.ReadOptions<TData, OperationVariables>\n  ): TData | null;\n\n  public read<TData = unknown>(\n    options: Cache.ReadOptions<TData, OperationVariables>\n  ): TData | DeepPartial<TData> | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n\n    return this.storeReader.diffQueryAgainstStore<TData>({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      config: this.config,\n      returnPartialData,\n    }).result;\n  }\n\n  public write<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: Cache.WriteOptions<TData, TVariables>): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store =\n      (\n        options.optimistic // Defaults to false.\n      ) ?\n        this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields, false);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: Cache.DiffOptions<TData, TVariables>): Cache.DiffResult<TData> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(watch: Cache.WatchOptions<TData, TVariables>): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n  }) {\n    canonicalStringify.reset();\n    print.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount && options.resetResultCache) {\n      this.resetResultCache();\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  /**\n   * {@inheritDoc @apollo/client/cache!ApolloCache#batch:member(1)}\n   */\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameTransform.transformDocument(\n      this.addFragmentsToDocument(document)\n    );\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string\n  ): boolean {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return this.config.fragments?.lookup(fragmentName) || null;\n  }\n\n  public resolvesClientField(typename: string, fieldName: string): boolean {\n    return !!this.policies.getReadFunction(typename, fieldName);\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      const prevOnAfter = this.onAfterBroadcast;\n      const callbacks = new Set<() => void>();\n      this.onAfterBroadcast = (cb: () => void) => {\n        callbacks.add(cb);\n      };\n      try {\n        this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n        callbacks.forEach((cb) => cb());\n      } finally {\n        this.onAfterBroadcast = prevOnAfter;\n      }\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff<any>(c);\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public declare getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}