{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { maybeDeepFreeze, resultKeyNameFromField } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { disableWarningsSlot, getFragmentMaskMode } from \"./utils.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n  const mutableTarget = Array.isArray(data) ? [] : {};\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  const {\n    knownChanged\n  } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n      const masked = maskSelectionSet(item, selectionSet, context, migration, __DEV__ ? \"\".concat(path || \"\", \"[\").concat(index, \"]\") : void 0);\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n      memo[index] = masked;\n    }\n    return knownChanged.has(memo) ? memo : data;\n  }\n  for (const selection of selectionSet.selections) {\n    let value;\n    // we later want to add accessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n      if (value === void 0) {\n        continue;\n      }\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, __DEV__ ? \"\".concat(path || \"\", \".\").concat(keyName) : void 0);\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        var _Object$getOwnPropert;\n        if (migration && keyName !== \"__typename\" &&\n        // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(memo, keyName)) !== null && _Object$getOwnPropert !== void 0 && _Object$getOwnPropert.value)) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 39, fragmentName);\n      const mode = getFragmentMaskMode(selection);\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n  return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n    __DEV__ && invariant.warn(40, operationName ? \"\".concat(operationType, \" '\").concat(operationName, \"'\") : \"anonymous \".concat(operationType), \"\".concat(path, \".\").concat(fieldName).replace(/^\\./, \"\"));\n    getValue = () => value;\n    return value;\n  };\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true\n  };\n}","map":{"version":3,"names":["Kind","__DEV__","maybeDeepFreeze","resultKeyNameFromField","invariant","disableWarningsSlot","getFragmentMaskMode","maskDefinition","data","selectionSet","context","withValue","masked","maskSelectionSet","Object","isFrozen","getMutableTarget","mutableTargets","has","get","mutableTarget","Array","isArray","set","migration","path","knownChanged","memo","index","item","from","entries","concat","add","selection","selections","value","kind","FIELD","keyName","childSelectionSet","_Object$getOwnPropert","getOwnPropertyDescriptor","defineProperty","getAccessorWarningDescriptor","operationName","operationType","INLINE_FRAGMENT","typeCondition","cache","fragmentMatches","__typename","FRAGMENT_SPREAD","fragmentName","name","fragment","fragmentMap","lookupFragment","mode","keys","length","fieldName","getValue","warn","replace","newValue","enumerable","configurable"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/masking/maskDefinition.ts"],"sourcesContent":["import type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type { ApolloCache } from \"@apollo/client/cache\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { FragmentMap } from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { disableWarningsSlot, getFragmentMaskMode } from \"./utils.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : {};\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add accessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}