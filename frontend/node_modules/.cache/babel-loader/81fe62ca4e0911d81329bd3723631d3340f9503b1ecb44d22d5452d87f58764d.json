{"ast":null,"code":"import _objectWithoutProperties from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _toPropertyKey from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\";\nimport _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"extensions\"];\nimport { Trie } from \"@wry/trie\";\nimport { BREAK, Kind, OperationTypeNode, visit } from \"graphql\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError, concat, EMPTY, filter, finalize, from, lastValueFrom, map, materialize, mergeMap, of, share, shareReplay, Subject, tap } from \"rxjs\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport { CombinedGraphQLErrors, graphQLResultHasProtocolErrors, registerLinkError, toErrorLike } from \"@apollo/client/errors\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"@apollo/client/errors\";\nimport { execute } from \"@apollo/client/link\";\nimport { maskFragment, maskOperation } from \"@apollo/client/masking\";\nimport { cacheSizes, DocumentTransform, isNetworkRequestInFlight, print } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { AutoCleanedWeakCache, checkDocument, extensionsSymbol, filterMap, getDefaultValues, getOperationDefinition, getOperationName, graphQLResultHasError, hasDirectives, hasForcedResolvers, isDocumentNode, isNonNullObject, makeUniqueId, removeDirectivesFromDocument, streamInfoSymbol, toQueryResult } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError } from \"@apollo/client/utilities/invariant\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport { logMissingFieldErrors, ObservableQuery } from \"./ObservableQuery.js\";\nimport { QueryInfo } from \"./QueryInfo.js\";\nexport class QueryManager {\n  constructor(options) {\n    _defineProperty(this, \"defaultOptions\", void 0);\n    _defineProperty(this, \"client\", void 0);\n    /**\n     * The options that were passed to the ApolloClient constructor.\n     */\n    _defineProperty(this, \"clientOptions\", void 0);\n    _defineProperty(this, \"assumeImmutableResults\", void 0);\n    _defineProperty(this, \"documentTransform\", void 0);\n    _defineProperty(this, \"ssrMode\", void 0);\n    _defineProperty(this, \"defaultContext\", void 0);\n    _defineProperty(this, \"dataMasking\", void 0);\n    _defineProperty(this, \"incrementalHandler\", void 0);\n    _defineProperty(this, \"localState\", void 0);\n    _defineProperty(this, \"queryDeduplication\", void 0);\n    /**\n     * Whether to prioritize cache values over network results when\n     * `fetchObservableWithInfo` is called.\n     * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"`\n     * fetchPolicy into a `\"cache-first\"` fetchPolicy, but without influencing\n     * the `fetchPolicy` of the `ObservableQuery`.\n     *\n     * This can e.g. be used to prioritize the cache during the first render after\n     * SSR.\n     */\n    _defineProperty(this, \"prioritizeCacheValues\", false);\n    _defineProperty(this, \"onBroadcast\", void 0);\n    _defineProperty(this, \"mutationStore\", void 0);\n    /**\n     * All ObservableQueries that currently have at least one subscriber.\n     */\n    _defineProperty(this, \"obsQueries\", new Set());\n    // Maps from queryInfo.id strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    _defineProperty(this, \"fetchCancelFns\", new Map());\n    _defineProperty(this, \"transformCache\", new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */));\n    _defineProperty(this, \"requestIdCounter\", 1);\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    _defineProperty(this, \"inFlightLinkObservables\", new Trie(false));\n    _defineProperty(this, \"noCacheWarningsByCause\", new WeakSet());\n    const defaultDocumentTransform = new DocumentTransform(document => this.cache.transformDocument(document),\n    // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.client = options.client;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientOptions = options.clientOptions;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    this.localState = options.localState;\n    this.incrementalHandler = options.incrementalHandler;\n    const documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)\n    // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || {};\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = {};\n    }\n  }\n  get link() {\n    return this.client.link;\n  }\n  get cache() {\n    return this.client.cache;\n  }\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  stop() {\n    this.obsQueries.forEach(oq => oq.stop());\n    this.cancelPendingFetches(newInvariantError(87));\n  }\n  cancelPendingFetches(error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n  async mutate(_ref) {\n    let {\n      mutation,\n      variables,\n      optimisticResponse,\n      updateQueries,\n      refetchQueries = [],\n      awaitRefetchQueries = false,\n      update: updateWithProxyFn,\n      onQueryUpdated,\n      fetchPolicy,\n      errorPolicy,\n      keepRootFields,\n      context\n    } = _ref;\n    const queryInfo = new QueryInfo(this);\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const {\n      hasClientExports\n    } = this.getDocumentInfo(mutation);\n    variables = this.getVariables(mutation, variables);\n    if (hasClientExports) {\n      if (__DEV__) {\n        invariant(this.localState, 88, getOperationName(mutation, \"(anonymous)\"));\n      }\n      variables = await this.localState.getExportedVariables({\n        client: this.client,\n        document: mutation,\n        variables,\n        context\n      });\n    }\n    const mutationStoreValue = this.mutationStore && (this.mutationStore[queryInfo.id] = {\n      mutation,\n      variables,\n      loading: true,\n      error: null\n    });\n    const isOptimistic = optimisticResponse && queryInfo.markMutationOptimistic(optimisticResponse, {\n      document: mutation,\n      variables,\n      cacheWriteBehavior: fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */ : 2 /* CacheWriteBehavior.MERGE */,\n      errorPolicy,\n      context,\n      updateQueries,\n      update: updateWithProxyFn,\n      keepRootFields\n    });\n    this.broadcastQueries();\n    return new Promise((resolve, reject) => {\n      const cause = {};\n      return this.getObservableFromLink(mutation, _objectSpread(_objectSpread({}, context), {}, {\n        optimisticResponse: isOptimistic ? optimisticResponse : void 0\n      }), variables, fetchPolicy, {}, false).observable.pipe(validateDidEmitValue(), mergeMap(result => {\n        const storeResult = _objectSpread({}, result);\n        return from(queryInfo.markMutationResult(storeResult, {\n          document: mutation,\n          variables,\n          cacheWriteBehavior: fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */ : 2 /* CacheWriteBehavior.MERGE */,\n          errorPolicy,\n          context,\n          update: updateWithProxyFn,\n          updateQueries,\n          awaitRefetchQueries,\n          refetchQueries,\n          removeOptimistic: isOptimistic ? queryInfo.id : void 0,\n          onQueryUpdated,\n          keepRootFields\n        }));\n      })).pipe(map(storeResult => {\n        const hasErrors = graphQLResultHasError(storeResult);\n        if (hasErrors && errorPolicy === \"none\") {\n          throw new CombinedGraphQLErrors(removeStreamDetailsFromExtensions(storeResult));\n        }\n        if (mutationStoreValue) {\n          mutationStoreValue.loading = false;\n          mutationStoreValue.error = null;\n        }\n        return storeResult;\n      })).subscribe({\n        next: storeResult => {\n          this.broadcastQueries();\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!queryInfo.hasNext) {\n            const result = {\n              data: this.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                cause\n              })\n            };\n            if (graphQLResultHasError(storeResult)) {\n              result.error = new CombinedGraphQLErrors(storeResult);\n            }\n            if (Object.keys(storeResult.extensions || {}).length) {\n              result.extensions = storeResult.extensions;\n            }\n            resolve(result);\n          }\n        },\n        error: error => {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = error;\n          }\n          if (isOptimistic) {\n            this.cache.removeOptimistic(queryInfo.id);\n          }\n          this.broadcastQueries();\n          if (errorPolicy === \"ignore\") {\n            return resolve({\n              data: undefined\n            });\n          }\n          if (errorPolicy === \"all\") {\n            return resolve({\n              data: undefined,\n              error\n            });\n          }\n          reject(error);\n        }\n      });\n    });\n  }\n  fetchQuery(options, networkStatus) {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n    // do the rest asynchronously to keep the same rejection timing as\n    // checks further in `.mutate`\n    return (async () => lastValueFrom(this.fetchObservableWithInfo(options, {\n      networkStatus\n    }).observable.pipe(filterMap(value => {\n      switch (value.kind) {\n        case \"E\":\n          throw value.error;\n        case \"N\":\n          {\n            if (value.source !== \"newNetworkStatus\") return toQueryResult(value.value);\n          }\n      }\n    })), {\n      // This default is needed when a `standby` fetch policy is used to avoid\n      // an EmptyError from rejecting this promise.\n      defaultValue: {\n        data: undefined\n      }\n    }))();\n  }\n  transform(document) {\n    return this.documentTransform.transformDocument(document);\n  }\n  getDocumentInfo(document) {\n    const {\n      transformCache\n    } = this;\n    if (!transformCache.has(document)) {\n      const operationDefinition = getOperationDefinition(document);\n      const cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasDirectives([\"client\", \"export\"], document, true),\n        hasForcedResolvers: hasForcedResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        hasIncrementalDirective: hasDirectives([\"defer\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: hasDirectives([\"client\"], document) ? document : null,\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        operationType: operationDefinition === null || operationDefinition === void 0 ? void 0 : operationDefinition.operation,\n        defaultVars: getDefaultValues(operationDefinition),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: _objectSpread(_objectSpread({}, document), {}, {\n          definitions: document.definitions.map(def => {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return _objectSpread(_objectSpread({}, def), {}, {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    const entry = transformCache.get(document);\n    if (entry.violation) {\n      throw entry.violation;\n    }\n    return entry;\n  }\n  getVariables(document, variables) {\n    const defaultVars = this.getDocumentInfo(document).defaultVars;\n    const varsWithDefaults = Object.entries(variables !== null && variables !== void 0 ? variables : {}).map(_ref2 => {\n      let [key, value] = _ref2;\n      return [key, value === undefined ? defaultVars[key] : value];\n    });\n    return _objectSpread(_objectSpread({}, defaultVars), Object.fromEntries(varsWithDefaults));\n  }\n  watchQuery(options) {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n    const query = this.transform(options.query);\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = _objectSpread(_objectSpread({}, options), {}, {\n      variables: this.getVariables(query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = true;\n    }\n    const observable = new ObservableQuery({\n      queryManager: this,\n      options,\n      transformedQuery: query\n    });\n    return observable;\n  }\n  query(options) {\n    const query = this.transform(options.query);\n    return this.fetchQuery(_objectSpread(_objectSpread({}, options), {}, {\n      query\n    })).then(value => _objectSpread(_objectSpread({}, value), {}, {\n      data: this.maskOperation({\n        document: query,\n        data: value === null || value === void 0 ? void 0 : value.data,\n        fetchPolicy: options.fetchPolicy\n      })\n    }));\n  }\n  generateRequestId() {\n    return this.requestIdCounter++;\n  }\n  clearStore() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      discardWatches: true\n    };\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(89));\n    this.obsQueries.forEach(observableQuery => {\n      // Set loading to true so listeners don't trigger unless they want\n      // results with partial data.\n      observableQuery.reset();\n    });\n    if (this.mutationStore) {\n      this.mutationStore = {};\n    }\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n  getObservableQueries() {\n    let include = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"active\";\n    const queries = new Set();\n    const queryNames = new Map();\n    const queryNamesAndQueryStrings = new Map();\n    const legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(desc => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.obsQueries.forEach(oq => {\n      const document = print(this.transform(oq.options.query));\n      if (include === \"all\") {\n        queries.add(oq);\n        return;\n      }\n      const {\n        queryName,\n        options: {\n          fetchPolicy\n        }\n      } = oq;\n      if (include === \"active\" && fetchPolicy === \"standby\") {\n        return;\n      }\n      if (include === \"active\" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(document)) {\n        queries.add(oq);\n        if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n        if (document) queryNamesAndQueryStrings.set(document, true);\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(options => {\n        const oq = new ObservableQuery({\n          queryManager: this,\n          options: _objectSpread(_objectSpread({}, options), {}, {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        queries.add(oq);\n      });\n    }\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n          if (queryName) {\n            __DEV__ && invariant.warn(90, queryName);\n          } else {\n            __DEV__ && invariant.warn(91);\n          }\n        }\n      });\n    }\n    return queries;\n  }\n  refetchObservableQueries() {\n    let includeStandby = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(observableQuery => {\n      const {\n        fetchPolicy\n      } = observableQuery.options;\n      if ((includeStandby || fetchPolicy !== \"standby\") && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  }\n  startGraphQLSubscription(options) {\n    let {\n      query,\n      variables\n    } = options;\n    const {\n      fetchPolicy = \"cache-first\",\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {}\n    } = options;\n    checkDocument(query, OperationTypeNode.SUBSCRIPTION);\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    let restart;\n    if (__DEV__) {\n      invariant(!this.getDocumentInfo(query).hasClientExports || this.localState, 92, getOperationName(query, \"(anonymous)\"));\n    }\n    const observable = (this.getDocumentInfo(query).hasClientExports ? from(this.localState.getExportedVariables({\n      client: this.client,\n      document: query,\n      variables,\n      context\n    })) : of(variables)).pipe(mergeMap(variables => {\n      const {\n        observable,\n        restart: res\n      } = this.getObservableFromLink(query, context, variables, fetchPolicy, extensions);\n      const queryInfo = new QueryInfo(this);\n      restart = res;\n      return observable.pipe(map(rawResult => {\n        var _rawResult$data;\n        queryInfo.markSubscriptionResult(rawResult, {\n          document: query,\n          variables,\n          errorPolicy,\n          cacheWriteBehavior: fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */ : 2 /* CacheWriteBehavior.MERGE */\n        });\n        const result = {\n          data: (_rawResult$data = rawResult.data) !== null && _rawResult$data !== void 0 ? _rawResult$data : undefined\n        };\n        if (graphQLResultHasError(rawResult)) {\n          result.error = new CombinedGraphQLErrors(rawResult);\n        } else if (graphQLResultHasProtocolErrors(rawResult)) {\n          result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n          // Don't emit protocol errors added by HttpLink\n          delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n        }\n        if (rawResult.extensions && Object.keys(rawResult.extensions).length) {\n          result.extensions = rawResult.extensions;\n        }\n        if (result.error && errorPolicy === \"none\") {\n          result.data = undefined;\n        }\n        if (errorPolicy === \"ignore\") {\n          delete result.error;\n        }\n        return result;\n      }), catchError(error => {\n        if (errorPolicy === \"ignore\") {\n          return of({\n            data: undefined\n          });\n        }\n        return of({\n          data: undefined,\n          error\n        });\n      }), filter(result => !!(result.data || result.error)));\n    }));\n    return Object.assign(observable, {\n      restart: () => {\n        var _restart;\n        return (_restart = restart) === null || _restart === void 0 ? void 0 : _restart();\n      }\n    });\n  }\n  broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.obsQueries.forEach(observableQuery => observableQuery.notify());\n  }\n  getObservableFromLink(query, context, variables, fetchPolicy, extensions) {\n    var _context$queryDedupli, _context;\n    let deduplication = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : (_context$queryDedupli = (_context = context) === null || _context === void 0 ? void 0 : _context.queryDeduplication) !== null && _context$queryDedupli !== void 0 ? _context$queryDedupli : this.queryDeduplication;\n    let entry = {};\n    const {\n      serverQuery,\n      clientQuery,\n      operationType,\n      hasIncrementalDirective\n    } = this.getDocumentInfo(query);\n    const operationName = getOperationName(query);\n    const executeContext = {\n      client: this.client\n    };\n    if (serverQuery) {\n      const {\n        inFlightLinkObservables,\n        link\n      } = this;\n      try {\n        const operation = this.incrementalHandler.prepareRequest({\n          query: serverQuery,\n          variables,\n          context: _objectSpread(_objectSpread(_objectSpread({}, this.defaultContext), context), {}, {\n            queryDeduplication: deduplication\n          }),\n          extensions\n        });\n        context = operation.context;\n        function withRestart(source) {\n          return new Observable(observer => {\n            var _entry;\n            function subscribe() {\n              return source.subscribe({\n                next: observer.next.bind(observer),\n                complete: observer.complete.bind(observer),\n                error: observer.error.bind(observer)\n              });\n            }\n            let subscription = subscribe();\n            (_entry = entry).restart || (_entry.restart = () => {\n              subscription.unsubscribe();\n              subscription = subscribe();\n            });\n            return () => {\n              subscription.unsubscribe();\n              entry.restart = undefined;\n            };\n          });\n        }\n        if (deduplication) {\n          const printedServerQuery = print(serverQuery);\n          const varJson = canonicalStringify(variables);\n          entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);\n          if (!entry.observable) {\n            entry.observable = execute(link, operation, executeContext).pipe(withRestart, finalize(() => {\n              if (inFlightLinkObservables.peek(printedServerQuery, varJson) === entry) {\n                inFlightLinkObservables.remove(printedServerQuery, varJson);\n              }\n            }),\n            // We don't want to replay the last emitted value for\n            // subscriptions and instead opt to wait to receive updates until\n            // the subscription emits new values.\n            operationType === OperationTypeNode.SUBSCRIPTION ? share() : shareReplay({\n              refCount: true\n            }));\n          }\n        } else {\n          entry.observable = execute(link, operation, executeContext).pipe(withRestart);\n        }\n      } catch (error) {\n        entry.observable = throwError(() => error);\n      }\n    } else {\n      entry.observable = of({\n        data: {}\n      });\n    }\n    if (clientQuery) {\n      const {\n        operation\n      } = getOperationDefinition(query);\n      if (__DEV__) {\n        invariant(this.localState, 93, operation[0].toUpperCase() + operation.slice(1), operationName !== null && operationName !== void 0 ? operationName : \"(anonymous)\");\n      }\n      invariant(!hasIncrementalDirective, 94, operation[0].toUpperCase() + operation.slice(1), operationName !== null && operationName !== void 0 ? operationName : \"(anonymous)\");\n      entry.observable = entry.observable.pipe(mergeMap(result => {\n        return from(this.localState.execute({\n          client: this.client,\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n          fetchPolicy\n        }));\n      }));\n    }\n    return {\n      restart: () => {\n        var _entry$restart, _entry2;\n        return (_entry$restart = (_entry2 = entry).restart) === null || _entry$restart === void 0 ? void 0 : _entry$restart.call(_entry2);\n      },\n      observable: entry.observable.pipe(catchError(error => {\n        error = toErrorLike(error);\n        registerLinkError(error);\n        throw error;\n      }))\n    };\n  }\n  getResultsFromLink(options, _ref3) {\n    let {\n      queryInfo,\n      cacheWriteBehavior,\n      observableQuery,\n      exposeExtensions\n    } = _ref3;\n    const requestId = queryInfo.lastRequestId = this.generateRequestId();\n    const {\n      errorPolicy\n    } = options;\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n    return this.getObservableFromLink(linkDocument, options.context, options.variables, options.fetchPolicy).observable.pipe(map(incoming => {\n      // Use linkDocument rather than queryInfo.document so the\n      // operation/fragments used to write the result are the same as the\n      // ones used to obtain it from the link.\n      const result = queryInfo.markQueryResult(incoming, _objectSpread(_objectSpread({}, options), {}, {\n        document: linkDocument,\n        cacheWriteBehavior\n      }));\n      const hasErrors = graphQLResultHasError(result);\n      if (hasErrors && errorPolicy === \"none\") {\n        queryInfo.resetLastWrite();\n        observableQuery === null || observableQuery === void 0 || observableQuery[\"resetNotifications\"]();\n        throw new CombinedGraphQLErrors(removeStreamDetailsFromExtensions(result));\n      }\n      const aqr = _objectSpread({\n        data: result.data\n      }, queryInfo.hasNext ? {\n        loading: true,\n        networkStatus: NetworkStatus.streaming,\n        dataState: \"streaming\",\n        partial: true\n      } : {\n        dataState: result.data ? \"complete\" : \"empty\",\n        loading: false,\n        networkStatus: NetworkStatus.ready,\n        partial: !result.data\n      });\n      if (exposeExtensions && \"extensions\" in result) {\n        aqr[extensionsSymbol] = result.extensions;\n      }\n      // In the case we start multiple network requests simultaneously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n      if (hasErrors) {\n        if (errorPolicy === \"none\") {\n          aqr.data = void 0;\n          aqr.dataState = \"empty\";\n        }\n        if (errorPolicy !== \"ignore\") {\n          aqr.error = new CombinedGraphQLErrors(removeStreamDetailsFromExtensions(result));\n          if (aqr.dataState !== \"streaming\") {\n            aqr.networkStatus = NetworkStatus.error;\n          }\n        }\n      }\n      return aqr;\n    }), catchError(error => {\n      // Avoid storing errors from older interrupted queries.\n      if (requestId >= queryInfo.lastRequestId && errorPolicy === \"none\") {\n        queryInfo.resetLastWrite();\n        observableQuery === null || observableQuery === void 0 || observableQuery[\"resetNotifications\"]();\n        throw error;\n      }\n      const aqr = {\n        data: undefined,\n        dataState: \"empty\",\n        loading: false,\n        networkStatus: NetworkStatus.ready,\n        partial: true\n      };\n      if (errorPolicy !== \"ignore\") {\n        aqr.error = error;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return of(aqr);\n    }));\n  }\n  fetchObservableWithInfo(options, _ref4) {\n    let {\n      // The initial networkStatus for this fetch, most often\n      // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n      // or setVariables.\n      networkStatus = NetworkStatus.loading,\n      query = options.query,\n      fetchQueryOperator = x => x,\n      onCacheHit = () => {},\n      observableQuery,\n      exposeExtensions\n    } = _ref4;\n    const variables = this.getVariables(query, options.variables);\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = defaults && defaults.fetchPolicy || \"cache-first\",\n      errorPolicy = defaults && defaults.errorPolicy || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = true,\n      context = {}\n    } = options;\n    if (this.prioritizeCacheValues && (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")) {\n      fetchPolicy = \"cache-first\";\n    }\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context\n    });\n    const queryInfo = new QueryInfo(this, observableQuery);\n    const fromVariables = variables => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      const cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n      // Watched queries must opt into overwriting existing data on refetch,\n      // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : networkStatus === NetworkStatus.refetch && normalized.refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */ : 2 /* CacheWriteBehavior.MERGE */;\n      const observableWithInfo = this.fetchQueryByPolicy(normalized, {\n        queryInfo,\n        cacheWriteBehavior,\n        onCacheHit,\n        observableQuery,\n        exposeExtensions\n      });\n      observableWithInfo.observable = observableWithInfo.observable.pipe(fetchQueryOperator);\n      if (\n      // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\") {\n        observableQuery === null || observableQuery === void 0 || observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return observableWithInfo;\n    };\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => {\n      this.fetchCancelFns.delete(queryInfo.id);\n    };\n    this.fetchCancelFns.set(queryInfo.id, error => {\n      fetchCancelSubject.next({\n        kind: \"E\",\n        error,\n        source: \"network\"\n      });\n    });\n    const fetchCancelSubject = new Subject();\n    let observable, containsDataFromLink;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      if (__DEV__) {\n        invariant(this.localState, 95, getOperationName(normalized.query, \"(anonymous)\"));\n      }\n      observable = from(this.localState.getExportedVariables({\n        client: this.client,\n        document: normalized.query,\n        variables: normalized.variables,\n        context: normalized.context\n      })).pipe(mergeMap(variables => fromVariables(variables).observable));\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      observable = sourcesWithInfo.observable;\n    }\n    return {\n      // Merge `observable` with `fetchCancelSubject`, in a way that completing or\n      // erroring either of them will complete the merged obserable.\n      observable: new Observable(observer => {\n        observer.add(cleanupCancelFn);\n        observable.subscribe(observer);\n        fetchCancelSubject.subscribe(observer);\n      }).pipe(share()),\n      fromLink: containsDataFromLink\n    };\n  }\n  refetchQueries(_ref5) {\n    let {\n      updateCache,\n      include,\n      optimistic = false,\n      removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n      onQueryUpdated\n    } = _ref5;\n    const includedQueriesByOq = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(oq => {\n        if (oq.options.fetchPolicy === \"cache-only\" || oq[\"variablesUnknown\"]) {\n          return;\n        }\n        const current = oq.getCurrentResult();\n        includedQueriesByOq.set(oq, {\n          oq,\n          lastDiff: {\n            result: current === null || current === void 0 ? void 0 : current.data,\n            complete: !(current !== null && current !== void 0 && current.partial)\n          }\n        });\n      });\n    }\n    const results = new Map();\n    if (updateCache) {\n      const handled = new Set();\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq = watch.watcher;\n          if (oq instanceof ObservableQuery && !handled.has(oq)) {\n            handled.add(oq);\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesByOq.delete(oq);\n              let result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch().retain(\n\n                  /* create a persistent subscription on the query */);\n              }\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n            if (onQueryUpdated !== null && oq.options.fetchPolicy !== \"cache-only\") {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesByOq.set(oq, {\n                oq,\n                lastDiff,\n                diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesByOq.size) {\n      includedQueriesByOq.forEach(_ref6 => {\n        let {\n          oq,\n          lastDiff,\n          diff\n        } = _ref6;\n        let result;\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = oq.getCacheDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch().retain(\n\n            /* create a persistent subscription on the query */);\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  }\n  maskOperation(options) {\n    const {\n      document,\n      data\n    } = options;\n    if (__DEV__) {\n      var _getOperationDefiniti;\n      const {\n        fetchPolicy,\n        cause = {}\n      } = options;\n      const operationType = (_getOperationDefiniti = getOperationDefinition(document)) === null || _getOperationDefiniti === void 0 ? void 0 : _getOperationDefiniti.operation;\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByCause.has(cause)) {\n        this.noCacheWarningsByCause.add(cause);\n        __DEV__ && invariant.warn(96, getOperationName(document, \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\")));\n      }\n    }\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  }\n  maskFragment(options) {\n    const {\n      data,\n      fragment,\n      fragmentName\n    } = options;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  }\n  fetchQueryByPolicy(_ref7, _ref8) {\n    let {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      context\n    } = _ref7;\n    let {\n      cacheWriteBehavior,\n      onCacheHit,\n      queryInfo,\n      observableQuery,\n      exposeExtensions\n    } = _ref8;\n    const readCache = () => this.cache.diff({\n      query,\n      variables,\n      returnPartialData: true,\n      optimistic: true\n    });\n    const resultsFromCache = (diff, networkStatus) => {\n      const data = diff.result;\n      if (__DEV__ && !returnPartialData && data !== null) {\n        logMissingFieldErrors(diff.missing);\n      }\n      const toResult = data => {\n        // TODO: Eventually we should move this handling into\n        // queryInfo.getDiff() directly. Since getDiff is updated to return null\n        // on returnPartialData: false, we should take advantage of that instead\n        // of having to patch it elsewhere.\n        if (!diff.complete && !returnPartialData) {\n          data = undefined;\n        }\n        return {\n          // TODO: Handle partial data\n          data: data,\n          dataState: diff.complete ? \"complete\" : data ? \"partial\" : \"empty\",\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          partial: !diff.complete\n        };\n      };\n      const fromData = data => {\n        return of({\n          kind: \"N\",\n          value: toResult(data),\n          source: \"cache\"\n        });\n      };\n      if (\n      // Don't attempt to run forced resolvers if we have incomplete cache\n      // data and partial isn't allowed since this result would get set to\n      // `undefined` anyways in `toResult`.\n      (diff.complete || returnPartialData) && this.getDocumentInfo(query).hasForcedResolvers) {\n        if (__DEV__) {\n          invariant(this.localState, 97, getOperationName(query, \"(anonymous)\"));\n        }\n        onCacheHit();\n        return from(this.localState.execute({\n          client: this.client,\n          document: query,\n          remoteResult: data ? {\n            data\n          } : undefined,\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n          returnPartialData: true,\n          fetchPolicy\n        }).then(resolved => ({\n          kind: \"N\",\n          value: toResult(resolved.data || void 0),\n          source: \"cache\"\n        })));\n      }\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && diff.missing) {\n        return fromData(void 0);\n      }\n      return fromData(data || undefined);\n    };\n    const resultsFromLink = () => this.getResultsFromLink({\n      query,\n      variables,\n      context,\n      fetchPolicy,\n      errorPolicy\n    }, {\n      cacheWriteBehavior,\n      queryInfo,\n      observableQuery,\n      exposeExtensions\n    }).pipe(validateDidEmitValue(), materialize(), map(result => _objectSpread(_objectSpread({}, result), {}, {\n      source: \"network\"\n    })));\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          const diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              observable: resultsFromCache(diff, NetworkStatus.ready)\n            };\n          }\n          if (returnPartialData) {\n            return {\n              fromLink: true,\n              observable: concat(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink())\n            };\n          }\n          return {\n            fromLink: true,\n            observable: resultsFromLink()\n          };\n        }\n      case \"cache-and-network\":\n        {\n          const diff = readCache();\n          if (diff.complete || returnPartialData) {\n            return {\n              fromLink: true,\n              observable: concat(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink())\n            };\n          }\n          return {\n            fromLink: true,\n            observable: resultsFromLink()\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          observable: concat(resultsFromCache(readCache(), NetworkStatus.ready))\n        };\n      case \"network-only\":\n        return {\n          fromLink: true,\n          observable: resultsFromLink()\n        };\n      case \"no-cache\":\n        return {\n          fromLink: true,\n          observable: resultsFromLink()\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          observable: EMPTY\n        };\n    }\n  }\n}\nfunction validateDidEmitValue() {\n  let didEmitValue = false;\n  return tap({\n    next() {\n      didEmitValue = true;\n    },\n    complete() {\n      invariant(didEmitValue, 98);\n    }\n  });\n}\nfunction isFullyUnmaskedOperation(document) {\n  let isUnmasked = true;\n  visit(document, {\n    FragmentSpread: node => {\n      isUnmasked = !!node.directives && node.directives.some(directive => directive.name.value === \"unmask\");\n      if (!isUnmasked) {\n        return BREAK;\n      }\n    }\n  });\n  return isUnmasked;\n}\nfunction addNonReactiveToNamedFragments(document) {\n  return visit(document, {\n    FragmentSpread: node => {\n      var _node$directives;\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if ((_node$directives = node.directives) !== null && _node$directives !== void 0 && _node$directives.some(directive => directive.name.value === \"unmask\")) {\n        return;\n      }\n      return _objectSpread(_objectSpread({}, node), {}, {\n        directives: [...(node.directives || []), {\n          kind: Kind.DIRECTIVE,\n          name: {\n            kind: Kind.NAME,\n            value: \"nonreactive\"\n          }\n        }]\n      });\n    }\n  });\n}\nfunction removeStreamDetailsFromExtensions(original) {\n  var _original$extensions;\n  if (((_original$extensions = original.extensions) === null || _original$extensions === void 0 ? void 0 : _original$extensions[streamInfoSymbol]) == null) {\n    return original;\n  }\n  const {\n      extensions: {\n        [streamInfoSymbol]: _\n      }\n    } = original,\n    extensions = _objectWithoutProperties(original.extensions, [streamInfoSymbol].map(_toPropertyKey)),\n    result = _objectWithoutProperties(original, _excluded);\n  if (Object.keys(extensions).length > 0) {\n    result.extensions = extensions;\n  }\n  return result;\n}","map":{"version":3,"names":["Trie","BREAK","Kind","OperationTypeNode","visit","Observable","throwError","catchError","concat","EMPTY","filter","finalize","from","lastValueFrom","map","materialize","mergeMap","of","share","shareReplay","Subject","tap","canonicalStringify","CombinedGraphQLErrors","graphQLResultHasProtocolErrors","registerLinkError","toErrorLike","PROTOCOL_ERRORS_SYMBOL","execute","maskFragment","maskOperation","cacheSizes","DocumentTransform","isNetworkRequestInFlight","print","__DEV__","AutoCleanedWeakCache","checkDocument","extensionsSymbol","filterMap","getDefaultValues","getOperationDefinition","getOperationName","graphQLResultHasError","hasDirectives","hasForcedResolvers","isDocumentNode","isNonNullObject","makeUniqueId","removeDirectivesFromDocument","streamInfoSymbol","toQueryResult","invariant","newInvariantError","NetworkStatus","logMissingFieldErrors","ObservableQuery","QueryInfo","QueryManager","constructor","options","_defineProperty","Set","Map","WeakSet","defaultDocumentTransform","document","cache","transformDocument","client","defaultOptions","queryDeduplication","clientOptions","ssrMode","assumeImmutableResults","dataMasking","localState","incrementalHandler","documentTransform","defaultContext","onBroadcast","mutationStore","link","stop","obsQueries","forEach","oq","cancelPendingFetches","error","fetchCancelFns","cancel","clear","mutate","_ref","mutation","variables","optimisticResponse","updateQueries","refetchQueries","awaitRefetchQueries","update","updateWithProxyFn","onQueryUpdated","fetchPolicy","errorPolicy","keepRootFields","context","queryInfo","transformForLink","transform","hasClientExports","getDocumentInfo","getVariables","getExportedVariables","mutationStoreValue","id","loading","isOptimistic","markMutationOptimistic","cacheWriteBehavior","broadcastQueries","Promise","resolve","reject","cause","getObservableFromLink","_objectSpread","observable","pipe","validateDidEmitValue","result","storeResult","markMutationResult","removeOptimistic","hasErrors","removeStreamDetailsFromExtensions","subscribe","next","hasNext","data","Object","keys","extensions","length","undefined","fetchQuery","networkStatus","query","QUERY","fetchObservableWithInfo","value","kind","source","defaultValue","transformCache","has","operationDefinition","cacheEntry","hasNonreactiveDirective","hasIncrementalDirective","nonReactiveQuery","addNonReactiveToNamedFragments","clientQuery","serverQuery","name","remove","operationType","operation","defaultVars","asQuery","definitions","def","set","entry","get","violation","varsWithDefaults","entries","_ref2","key","fromEntries","watchQuery","notifyOnNetworkStatusChange","queryManager","transformedQuery","then","generateRequestId","requestIdCounter","clearStore","arguments","discardWatches","observableQuery","reset","getObservableQueries","include","queries","queryNames","queryNamesAndQueryStrings","legacyQueryOptions","Array","isArray","desc","queryString","add","queryName","size","included","nameOrQueryString","warn","refetchObservableQueries","includeStandby","observableQueryPromises","push","refetch","all","startGraphQLSubscription","SUBSCRIPTION","restart","res","rawResult","_rawResult$data","markSubscriptionResult","assign","_restart","notify","_context$queryDedupli","_context","deduplication","operationName","executeContext","inFlightLinkObservables","prepareRequest","withRestart","observer","_entry","bind","complete","subscription","unsubscribe","printedServerQuery","varJson","lookup","peek","refCount","toUpperCase","slice","remoteResult","_entry$restart","_entry2","call","getResultsFromLink","_ref3","exposeExtensions","requestId","lastRequestId","linkDocument","incoming","markQueryResult","resetLastWrite","aqr","streaming","dataState","partial","ready","_ref4","fetchQueryOperator","x","onCacheHit","defaults","returnPartialData","prioritizeCacheValues","normalized","fromVariables","refetchWritePolicy","observableWithInfo","fetchQueryByPolicy","cleanupCancelFn","delete","fetchCancelSubject","containsDataFromLink","sourcesWithInfo","fromLink","_ref5","updateCache","optimistic","includedQueriesByOq","current","getCurrentResult","lastDiff","results","handled","batch","onWatchUpdated","watch","diff","watcher","retain","_ref6","getCacheDiff","_getOperationDefiniti","isFullyUnmaskedOperation","noCacheWarningsByCause","fragment","fragmentName","_ref7","_ref8","readCache","resultsFromCache","missing","toResult","fromData","onlyRunForcedResolvers","resolved","resultsFromLink","didEmitValue","isUnmasked","FragmentSpread","node","directives","some","directive","_node$directives","DIRECTIVE","NAME","original","_original$extensions","_","_objectWithoutProperties","_toPropertyKey","_excluded"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/core/QueryManager.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FormattedExecutionResult,\n} from \"graphql\";\nimport { BREAK, Kind, OperationTypeNode, visit } from \"graphql\";\nimport { Observable, throwError } from \"rxjs\";\nimport {\n  catchError,\n  concat,\n  EMPTY,\n  filter,\n  finalize,\n  from,\n  lastValueFrom,\n  map,\n  materialize,\n  mergeMap,\n  of,\n  share,\n  shareReplay,\n  Subject,\n  tap,\n} from \"rxjs\";\n\nimport type { ApolloCache, Cache } from \"@apollo/client/cache\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport {\n  CombinedGraphQLErrors,\n  graphQLResultHasProtocolErrors,\n  registerLinkError,\n  toErrorLike,\n} from \"@apollo/client/errors\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"@apollo/client/errors\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport { execute } from \"@apollo/client/link\";\nimport type { LocalState } from \"@apollo/client/local-state\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport { maskFragment, maskOperation } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport {\n  cacheSizes,\n  DocumentTransform,\n  isNetworkRequestInFlight,\n  print,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { ExtensionsWithStreamInfo } from \"@apollo/client/utilities/internal\";\nimport {\n  AutoCleanedWeakCache,\n  checkDocument,\n  extensionsSymbol,\n  filterMap,\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  graphQLResultHasError,\n  hasDirectives,\n  hasForcedResolvers,\n  isDocumentNode,\n  isNonNullObject,\n  makeUniqueId,\n  removeDirectivesFromDocument,\n  streamInfoSymbol,\n  toQueryResult,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../utilities/caching/sizes.js\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport { logMissingFieldErrors, ObservableQuery } from \"./ObservableQuery.js\";\nimport { CacheWriteBehavior, QueryInfo } from \"./QueryInfo.js\";\nimport type {\n  DataState,\n  DefaultContext,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesMap,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  OperationVariables,\n  QueryNotification,\n  SubscriptionObservable,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  hasIncrementalDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n  operationType: OperationTypeNode | undefined;\n  violation?: Error | undefined;\n}\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  /**\n   * Can be used to identify the cause to prevent warning for the same cause twice.\n   * This would be an object like e.g. an `ObervableQuery`.\n   * If the `cause` is not provided, we will warn every time.\n   */\n  cause?: object;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\ninterface QueryManagerOptions {\n  client: ApolloClient;\n  clientOptions: ApolloClient.Options;\n  defaultOptions: ApolloClient.DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n  localState: LocalState | undefined;\n  incrementalHandler: Incremental.Handler;\n}\n\nexport declare namespace QueryManager {\n  export type Result<\n    TData,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = ObservableQuery.Result<TData, TStates> & {\n    [extensionsSymbol]?: ExtensionsWithStreamInfo;\n  };\n}\n\nexport class QueryManager {\n  public defaultOptions: ApolloClient.DefaultOptions;\n\n  public readonly client: ApolloClient;\n  /**\n   * The options that were passed to the ApolloClient constructor.\n   */\n  public readonly clientOptions: ApolloClient.Options;\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n  public readonly incrementalHandler: Incremental.Handler;\n  public localState: LocalState | undefined;\n\n  private queryDeduplication: boolean;\n\n  /**\n   * Whether to prioritize cache values over network results when\n   * `fetchObservableWithInfo` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"`\n   * fetchPolicy into a `\"cache-first\"` fetchPolicy, but without influencing\n   * the `fetchPolicy` of the `ObservableQuery`.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after\n   * SSR.\n   */\n  public prioritizeCacheValues: boolean = false;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  /**\n   * All ObservableQueries that currently have at least one subscriber.\n   */\n  public obsQueries = new Set<ObservableQuery<any, any>>();\n\n  // Maps from queryInfo.id strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.client = options.client;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientOptions = options.clientOptions;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    this.localState = options.localState;\n    this.incrementalHandler = options.incrementalHandler;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || {};\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = {};\n    }\n  }\n\n  get link() {\n    return this.client.link;\n  }\n\n  get cache() {\n    return this.client.cache;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.obsQueries.forEach((oq) => oq.stop());\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TCache extends ApolloCache,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy,\n    errorPolicy,\n    keepRootFields,\n    context,\n  }: ApolloClient.MutateOptions<TData, TVariables, TCache> & {\n    errorPolicy: ErrorPolicy;\n    fetchPolicy: MutationFetchPolicy;\n  }): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>> {\n    const queryInfo = new QueryInfo<TData, TVariables, TCache>(this);\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables);\n\n    if (hasClientExports) {\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"Mutation '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n          getOperationName(mutation, \"(anonymous)\")\n        );\n      }\n\n      variables = await this.localState!.getExportedVariables<TVariables>({\n        client: this.client,\n        document: mutation,\n        variables,\n        context,\n      });\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[queryInfo.id] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      queryInfo.markMutationOptimistic(optimisticResponse, {\n        document: mutation,\n        variables,\n        cacheWriteBehavior:\n          fetchPolicy === \"no-cache\" ?\n            CacheWriteBehavior.FORBID\n          : CacheWriteBehavior.MERGE,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      const cause = {};\n      return this.getObservableFromLink<TData>(\n        mutation,\n        {\n          ...context,\n          optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n        },\n        variables,\n        fetchPolicy,\n        {},\n        false\n      )\n        .observable.pipe(\n          validateDidEmitValue(),\n          mergeMap((result) => {\n            const storeResult: typeof result = { ...result };\n\n            return from(\n              queryInfo.markMutationResult(storeResult, {\n                document: mutation,\n                variables,\n                cacheWriteBehavior:\n                  fetchPolicy === \"no-cache\" ?\n                    CacheWriteBehavior.FORBID\n                  : CacheWriteBehavior.MERGE,\n                errorPolicy,\n                context,\n                update: updateWithProxyFn,\n                updateQueries,\n                awaitRefetchQueries,\n                refetchQueries,\n                removeOptimistic: isOptimistic ? queryInfo.id : void 0,\n                onQueryUpdated,\n                keepRootFields,\n              })\n            );\n          })\n        )\n        .pipe(\n          map((storeResult) => {\n            const hasErrors = graphQLResultHasError(storeResult);\n            if (hasErrors && errorPolicy === \"none\") {\n              throw new CombinedGraphQLErrors(\n                removeStreamDetailsFromExtensions(storeResult)\n              );\n            }\n\n            if (mutationStoreValue) {\n              mutationStoreValue.loading = false;\n              mutationStoreValue.error = null;\n            }\n\n            return storeResult;\n          })\n        )\n        .subscribe({\n          next: (storeResult) => {\n            this.broadcastQueries();\n\n            // Since mutations might receive multiple payloads from the\n            // ApolloLink chain (e.g. when used with @defer),\n            // we resolve with a SingleExecutionResult or after the final\n            // ExecutionPatchResult has arrived and we have assembled the\n            // multipart response into a single result.\n            if (!queryInfo.hasNext) {\n              const result: ApolloClient.MutateResult<TData> = {\n                data: this.maskOperation({\n                  document: mutation,\n                  data: storeResult.data,\n                  fetchPolicy,\n                  cause,\n                }) as any,\n              };\n\n              if (graphQLResultHasError(storeResult)) {\n                result.error = new CombinedGraphQLErrors(storeResult);\n              }\n\n              if (Object.keys(storeResult.extensions || {}).length) {\n                result.extensions = storeResult.extensions;\n              }\n\n              resolve(result);\n            }\n          },\n\n          error: (error) => {\n            if (mutationStoreValue) {\n              mutationStoreValue.loading = false;\n              mutationStoreValue.error = error;\n            }\n\n            if (isOptimistic) {\n              this.cache.removeOptimistic(queryInfo.id);\n            }\n\n            this.broadcastQueries();\n\n            if (errorPolicy === \"ignore\") {\n              return resolve({ data: undefined });\n            }\n\n            if (errorPolicy === \"all\") {\n              return resolve({ data: undefined, error });\n            }\n\n            reject(error);\n          },\n        });\n    });\n  }\n\n  public fetchQuery<TData, TVariables extends OperationVariables>(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloClient.QueryResult<TData>> {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n\n    // do the rest asynchronously to keep the same rejection timing as\n    // checks further in `.mutate`\n    return (async () =>\n      lastValueFrom(\n        this.fetchObservableWithInfo(options, {\n          networkStatus,\n        }).observable.pipe(\n          filterMap((value) => {\n            switch (value.kind) {\n              case \"E\":\n                throw value.error;\n              case \"N\": {\n                if (value.source !== \"newNetworkStatus\")\n                  return toQueryResult(value.value);\n              }\n            }\n          })\n        ),\n        {\n          // This default is needed when a `standby` fetch policy is used to avoid\n          // an EmptyError from rejecting this promise.\n          defaultValue: { data: undefined },\n        }\n      ))();\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const operationDefinition = getOperationDefinition(document);\n\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasDirectives([\"client\", \"export\"], document, true),\n        hasForcedResolvers: hasForcedResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        hasIncrementalDirective: hasDirectives([\"defer\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: hasDirectives([\"client\"], document) ? document : null,\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        operationType: operationDefinition?.operation,\n        defaultVars: getDefaultValues(\n          operationDefinition\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    const entry = transformCache.get(document)!;\n    if (entry.violation) {\n      throw entry.violation;\n    }\n    return entry;\n  }\n\n  public getVariables<TVariables extends OperationVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): TVariables {\n    const defaultVars = this.getDocumentInfo(document).defaultVars;\n    const varsWithDefaults = Object.entries(variables ?? {}).map(\n      ([key, value]) => [key, value === undefined ? defaultVars[key] : value]\n    );\n\n    return {\n      ...defaultVars,\n      ...Object.fromEntries(varsWithDefaults),\n    };\n  }\n\n  public watchQuery<\n    TData,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ): ObservableQuery<TData, TVariables> {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = true;\n    }\n\n    const observable = new ObservableQuery<TData, TVariables>({\n      queryManager: this,\n      options,\n      transformedQuery: query,\n    });\n\n    return observable;\n  }\n\n  public query<\n    TData,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.QueryOptions<TData, TVariables>\n  ): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>> {\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVariables>({\n      ...(options as any),\n      query,\n    }).then((value) => ({\n      ...value,\n      data: this.maskOperation({\n        document: query,\n        data: value?.data,\n        fetchPolicy: options.fetchPolicy,\n      }),\n    }));\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.obsQueries.forEach((observableQuery) => {\n      // Set loading to true so listeners don't trigger unless they want\n      // results with partial data.\n      observableQuery.reset();\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = {};\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Set<ObservableQuery<any>>();\n    const queryNames = new Map<string, string | undefined>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<ApolloClient.QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.obsQueries.forEach((oq) => {\n      const document = print(this.transform(oq.options.query));\n      if (include === \"all\") {\n        queries.add(oq);\n        return;\n      }\n\n      const {\n        queryName,\n        options: { fetchPolicy },\n      } = oq;\n\n      if (include === \"active\" && fetchPolicy === \"standby\") {\n        return;\n      }\n\n      if (\n        include === \"active\" ||\n        (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n        (document && queryNamesAndQueryStrings.has(document))\n      ) {\n        queries.add(oq);\n        if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n        if (document) queryNamesAndQueryStrings.set(document, true);\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options) => {\n        const oq = new ObservableQuery({\n          queryManager: this,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        queries.add(oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public refetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloClient.QueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloClient.QueryResult<any>>[] =\n      [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery) => {\n        const { fetchPolicy } = observableQuery.options;\n        if (\n          (includeStandby || fetchPolicy !== \"standby\") &&\n          fetchPolicy !== \"cache-only\"\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startGraphQLSubscription<TData = unknown>(\n    options: ApolloClient.SubscribeOptions<TData>\n  ): SubscriptionObservable<ApolloClient.SubscribeResult<TData>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy = \"cache-first\",\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    checkDocument(query, OperationTypeNode.SUBSCRIPTION);\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    let restart: (() => void) | undefined;\n\n    if (__DEV__) {\n      invariant(\n        !this.getDocumentInfo(query).hasClientExports || this.localState,\n        \"Subscription '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n        getOperationName(query, \"(anonymous)\")\n      );\n    }\n\n    const observable = (\n      this.getDocumentInfo(query).hasClientExports ?\n        from(\n          this.localState!.getExportedVariables({\n            client: this.client,\n            document: query,\n            variables,\n            context,\n          })\n        )\n      : of(variables)).pipe(\n      mergeMap((variables) => {\n        const { observable, restart: res } = this.getObservableFromLink<TData>(\n          query,\n          context,\n          variables,\n          fetchPolicy,\n          extensions\n        );\n\n        const queryInfo = new QueryInfo<TData>(this);\n\n        restart = res;\n        return (observable as Observable<FormattedExecutionResult<TData>>).pipe(\n          map((rawResult): ApolloClient.SubscribeResult<TData> => {\n            queryInfo.markSubscriptionResult(rawResult, {\n              document: query,\n              variables,\n              errorPolicy,\n              cacheWriteBehavior:\n                fetchPolicy === \"no-cache\" ?\n                  CacheWriteBehavior.FORBID\n                : CacheWriteBehavior.MERGE,\n            });\n\n            const result: ApolloClient.SubscribeResult<TData> = {\n              data: rawResult.data ?? undefined,\n            };\n\n            if (graphQLResultHasError(rawResult)) {\n              result.error = new CombinedGraphQLErrors(rawResult);\n            } else if (graphQLResultHasProtocolErrors(rawResult)) {\n              result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n              // Don't emit protocol errors added by HttpLink\n              delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            if (\n              rawResult.extensions &&\n              Object.keys(rawResult.extensions).length\n            ) {\n              result.extensions = rawResult.extensions;\n            }\n\n            if (result.error && errorPolicy === \"none\") {\n              result.data = undefined;\n            }\n\n            if (errorPolicy === \"ignore\") {\n              delete result.error;\n            }\n\n            return result;\n          }),\n          catchError((error) => {\n            if (errorPolicy === \"ignore\") {\n              return of({\n                data: undefined,\n              } as ApolloClient.SubscribeResult<TData>);\n            }\n\n            return of({ data: undefined, error });\n          }),\n          filter((result) => !!(result.data || result.error))\n        );\n      })\n    );\n\n    return Object.assign(observable, { restart: () => restart?.() });\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.obsQueries.forEach((observableQuery) => observableQuery.notify());\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<ApolloLink.Result<any>>;\n    restart?: () => void;\n  }>(false);\n\n  private getObservableFromLink<TData = unknown>(\n    query: DocumentNode,\n    context: DefaultContext | undefined,\n    variables: OperationVariables,\n    fetchPolicy: WatchQueryFetchPolicy,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): {\n    restart: () => void;\n    observable: Observable<ApolloLink.Result<TData>>;\n  } {\n    let entry: {\n      observable?: Observable<ApolloLink.Result<TData>>;\n      // The restart function has to be on a mutable object that way if multiple\n      // client.subscribe() calls are made before the first one subscribes to\n      // the observable, the `restart` function can be updated for all\n      // deduplicated client.subscribe() calls.\n      restart?: () => void;\n    } = {};\n\n    const { serverQuery, clientQuery, operationType, hasIncrementalDirective } =\n      this.getDocumentInfo(query);\n\n    const operationName = getOperationName(query);\n    const executeContext: ApolloLink.ExecuteContext = {\n      client: this.client,\n    };\n\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      try {\n        const operation = this.incrementalHandler.prepareRequest({\n          query: serverQuery,\n          variables,\n          context: {\n            ...this.defaultContext,\n            ...context,\n            queryDeduplication: deduplication,\n          },\n          extensions,\n        });\n\n        context = operation.context;\n\n        function withRestart(source: Observable<ApolloLink.Result>) {\n          return new Observable<ApolloLink.Result>((observer) => {\n            function subscribe() {\n              return source.subscribe({\n                next: observer.next.bind(observer),\n                complete: observer.complete.bind(observer),\n                error: observer.error.bind(observer),\n              });\n            }\n            let subscription = subscribe();\n\n            entry.restart ||= () => {\n              subscription.unsubscribe();\n              subscription = subscribe();\n            };\n\n            return () => {\n              subscription.unsubscribe();\n              entry.restart = undefined;\n            };\n          });\n        }\n\n        if (deduplication) {\n          const printedServerQuery = print(serverQuery);\n          const varJson = canonicalStringify(variables);\n\n          entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);\n\n          if (!entry.observable) {\n            entry.observable = execute(link, operation, executeContext).pipe(\n              withRestart,\n              finalize(() => {\n                if (\n                  inFlightLinkObservables.peek(printedServerQuery, varJson) ===\n                  entry\n                ) {\n                  inFlightLinkObservables.remove(printedServerQuery, varJson);\n                }\n              }),\n              // We don't want to replay the last emitted value for\n              // subscriptions and instead opt to wait to receive updates until\n              // the subscription emits new values.\n              operationType === OperationTypeNode.SUBSCRIPTION ?\n                share()\n              : shareReplay({ refCount: true })\n            ) as Observable<ApolloLink.Result<TData>>;\n          }\n        } else {\n          entry.observable = execute(link, operation, executeContext).pipe(\n            withRestart\n          ) as Observable<ApolloLink.Result<TData>>;\n        }\n      } catch (error) {\n        entry.observable = throwError(() => error);\n      }\n    } else {\n      entry.observable = of({ data: {} } as ApolloLink.Result<TData>);\n    }\n\n    if (clientQuery) {\n      const { operation } = getOperationDefinition(query)!;\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"%s '%s' contains `@client` fields but local state has not been configured.\",\n          operation[0].toUpperCase() + operation.slice(1),\n          operationName ?? \"(anonymous)\"\n        );\n      }\n\n      invariant(\n        !hasIncrementalDirective,\n        \"%s '%s' contains `@client` and `@defer` directives. These cannot be used together.\",\n        operation[0].toUpperCase() + operation.slice(1),\n        operationName ?? \"(anonymous)\"\n      );\n\n      entry.observable = entry.observable.pipe(\n        mergeMap((result) => {\n          return from(\n            this.localState!.execute<TData>({\n              client: this.client,\n              document: clientQuery,\n              remoteResult: result as FormattedExecutionResult<TData>,\n              context,\n              variables,\n              fetchPolicy,\n            })\n          );\n        })\n      );\n    }\n\n    return {\n      restart: () => entry.restart?.(),\n      observable: entry.observable.pipe(\n        catchError((error) => {\n          error = toErrorLike(error);\n          registerLinkError(error);\n          throw error;\n        })\n      ),\n    };\n  }\n\n  private getResultsFromLink<TData, TVariables extends OperationVariables>(\n    options: {\n      query: DocumentNode;\n      variables: TVariables;\n      context: DefaultContext | undefined;\n      fetchPolicy: WatchQueryFetchPolicy;\n      errorPolicy: ErrorPolicy;\n    },\n    {\n      queryInfo,\n      cacheWriteBehavior,\n      observableQuery,\n      exposeExtensions,\n    }: {\n      queryInfo: QueryInfo<TData, TVariables>;\n      cacheWriteBehavior: CacheWriteBehavior;\n      observableQuery: ObservableQuery<TData, TVariables> | undefined;\n      exposeExtensions?: boolean;\n    }\n  ): Observable<ObservableQuery.Result<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n    const { errorPolicy } = options;\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return this.getObservableFromLink<TData>(\n      linkDocument,\n      options.context,\n      options.variables,\n      options.fetchPolicy\n    ).observable.pipe(\n      map((incoming) => {\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        const result = queryInfo.markQueryResult(incoming, {\n          ...options,\n          document: linkDocument,\n          cacheWriteBehavior,\n        });\n        const hasErrors = graphQLResultHasError(result);\n\n        if (hasErrors && errorPolicy === \"none\") {\n          queryInfo.resetLastWrite();\n          observableQuery?.[\"resetNotifications\"]();\n          throw new CombinedGraphQLErrors(\n            removeStreamDetailsFromExtensions(result)\n          );\n        }\n\n        const aqr: QueryManager.Result<TData> = {\n          data: result.data as TData,\n          ...(queryInfo.hasNext ?\n            {\n              loading: true,\n              networkStatus: NetworkStatus.streaming,\n              dataState: \"streaming\",\n              partial: true,\n            }\n          : {\n              dataState: result.data ? \"complete\" : \"empty\",\n              loading: false,\n              networkStatus: NetworkStatus.ready,\n              partial: !result.data,\n            }),\n        } as ObservableQuery.Result<TData>;\n\n        if (exposeExtensions && \"extensions\" in result) {\n          aqr[extensionsSymbol] = result.extensions;\n        }\n\n        // In the case we start multiple network requests simultaneously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors) {\n          if (errorPolicy === \"none\") {\n            aqr.data = void 0 as TData;\n            aqr.dataState = \"empty\";\n          }\n          if (errorPolicy !== \"ignore\") {\n            aqr.error = new CombinedGraphQLErrors(\n              removeStreamDetailsFromExtensions(result)\n            );\n            if (aqr.dataState !== \"streaming\") {\n              aqr.networkStatus = NetworkStatus.error;\n            }\n          }\n        }\n\n        return aqr;\n      }),\n      catchError((error) => {\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId && errorPolicy === \"none\") {\n          queryInfo.resetLastWrite();\n          observableQuery?.[\"resetNotifications\"]();\n          throw error;\n        }\n\n        const aqr: ObservableQuery.Result<TData> = {\n          data: undefined,\n          dataState: \"empty\",\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n          partial: true,\n        };\n\n        if (errorPolicy !== \"ignore\") {\n          aqr.error = error;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return of(aqr);\n      })\n    );\n  }\n\n  public fetchObservableWithInfo<TData, TVariables extends OperationVariables>(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>,\n    {\n      // The initial networkStatus for this fetch, most often\n      // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n      // or setVariables.\n      networkStatus = NetworkStatus.loading,\n      query = options.query,\n      fetchQueryOperator = (x) => x,\n      onCacheHit = () => {},\n      observableQuery,\n      exposeExtensions,\n    }: {\n      networkStatus?: NetworkStatus;\n      query?: DocumentNode;\n      fetchQueryOperator?: <T>(source: Observable<T>) => Observable<T>;\n      onCacheHit?: () => void;\n      observableQuery?: ObservableQuery<TData, TVariables> | undefined;\n      /**\n       * Attach `extensions` to the result object so that it is accessible by\n       * the calling code without being exposed to the emitted result.\n       *\n       * @remarks\n       * Used by e.g. `fetchMore` to add `extensions` to the `cache.writeQuery`\n       * call since it uses a `no-cache` query and cannot be written in\n       * `QueryInfo`.\n       */\n      exposeExtensions?: boolean;\n    }\n  ): ObservableAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVariables;\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = true,\n      context = {},\n    } = options;\n\n    if (\n      this.prioritizeCacheValues &&\n      (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")\n    ) {\n      fetchPolicy = \"cache-first\";\n    }\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const queryInfo = new QueryInfo<TData, TVariables>(this, observableQuery);\n\n    const fromVariables = (variables: TVariables) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const cacheWriteBehavior =\n        fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n          // Watched queries must opt into overwriting existing data on refetch,\n          // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        : (\n          networkStatus === NetworkStatus.refetch &&\n          normalized.refetchWritePolicy !== \"merge\"\n        ) ?\n          CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n      const observableWithInfo = this.fetchQueryByPolicy<TData, TVariables>(\n        normalized,\n        {\n          queryInfo,\n          cacheWriteBehavior,\n          onCacheHit,\n          observableQuery,\n          exposeExtensions,\n        }\n      );\n      observableWithInfo.observable =\n        observableWithInfo.observable.pipe(fetchQueryOperator);\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\"\n      ) {\n        observableQuery?.[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options as any\n        );\n      }\n\n      return observableWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => {\n      this.fetchCancelFns.delete(queryInfo.id);\n    };\n    this.fetchCancelFns.set(queryInfo.id, (error) => {\n      fetchCancelSubject.next({\n        kind: \"E\",\n        error,\n        source: \"network\",\n      });\n    });\n\n    const fetchCancelSubject = new Subject<QueryNotification.Value<TData>>();\n    let observable: Observable<QueryNotification.Value<TData>>,\n      containsDataFromLink: boolean;\n\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"Query '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n          getOperationName(normalized.query, \"(anonymous)\")\n        );\n      }\n\n      observable = from(\n        this.localState!.getExportedVariables({\n          client: this.client,\n          document: normalized.query,\n          variables: normalized.variables,\n          context: normalized.context,\n        })\n      ).pipe(mergeMap((variables) => fromVariables(variables).observable));\n\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      observable = sourcesWithInfo.observable;\n    }\n\n    return {\n      // Merge `observable` with `fetchCancelSubject`, in a way that completing or\n      // erroring either of them will complete the merged obserable.\n      observable: new Observable<QueryNotification.Value<TData>>((observer) => {\n        observer.add(cleanupCancelFn);\n        observable.subscribe(observer);\n        fetchCancelSubject.subscribe(observer);\n      }).pipe(share()),\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesByOq = new Map<\n      ObservableQuery<any>,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq) => {\n        if (oq.options.fetchPolicy === \"cache-only\" || oq[\"variablesUnknown\"]) {\n          return;\n        }\n\n        const current = oq.getCurrentResult();\n        includedQueriesByOq.set(oq, {\n          oq,\n          lastDiff: {\n            result: current?.data,\n            complete: !current?.partial,\n          },\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      const handled = new Set<ObservableQuery<any>>();\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq = watch.watcher;\n\n          if (oq instanceof ObservableQuery && !handled.has(oq)) {\n            handled.add(oq);\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesByOq.delete(oq);\n\n              let result:\n                | TResult\n                | boolean\n                | Promise<ApolloClient.QueryResult<any>> = onQueryUpdated(\n                oq,\n                diff,\n                lastDiff\n              );\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq\n                  .refetch()\n                  .retain(/* create a persistent subscription on the query */);\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (\n              onQueryUpdated !== null &&\n              oq.options.fetchPolicy !== \"cache-only\"\n            ) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesByOq.set(oq, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesByOq.size) {\n      includedQueriesByOq.forEach(({ oq, lastDiff, diff }) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloClient.QueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = oq.getCacheDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq\n            .refetch()\n            .retain(/* create a persistent subscription on the query */);\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByCause = new WeakSet<object>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, cause = {} } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByCause.has(cause)\n      ) {\n        this.noCacheWarningsByCause.add(cause);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document, `Unnamed ${operationType ?? \"operation\"}`)\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVariables extends OperationVariables>(\n    {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n    }: {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      fetchPolicy: WatchQueryFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      returnPartialData?: boolean;\n      context?: DefaultContext;\n    },\n    {\n      cacheWriteBehavior,\n      onCacheHit,\n      queryInfo,\n      observableQuery,\n      exposeExtensions,\n    }: {\n      cacheWriteBehavior: CacheWriteBehavior;\n      onCacheHit: () => void;\n      queryInfo: QueryInfo<TData, TVariables>;\n      observableQuery: ObservableQuery<TData, TVariables> | undefined;\n      exposeExtensions?: boolean;\n    }\n  ): ObservableAndInfo<TData> {\n    const readCache = () =>\n      this.cache.diff<any>({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: true,\n      });\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus: NetworkStatus\n    ): Observable<QueryNotification.FromCache<TData>> => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && data !== null) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const toResult = (\n        data: TData | DeepPartial<TData> | undefined\n      ): ObservableQuery.Result<TData> => {\n        // TODO: Eventually we should move this handling into\n        // queryInfo.getDiff() directly. Since getDiff is updated to return null\n        // on returnPartialData: false, we should take advantage of that instead\n        // of having to patch it elsewhere.\n        if (!diff.complete && !returnPartialData) {\n          data = undefined;\n        }\n\n        return {\n          // TODO: Handle partial data\n          data: data as TData | undefined,\n          dataState:\n            diff.complete ? \"complete\"\n            : data ? \"partial\"\n            : \"empty\",\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          partial: !diff.complete,\n        } as ObservableQuery.Result<TData>;\n      };\n\n      const fromData = (\n        data: TData | DeepPartial<TData> | undefined\n      ): Observable<QueryNotification.FromCache<TData>> => {\n        return of({\n          kind: \"N\",\n          value: toResult(data),\n          source: \"cache\",\n        });\n      };\n\n      if (\n        // Don't attempt to run forced resolvers if we have incomplete cache\n        // data and partial isn't allowed since this result would get set to\n        // `undefined` anyways in `toResult`.\n        (diff.complete || returnPartialData) &&\n        this.getDocumentInfo(query).hasForcedResolvers\n      ) {\n        if (__DEV__) {\n          invariant(\n            this.localState,\n            \"Query '%s' contains `@client` fields but local state has not been configured.\",\n            getOperationName(query, \"(anonymous)\")\n          );\n        }\n        onCacheHit();\n\n        return from(\n          this.localState!.execute<TData>({\n            client: this.client,\n            document: query,\n            remoteResult: data ? { data } : undefined,\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n            returnPartialData: true,\n            fetchPolicy,\n          }).then(\n            (resolved): QueryNotification.FromCache<TData> => ({\n              kind: \"N\",\n              value: toResult(resolved.data || void 0),\n              source: \"cache\",\n            })\n          )\n        );\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        diff.missing\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data || undefined);\n    };\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVariables>(\n        {\n          query,\n          variables,\n          context,\n          fetchPolicy,\n          errorPolicy,\n        },\n        {\n          cacheWriteBehavior,\n          queryInfo,\n          observableQuery,\n          exposeExtensions,\n        }\n      ).pipe(\n        validateDidEmitValue(),\n        materialize(),\n        map(\n          (result): QueryNotification.FromNetwork<TData> => ({\n            ...result,\n            source: \"network\",\n          })\n        )\n      );\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            observable: resultsFromCache(diff, NetworkStatus.ready),\n          };\n        }\n\n        if (returnPartialData) {\n          return {\n            fromLink: true,\n            observable: concat(\n              resultsFromCache(diff, NetworkStatus.loading),\n              resultsFromLink()\n            ),\n          };\n        }\n\n        return { fromLink: true, observable: resultsFromLink() };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData) {\n          return {\n            fromLink: true,\n            observable: concat(\n              resultsFromCache(diff, NetworkStatus.loading),\n              resultsFromLink()\n            ),\n          };\n        }\n\n        return { fromLink: true, observable: resultsFromLink() };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          observable: concat(\n            resultsFromCache(readCache(), NetworkStatus.ready)\n          ),\n        };\n\n      case \"network-only\":\n        return { fromLink: true, observable: resultsFromLink() };\n\n      case \"no-cache\":\n        return { fromLink: true, observable: resultsFromLink() };\n\n      case \"standby\":\n        return { fromLink: false, observable: EMPTY };\n    }\n  }\n}\n\nfunction validateDidEmitValue<T>() {\n  let didEmitValue = false;\n\n  return tap<T>({\n    next() {\n      didEmitValue = true;\n    },\n    complete() {\n      invariant(\n        didEmitValue,\n        \"The link chain completed without emitting a value. This is likely unintentional and should be updated to emit a value before completing.\"\n      );\n    },\n  });\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface ObservableAndInfo<TData> {\n  // Metadata properties that can be returned in addition to the Observable.\n  fromLink: boolean;\n  observable: Observable<QueryNotification.Value<TData>>;\n}\n\nfunction isFullyUnmaskedOperation(document: DocumentNode) {\n  let isUnmasked = true;\n\n  visit(document, {\n    FragmentSpread: (node) => {\n      isUnmasked =\n        !!node.directives &&\n        node.directives.some((directive) => directive.name.value === \"unmask\");\n\n      if (!isUnmasked) {\n        return BREAK;\n      }\n    },\n  });\n\n  return isUnmasked;\n}\n\nfunction addNonReactiveToNamedFragments(document: DocumentNode) {\n  return visit(document, {\n    FragmentSpread: (node) => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (\n        node.directives?.some((directive) => directive.name.value === \"unmask\")\n      ) {\n        return;\n      }\n\n      return {\n        ...node,\n        directives: [\n          ...(node.directives || []),\n          {\n            kind: Kind.DIRECTIVE,\n            name: { kind: Kind.NAME, value: \"nonreactive\" },\n          } satisfies DirectiveNode,\n        ],\n      };\n    },\n  });\n}\n\nfunction removeStreamDetailsFromExtensions(\n  original: FormattedExecutionResult<any, ExtensionsWithStreamInfo>\n): FormattedExecutionResult<any> {\n  if (original.extensions?.[streamInfoSymbol] == null) {\n    return original;\n  }\n\n  const {\n    extensions: { [streamInfoSymbol]: _, ...extensions },\n    ...result\n  } = original;\n\n  if (Object.keys(extensions).length > 0) {\n    (result as FormattedExecutionResult<any>).extensions = extensions;\n  }\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}