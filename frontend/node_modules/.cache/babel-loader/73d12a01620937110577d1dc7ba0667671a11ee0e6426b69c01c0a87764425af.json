{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { isAbstractType, isLeafType, isListType, isNonNullType, isObjectType } from '../type/definition.mjs';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { collectFields, collectSubfields as _collectSubfields } from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) => _collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 || devAssert(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');\n  const {\n    schema,\n    document,\n    variableValues,\n    rootValue\n  } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const {\n      operation\n    } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n    if (isPromise(result)) {\n      return result.then(data => buildResponse(data, exeContext.errors), error => {\n        exeContext.errors.push(error);\n        return buildResponse(null, exeContext.errors);\n      });\n    }\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0 ? {\n    data\n  } : {\n    errors,\n    data\n  };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(false, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe, _options$maxCoercionE;\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n    options\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [new GraphQLError('Must provide operation name if query contains multiple operations.')];\n          }\n          operation = definition;\n        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n          operation = definition;\n        }\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n      default: // ignore non-executable definitions\n    }\n  }\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(\"Unknown operation named \\\"\".concat(operationName, \"\\\".\"))];\n    }\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n  const coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n    maxErrors: (_options$maxCoercionE = options === null || options === void 0 ? void 0 : options.maxCoercionErrors) !== null && _options$maxCoercionE !== void 0 ? _options$maxCoercionE : 50\n  });\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,\n    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,\n    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,\n    errors: []\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n  if (rootType == null) {\n    throw new GraphQLError(\"Schema is not configured to execute \".concat(operation.operation, \" operation.\"), {\n      nodes: operation\n    });\n  }\n  const rootFields = collectFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);\n  const path = undefined;\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return promiseReduce(fields.entries(), (results, _ref) => {\n    let [responseName, fieldNodes] = _ref;\n    const fieldPath = addPath(path, responseName, parentType.name);\n    const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n    if (result === undefined) {\n      return results;\n    }\n    if (isPromise(result)) {\n      return result.then(resolvedResult => {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n  try {\n    for (const [responseName, fieldNodes] of fields.entries()) {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n      if (result !== undefined) {\n        results[responseName] = result;\n        if (isPromise(result)) {\n          containsPromise = true;\n        }\n      }\n    }\n  } catch (error) {\n    if (containsPromise) {\n      // Ensure that any promises returned by other fields are handled, as they may also reject.\n      return promiseForObject(results).finally(() => {\n        throw error;\n      });\n    }\n    throw error;\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n  if (!fieldDef) {\n    return;\n  }\n  const returnType = fieldDef.type;\n  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;\n  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n    if (isPromise(result)) {\n      completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, rawError => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n}\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n    if (completed === null) {\n      throw new Error(\"Cannot return null for non-nullable field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\"));\n    }\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false || invariant(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\"Expected Iterable, but did not find one for field \\\"\".concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\".\"));\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n    try {\n      let completedItem;\n      if (isPromise(item)) {\n        completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));\n      } else {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);\n      }\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, rawError => {\n          const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n  if (serializedResult == null) {\n    throw new Error(\"Expected `\".concat(inspect(returnType), \".serialize(\").concat(inspect(result), \")` to \") + \"return non-nullable value, returned: \".concat(inspect(serializedResult)));\n  }\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var _returnType$resolveTy;\n  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n  if (isPromise(runtimeType)) {\n    return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));\n  }\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" must resolve to an Object type at runtime for field \\\"\").concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\". Either the \\\"\").concat(returnType.name, \"\\\" type should provide a \\\"resolveType\\\" function or each possible type should provide an \\\"isTypeOf\\\" function.\"), fieldNodes);\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n  }\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" must resolve to an Object type at runtime for field \\\"\").concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\" with \") + \"value \".concat(inspect(result), \", received \\\"\").concat(inspect(runtimeTypeName), \"\\\".\"));\n  }\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n  if (runtimeType == null) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" was resolved to a type \\\"\").concat(runtimeTypeName, \"\\\" that does not exist inside the schema.\"), {\n      nodes: fieldNodes\n    });\n  }\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" was resolved to a non-object type \\\"\").concat(runtimeTypeName, \"\\\".\"), {\n      nodes: fieldNodes\n    });\n  }\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\"Runtime Object type \\\"\".concat(runtimeType.name, \"\\\" is not a possible type for \\\"\").concat(returnType.name, \"\\\".\"), {\n      nodes: fieldNodes\n    });\n  }\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then(resolvedIsTypeOf => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n        return executeFields(exeContext, returnType, result, path, subFieldNodes);\n      });\n    }\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\"Expected value of type \\\"\".concat(returnType.name, \"\\\" but got: \").concat(inspect(result), \".\"), {\n    nodes: fieldNodes\n  });\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        if (promisedIsTypeOfResults.length) {\n          // Explicitly ignore any promise rejections\n          Promise.allSettled(promisedIsTypeOfResults)\n          /* c8 ignore next 3 */.catch(() => {\n            // Do nothing\n          });\n        }\n        return type.name;\n      }\n    }\n  }\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n  return parentType.getFields()[fieldName];\n}","map":{"version":3,"names":["devAssert","inspect","invariant","isIterableObject","isObjectLike","isPromise","memoize3","addPath","pathToArray","promiseForObject","promiseReduce","GraphQLError","locatedError","OperationTypeNode","Kind","isAbstractType","isLeafType","isListType","isNonNullType","isObjectType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","assertValidSchema","collectFields","collectSubfields","_collectSubfields","getArgumentValues","getVariableValues","exeContext","returnType","fieldNodes","schema","fragments","variableValues","execute","args","arguments","length","document","rootValue","assertValidExecutionArguments","buildExecutionContext","errors","operation","result","executeOperation","then","data","buildResponse","error","push","executeSync","Error","rawVariableValues","_definition$name","_operation$variableDe","_options$maxCoercionE","contextValue","operationName","fieldResolver","typeResolver","subscribeFieldResolver","options","Object","create","definition","definitions","kind","OPERATION_DEFINITION","undefined","name","value","FRAGMENT_DEFINITION","concat","variableDefinitions","coercedVariableValues","maxErrors","maxCoercionErrors","coerced","defaultFieldResolver","defaultTypeResolver","rootType","getRootType","nodes","rootFields","selectionSet","path","QUERY","executeFields","MUTATION","executeFieldsSerially","SUBSCRIPTION","parentType","sourceValue","fields","entries","results","_ref","responseName","fieldPath","executeField","resolvedResult","containsPromise","finally","source","_fieldDef$resolve","fieldDef","getFieldDef","type","resolveFn","resolve","info","buildResolveInfo","completed","resolved","completeValue","rawError","handleFieldError","fieldName","ofType","completeListValue","completeLeafValue","completeAbstractValue","completeObjectValue","itemType","completedResults","Array","from","item","index","itemPath","completedItem","Promise","all","serializedResult","serialize","_returnType$resolveTy","resolveTypeFn","resolveType","runtimeType","resolvedRuntimeType","ensureValidRuntimeType","runtimeTypeName","getType","isSubType","subFieldNodes","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","i","isTypeOfResult","allSettled","catch","isTypeOfResults","property","fieldNode","getQueryType","getFields"],"sources":["/home/zobair-qauomi/todo_app/node_modules/graphql/execution/execute.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe, _options$maxCoercionE;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n    options,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors:\n        (_options$maxCoercionE =\n          options === null || options === void 0\n            ? void 0\n            : options.maxCoercionErrors) !== null &&\n        _options$maxCoercionE !== void 0\n          ? _options$maxCoercionE\n          : 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  try {\n    for (const [responseName, fieldNodes] of fields.entries()) {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result !== undefined) {\n        results[responseName] = result;\n\n        if (isPromise(result)) {\n          containsPromise = true;\n        }\n      }\n    }\n  } catch (error) {\n    if (containsPromise) {\n      // Ensure that any promises returned by other fields are handled, as they may also reject.\n      return promiseForObject(results).finally(() => {\n        throw error;\n      });\n    }\n\n    throw error;\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        if (promisedIsTypeOfResults.length) {\n          // Explicitly ignore any promise rejections\n          Promise.allSettled(promisedIsTypeOfResults)\n            /* c8 ignore next 3 */\n            .catch(() => {\n              // Do nothing\n            });\n        }\n\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}