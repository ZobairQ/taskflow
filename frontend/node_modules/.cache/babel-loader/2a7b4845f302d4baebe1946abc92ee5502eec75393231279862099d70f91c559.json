{"ast":null,"code":"import _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { DeepMerger, hasDirectives, isNonEmptyArray } from \"@apollo/client/utilities/internal\";\nclass DeferRequest {\n  constructor() {\n    _defineProperty(this, \"hasNext\", true);\n    _defineProperty(this, \"errors\", []);\n    _defineProperty(this, \"extensions\", {});\n    _defineProperty(this, \"data\", {});\n    // This tracks paths for `@stream` arrays that returns items: null due to\n    // errors thrown for non-null array items. We stop processing future updates\n    // to these stream arrays to prevent creating sparse arrays or inserting\n    // `null` for an expected non-null value which could cause runtime crashes.\n    _defineProperty(this, \"ignoredImpossibleStreamPaths\", new Set());\n  }\n  merge(normalized, atPath) {\n    if (normalized.data !== undefined) {\n      this.data = new DeepMerger({\n        arrayMerge: \"truncate\"\n      }).merge(this.data, normalized.data, {\n        atPath\n      });\n    }\n    if (normalized.errors) {\n      this.errors.push(...normalized.errors);\n    }\n    Object.assign(this.extensions, normalized.extensions);\n  }\n  handle() {\n    let cacheData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.data;\n    let chunk = arguments.length > 1 ? arguments[1] : undefined;\n    this.hasNext = chunk.hasNext;\n    this.data = cacheData;\n    if (hasIncrementalChunks(chunk)) {\n      for (const incremental of chunk.incremental) {\n        var _incremental$data;\n        const {\n          path,\n          errors,\n          extensions\n        } = incremental;\n        if (\"items\" in incremental) {\n          var _path$slice$join;\n          // Remove the array index from the end of the array since each future\n          // chunk sends a different array index. This normalizes the path to\n          // ensure we ignore updates to this field if `items` is `null`.\n          const stringPath = (_path$slice$join = path === null || path === void 0 ? void 0 : path.slice(0, -1).join(\".\")) !== null && _path$slice$join !== void 0 ? _path$slice$join : \"\";\n          if (incremental.items === null) {\n            this.ignoredImpossibleStreamPaths.add(stringPath);\n          }\n          if (this.ignoredImpossibleStreamPaths.has(stringPath)) {\n            this.merge({\n              errors,\n              extensions\n            });\n            continue;\n          }\n        }\n        let data = \"items\" in incremental ? incremental.items\n        // Ensure `data: null` isn't merged for `@defer` responses by\n        // falling back to `undefined`\n        : \"data\" in incremental ? (_incremental$data = incremental.data) !== null && _incremental$data !== void 0 ? _incremental$data : undefined : undefined;\n        if (path && typeof path.at(-1) === \"number\" && Array.isArray(data)) {\n          const startingIdx = path.at(-1);\n          data.forEach((item, idx) => {\n            this.merge({\n              data: item\n            }, [...path.slice(0, -1), startingIdx + idx]);\n          });\n        } else {\n          this.merge({\n            data\n          }, path);\n        }\n        this.merge({\n          errors,\n          extensions\n        });\n      }\n    } else {\n      this.merge(chunk);\n    }\n    const result = {\n      data: this.data\n    };\n    if (isNonEmptyArray(this.errors)) {\n      result.errors = this.errors;\n    }\n    if (Object.keys(this.extensions).length > 0) {\n      result.extensions = this.extensions;\n    }\n    return result;\n  }\n}\n/**\n * This handler implements the `@defer` directive as specified in this historical commit:\n * https://github.com/graphql/graphql-spec/tree/48cf7263a71a683fab03d45d309fd42d8d9a6659/spec\n */\nexport class Defer20220824Handler {\n  isIncrementalResult(result) {\n    return \"hasNext\" in result;\n  }\n  extractErrors(result) {\n    const acc = [];\n    const push = _ref => {\n      let {\n        errors\n      } = _ref;\n      if (errors) {\n        acc.push(...errors);\n      }\n    };\n    if (this.isIncrementalResult(result)) {\n      if (\"errors\" in result) {\n        push(result);\n      }\n      if (hasIncrementalChunks(result)) {\n        result.incremental.forEach(push);\n      }\n    }\n    if (acc.length) {\n      return acc;\n    }\n  }\n  prepareRequest(request) {\n    if (hasDirectives([\"defer\", \"stream\"], request.query)) {\n      var _request$context, _context$http;\n      const context = (_request$context = request.context) !== null && _request$context !== void 0 ? _request$context : {};\n      const http = (_context$http = context.http) !== null && _context$http !== void 0 ? _context$http : context.http = {};\n      http.accept = [\"multipart/mixed;deferSpec=20220824\", ...(http.accept || [])];\n    }\n    return request;\n  }\n  startRequest(_) {\n    return new DeferRequest();\n  }\n}\n// only exported for use in tests\nexport function hasIncrementalChunks(result) {\n  return isNonEmptyArray(result.incremental);\n}","map":{"version":3,"names":["DeepMerger","hasDirectives","isNonEmptyArray","DeferRequest","constructor","_defineProperty","Set","merge","normalized","atPath","data","undefined","arrayMerge","errors","push","Object","assign","extensions","handle","cacheData","arguments","length","chunk","hasNext","hasIncrementalChunks","incremental","_incremental$data","path","_path$slice$join","stringPath","slice","join","items","ignoredImpossibleStreamPaths","add","has","at","Array","isArray","startingIdx","forEach","item","idx","result","keys","Defer20220824Handler","isIncrementalResult","extractErrors","acc","_ref","prepareRequest","request","query","_request$context","_context$http","context","http","accept","startRequest","_"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/incremental/handlers/defer20220824.ts"],"sourcesContent":["import type {\n  DocumentNode,\n  FormattedExecutionResult,\n  GraphQLFormattedError,\n} from \"graphql\";\n\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport type { DeepPartial, HKT } from \"@apollo/client/utilities\";\nimport {\n  DeepMerger,\n  hasDirectives,\n  isNonEmptyArray,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { Incremental } from \"../types.js\";\n\nexport declare namespace Defer20220824Handler {\n  interface Defer20220824Result extends HKT {\n    arg1: unknown; // TData\n    arg2: unknown; // TExtensions\n    return: Defer20220824Handler.Chunk<Record<string, unknown>>;\n  }\n  export interface TypeOverrides {\n    AdditionalApolloLinkResultTypes: Defer20220824Result;\n  }\n\n  export type InitialResult<TData = Record<string, unknown>> = {\n    data?: TData | null | undefined;\n    errors?: ReadonlyArray<GraphQLFormattedError>;\n    extensions?: Record<string, unknown>;\n    hasNext: boolean;\n    incremental?: ReadonlyArray<IncrementalResult<TData>>;\n  };\n\n  export type SubsequentResult<TData = Record<string, unknown>> = {\n    extensions?: Record<string, unknown>;\n    hasNext: boolean;\n    incremental?: Array<IncrementalResult<TData>>;\n  };\n\n  export type IncrementalDeferResult<TData = Record<string, unknown>> = {\n    data?: TData | null;\n    errors?: ReadonlyArray<GraphQLFormattedError>;\n    extensions?: Record<string, unknown>;\n    path?: Incremental.Path;\n    label?: string;\n  };\n\n  export type IncrementalStreamResult<TData = Array<unknown>> = {\n    errors?: ReadonlyArray<GraphQLFormattedError>;\n    items?: TData;\n    path?: Incremental.Path;\n    label?: string;\n    extensions?: Record<string, unknown>;\n  };\n\n  export type IncrementalResult<TData = Record<string, unknown>> =\n    | IncrementalDeferResult<TData>\n    | IncrementalStreamResult<TData>;\n\n  export type Chunk<TData extends Record<string, unknown>> =\n    | InitialResult<TData>\n    | SubsequentResult<TData>;\n}\n\nclass DeferRequest<TData extends Record<string, unknown>>\n  implements\n    Incremental.IncrementalRequest<Defer20220824Handler.Chunk<TData>, TData>\n{\n  public hasNext = true;\n\n  private errors: Array<GraphQLFormattedError> = [];\n  private extensions: Record<string, any> = {};\n  private data: any = {};\n  // This tracks paths for `@stream` arrays that returns items: null due to\n  // errors thrown for non-null array items. We stop processing future updates\n  // to these stream arrays to prevent creating sparse arrays or inserting\n  // `null` for an expected non-null value which could cause runtime crashes.\n  private ignoredImpossibleStreamPaths = new Set<string>();\n\n  private merge(\n    normalized: FormattedExecutionResult<TData>,\n    atPath?: DeepMerger.MergeOptions[\"atPath\"]\n  ) {\n    if (normalized.data !== undefined) {\n      this.data = new DeepMerger({ arrayMerge: \"truncate\" }).merge(\n        this.data,\n        normalized.data,\n        { atPath }\n      );\n    }\n    if (normalized.errors) {\n      this.errors.push(...normalized.errors);\n    }\n    Object.assign(this.extensions, normalized.extensions);\n  }\n\n  handle(\n    // we'll get `undefined` here in case of a `no-cache` fetch policy,\n    // so we'll continue with the last value this request had accumulated\n    cacheData: TData | DeepPartial<TData> | null | undefined = this.data,\n    chunk: Defer20220824Handler.Chunk<TData>\n  ): FormattedExecutionResult<TData> {\n    this.hasNext = chunk.hasNext;\n    this.data = cacheData;\n\n    if (hasIncrementalChunks(chunk)) {\n      for (const incremental of chunk.incremental) {\n        const { path, errors, extensions } = incremental;\n\n        if (\"items\" in incremental) {\n          // Remove the array index from the end of the array since each future\n          // chunk sends a different array index. This normalizes the path to\n          // ensure we ignore updates to this field if `items` is `null`.\n          const stringPath = path?.slice(0, -1).join(\".\") ?? \"\";\n\n          if (incremental.items === null) {\n            this.ignoredImpossibleStreamPaths.add(stringPath);\n          }\n\n          if (this.ignoredImpossibleStreamPaths.has(stringPath)) {\n            this.merge({ errors, extensions });\n            continue;\n          }\n        }\n\n        let data: any =\n          \"items\" in incremental ? incremental.items\n            // Ensure `data: null` isn't merged for `@defer` responses by\n            // falling back to `undefined`\n          : \"data\" in incremental ? incremental.data ?? undefined\n          : undefined;\n\n        if (path && typeof path.at(-1) === \"number\" && Array.isArray(data)) {\n          const startingIdx = path.at(-1) as number;\n          data.forEach((item, idx) => {\n            this.merge({ data: item }, [\n              ...path!.slice(0, -1),\n              startingIdx + idx,\n            ]);\n          });\n        } else {\n          this.merge({ data }, path);\n        }\n\n        this.merge({ errors, extensions });\n      }\n    } else {\n      this.merge(chunk);\n    }\n\n    const result: FormattedExecutionResult<TData> = { data: this.data };\n\n    if (isNonEmptyArray(this.errors)) {\n      result.errors = this.errors;\n    }\n\n    if (Object.keys(this.extensions).length > 0) {\n      result.extensions = this.extensions;\n    }\n\n    return result;\n  }\n}\n\n/**\n * This handler implements the `@defer` directive as specified in this historical commit:\n * https://github.com/graphql/graphql-spec/tree/48cf7263a71a683fab03d45d309fd42d8d9a6659/spec\n */\nexport class Defer20220824Handler\n  implements Incremental.Handler<Defer20220824Handler.Chunk<any>>\n{\n  isIncrementalResult(\n    result: Record<string, any>\n  ): result is\n    | Defer20220824Handler.SubsequentResult\n    | Defer20220824Handler.InitialResult {\n    return \"hasNext\" in result;\n  }\n\n  extractErrors(result: ApolloLink.Result<any>) {\n    const acc: GraphQLFormattedError[] = [];\n    const push = ({\n      errors,\n    }: {\n      errors?: ReadonlyArray<GraphQLFormattedError>;\n    }) => {\n      if (errors) {\n        acc.push(...errors);\n      }\n    };\n    if (this.isIncrementalResult(result)) {\n      if (\"errors\" in result) {\n        push(result);\n      }\n      if (hasIncrementalChunks(result)) {\n        result.incremental.forEach(push);\n      }\n    }\n    if (acc.length) {\n      return acc;\n    }\n  }\n\n  prepareRequest(request: ApolloLink.Request): ApolloLink.Request {\n    if (hasDirectives([\"defer\", \"stream\"], request.query)) {\n      const context = request.context ?? {};\n      const http = (context.http ??= {});\n      http.accept = [\n        \"multipart/mixed;deferSpec=20220824\",\n        ...(http.accept || []),\n      ];\n    }\n\n    return request;\n  }\n  startRequest<TData extends Record<string, unknown>>(_: {\n    query: DocumentNode;\n  }) {\n    return new DeferRequest<TData>();\n  }\n}\n\n// only exported for use in tests\nexport function hasIncrementalChunks(\n  result: Record<string, any>\n): result is Required<Defer20220824Handler.SubsequentResult> {\n  return isNonEmptyArray(result.incremental);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}