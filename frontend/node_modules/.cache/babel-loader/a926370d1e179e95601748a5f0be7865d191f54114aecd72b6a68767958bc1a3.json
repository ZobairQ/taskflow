{"ast":null,"code":"import _objectWithoutProperties from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"partial\"];\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport { maybeDeepFreeze, variablesUnknownSymbol } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { useRenderGuard } from \"./internal/index.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\"refetch\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"stopPolling\", \"subscribeToMore\"];\nexport function useLazyQuery(query, options) {\n  const client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  const previousDataRef = React.useRef(undefined);\n  const resultRef = React.useRef(undefined);\n  const stableOptions = useDeepMemo(() => options, [options]);\n  const calledDuringRender = useRenderGuard();\n  function createObservable() {\n    return client.watchQuery(_objectSpread(_objectSpread({}, options), {}, {\n      query,\n      initialFetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n      fetchPolicy: \"standby\",\n      [variablesUnknownSymbol]: true\n    }));\n  }\n  const [currentClient, setCurrentClient] = React.useState(client);\n  const [observable, setObservable] = React.useState(createObservable);\n  if (currentClient !== client) {\n    setCurrentClient(client);\n    setObservable(createObservable());\n  }\n  // TODO: Revisit after we have RxJS in place. We should be able to use\n  // observable.getCurrentResult() (or equivalent) to get these values which\n  // will hopefully alleviate the need for us to use refs to track these values.\n  const updateResult = React.useCallback((result, forceUpdate) => {\n    var _resultRef$current;\n    const previousData = (_resultRef$current = resultRef.current) === null || _resultRef$current === void 0 ? void 0 : _resultRef$current.data;\n    if (previousData && !equal(previousData, result.data)) {\n      previousDataRef.current = previousData;\n    }\n    resultRef.current = result;\n    forceUpdate();\n  }, []);\n  const observableResult = useSyncExternalStore(React.useCallback(forceUpdate => {\n    const subscription = observable.subscribe(result => {\n      if (!equal(resultRef.current, result)) {\n        updateResult(result, forceUpdate);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [observable, updateResult]), () => resultRef.current || initialResult, () => initialResult);\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods = {};\n    for (const key of EAGER_METHODS) {\n      eagerMethods[key] = function () {\n        invariant(resultRef.current, 29, key);\n        // @ts-expect-error this is just to generic to type\n        return observable[key](...arguments);\n      };\n    }\n    return eagerMethods;\n  }, [observable]);\n  React.useEffect(() => {\n    const updatedOptions = {\n      query,\n      errorPolicy: stableOptions === null || stableOptions === void 0 ? void 0 : stableOptions.errorPolicy,\n      refetchWritePolicy: stableOptions === null || stableOptions === void 0 ? void 0 : stableOptions.refetchWritePolicy,\n      returnPartialData: stableOptions === null || stableOptions === void 0 ? void 0 : stableOptions.returnPartialData,\n      notifyOnNetworkStatusChange: stableOptions === null || stableOptions === void 0 ? void 0 : stableOptions.notifyOnNetworkStatusChange,\n      nextFetchPolicy: options === null || options === void 0 ? void 0 : options.nextFetchPolicy,\n      skipPollAttempt: options === null || options === void 0 ? void 0 : options.skipPollAttempt\n    };\n    // Wait to apply the changed fetch policy until after the execute\n    // function has been called. The execute function will handle setting the\n    // the fetch policy away from standby for us when called for the first time.\n    if (observable.options.fetchPolicy !== \"standby\" && stableOptions !== null && stableOptions !== void 0 && stableOptions.fetchPolicy) {\n      updatedOptions.fetchPolicy = stableOptions.fetchPolicy;\n    }\n    observable.applyOptions(updatedOptions);\n  }, [query, observable, stableOptions, // Ensure inline functions don't suffer from stale closures by checking for\n  // these deps separately. @wry/equality doesn't compare function identity\n  // so `stableOptions` isn't updated when using inline functions.\n  options === null || options === void 0 ? void 0 : options.nextFetchPolicy, options === null || options === void 0 ? void 0 : options.skipPollAttempt]);\n  const execute = React.useCallback(function () {\n    var _executeOptions$conte;\n    invariant(!calledDuringRender(), 30);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const [executeOptions] = args;\n    let fetchPolicy = observable.options.fetchPolicy;\n    if (fetchPolicy === \"standby\") {\n      fetchPolicy = observable.options.initialFetchPolicy;\n    }\n    return observable.reobserve({\n      fetchPolicy,\n      // If `variables` is not given, reset back to empty variables by\n      // ensuring the key exists in options\n      variables: executeOptions === null || executeOptions === void 0 ? void 0 : executeOptions.variables,\n      context: (_executeOptions$conte = executeOptions === null || executeOptions === void 0 ? void 0 : executeOptions.context) !== null && _executeOptions$conte !== void 0 ? _executeOptions$conte : {}\n    });\n  }, [observable, calledDuringRender]);\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n  const stableExecute = React.useCallback(function () {\n    return executeRef.current(...arguments);\n  }, []);\n  const result = React.useMemo(() => {\n    const {\n        partial\n      } = observableResult,\n      result = _objectWithoutProperties(observableResult, _excluded);\n    return _objectSpread(_objectSpread(_objectSpread({}, eagerMethods), result), {}, {\n      client,\n      // eslint-disable-next-line react-hooks/refs\n      previousData: previousDataRef.current,\n      variables: observable.variables,\n      observable,\n      // eslint-disable-next-line react-hooks/refs\n      called: !!resultRef.current\n    });\n  }, [client, observableResult, eagerMethods, observable]);\n  return [stableExecute, result];\n}\nconst initialResult = maybeDeepFreeze({\n  data: undefined,\n  dataState: \"empty\",\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  partial: true\n});","map":{"version":3,"names":["equal","React","NetworkStatus","maybeDeepFreeze","variablesUnknownSymbol","invariant","useRenderGuard","useDeepMemo","useIsomorphicLayoutEffect","useApolloClient","useSyncExternalStore","EAGER_METHODS","useLazyQuery","query","options","client","previousDataRef","useRef","undefined","resultRef","stableOptions","calledDuringRender","createObservable","watchQuery","_objectSpread","initialFetchPolicy","fetchPolicy","currentClient","setCurrentClient","useState","observable","setObservable","updateResult","useCallback","result","forceUpdate","_resultRef$current","previousData","current","data","observableResult","subscription","subscribe","unsubscribe","initialResult","eagerMethods","useMemo","key","arguments","useEffect","updatedOptions","errorPolicy","refetchWritePolicy","returnPartialData","notifyOnNetworkStatusChange","nextFetchPolicy","skipPollAttempt","applyOptions","execute","_executeOptions$conte","_len","length","args","Array","_key","executeOptions","reobserve","variables","context","executeRef","stableExecute","partial","_objectWithoutProperties","_excluded","called","dataState","loading","networkStatus","ready"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/react/hooks/useLazyQuery.ts"],"sourcesContent":["import type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  InternalTypes,\n  MaybeMasked,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  SubscribeToMoreFunction,\n  UpdateQueryMapFn,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  variablesUnknownSymbol,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { useRenderGuard } from \"./internal/index.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nexport declare namespace useLazyQuery {\n  import _self = useLazyQuery;\n  export interface Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: InternalTypes.NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n    client?: ApolloClient;\n  }\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends _self.Options<TData, TVariables> {}\n    }\n  }\n\n  namespace Base {\n    export interface Result<TData, TVariables extends OperationVariables> {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#startPolling:member} */\n      startPolling: (pollInterval: number) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#stopPolling:member} */\n      stopPolling: () => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#updateQuery:member} */\n      updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n      refetch: (\n        variables?: Partial<TVariables>\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n      fetchMore: <\n        TFetchData = TData,\n        TFetchVars extends OperationVariables = TVariables,\n      >(\n        fetchMoreOptions: ObservableQuery.FetchMoreOptions<\n          TData,\n          TVariables,\n          TFetchData,\n          TFetchVars\n        >\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TFetchData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#observable:member} */\n      observable: ObservableQuery<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#previousData:member} */\n      previousData?: MaybeMasked<TData>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error?: ErrorLike;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n      loading: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n    }\n  }\n\n  export type Result<\n    TData,\n    TVariables extends OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData, TVariables> &\n    (\n      | ({\n          /**\n           * If `true`, the associated lazy query has been executed.\n           *\n           * @docGroup 2. Network info\n           */\n          called: true;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n          variables: TVariables;\n        } & GetDataState<MaybeMasked<TData>, TStates>)\n      | {\n          /**\n           * If `true`, the associated lazy query has been executed.\n           *\n           * @docGroup 2. Network info\n           */\n          called: false;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n          variables: Partial<TVariables>;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n          data: undefined;\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n          dataState: \"empty\";\n        }\n    );\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface Result<TData, TVariables extends OperationVariables>\n        extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {\n        /**\n         * If `true`, the associated lazy query has been executed.\n         *\n         * @docGroup 2. Network info\n         */\n        called: boolean;\n      }\n    }\n  }\n\n  export type ExecOptions<\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n  } & VariablesOption<TVariables>;\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface ExecOptions<TVariables extends OperationVariables>\n        extends UtilityDocumentationTypes.VariableOptions<TVariables> {\n        /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n        context?: DefaultContext;\n      }\n    }\n  }\n\n  export type ResultTuple<\n    TData,\n    TVariables extends OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = [\n    execute: ExecFunction<TData, TVariables>,\n    result: useLazyQuery.Result<TData, TVariables, TStates>,\n  ];\n\n  export type ExecFunction<TData, TVariables extends OperationVariables> = (\n    ...args: {} extends TVariables ?\n      [options?: useLazyQuery.ExecOptions<TVariables>]\n    : [options: useLazyQuery.ExecOptions<TVariables>]\n  ) => ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>>;\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export import ResultTuple = _self.ResultTuple;\n    }\n  }\n\n  namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\n    export function useLazyQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useLazyQuery.Options<TData, TVariables>\n    ): useLazyQuery.ResultTuple<TData, TVariables>;\n  }\n}\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"stopPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql } from \"@apollo/client\";\n * import { useLazyQuery } from \"@apollo/client/react\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(GET_GREETING, {\n *     variables: { language: \"english\" },\n *   });\n *   if (called && loading) return <p>Loading ...</p>;\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>;\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>>\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\"\n>;\n\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>>\n): useLazyQuery.ResultTuple<TData, TVariables, TStates> {\n  const client = useApolloClient(options?.client);\n  const previousDataRef = React.useRef<TData>(undefined);\n  const resultRef = React.useRef<ObservableQuery.Result<TData>>(undefined);\n  const stableOptions = useDeepMemo(() => options, [options]);\n  const calledDuringRender = useRenderGuard();\n\n  function createObservable() {\n    return client.watchQuery({\n      ...options,\n      query,\n      initialFetchPolicy: options?.fetchPolicy,\n      fetchPolicy: \"standby\",\n      [variablesUnknownSymbol]: true,\n    } as ApolloClient.WatchQueryOptions<TData, TVariables>);\n  }\n\n  const [currentClient, setCurrentClient] = React.useState(client);\n  const [observable, setObservable] = React.useState(createObservable);\n\n  if (currentClient !== client) {\n    setCurrentClient(client);\n    setObservable(createObservable());\n  }\n\n  // TODO: Revisit after we have RxJS in place. We should be able to use\n  // observable.getCurrentResult() (or equivalent) to get these values which\n  // will hopefully alleviate the need for us to use refs to track these values.\n  const updateResult = React.useCallback(\n    (result: ObservableQuery.Result<TData>, forceUpdate: () => void) => {\n      const previousData = resultRef.current?.data;\n\n      if (previousData && !equal(previousData, result.data)) {\n        previousDataRef.current = previousData as TData;\n      }\n\n      resultRef.current = result;\n\n      forceUpdate();\n    },\n    []\n  );\n\n  const observableResult = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        const subscription = observable.subscribe((result) => {\n          if (!equal(resultRef.current, result)) {\n            updateResult(result, forceUpdate);\n          }\n        });\n\n        return () => {\n          subscription.unsubscribe();\n        };\n      },\n      [observable, updateResult]\n    ),\n    () => resultRef.current || initialResult,\n    () => initialResult\n  );\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      eagerMethods[key] = function (...args: any[]) {\n        invariant(\n          resultRef.current,\n          \"useLazyQuery: '%s' cannot be called before executing the query.\",\n          key\n        );\n\n        // @ts-expect-error this is just to generic to type\n        return observable[key](...args);\n      };\n    }\n\n    return eagerMethods as Pick<\n      useLazyQuery.Result<TData, TVariables>,\n      (typeof EAGER_METHODS)[number]\n    >;\n  }, [observable]);\n\n  React.useEffect(() => {\n    const updatedOptions: Partial<ObservableQuery.Options<TData, TVariables>> =\n      {\n        query,\n        errorPolicy: stableOptions?.errorPolicy,\n        refetchWritePolicy: stableOptions?.refetchWritePolicy,\n        returnPartialData: stableOptions?.returnPartialData,\n        notifyOnNetworkStatusChange: stableOptions?.notifyOnNetworkStatusChange,\n        nextFetchPolicy: options?.nextFetchPolicy,\n        skipPollAttempt: options?.skipPollAttempt,\n      };\n\n    // Wait to apply the changed fetch policy until after the execute\n    // function has been called. The execute function will handle setting the\n    // the fetch policy away from standby for us when called for the first time.\n    if (\n      observable.options.fetchPolicy !== \"standby\" &&\n      stableOptions?.fetchPolicy\n    ) {\n      updatedOptions.fetchPolicy = stableOptions.fetchPolicy;\n    }\n\n    observable.applyOptions(updatedOptions);\n  }, [\n    query,\n    observable,\n    stableOptions,\n    // Ensure inline functions don't suffer from stale closures by checking for\n    // these deps separately. @wry/equality doesn't compare function identity\n    // so `stableOptions` isn't updated when using inline functions.\n    options?.nextFetchPolicy,\n    options?.skipPollAttempt,\n  ]);\n\n  const execute: useLazyQuery.ExecFunction<TData, TVariables> =\n    React.useCallback(\n      (...args) => {\n        invariant(\n          !calledDuringRender(),\n          \"useLazyQuery: 'execute' should not be called during render. To start a query during render, use the 'useQuery' hook.\"\n        );\n\n        const [executeOptions] = args;\n\n        let fetchPolicy = observable.options.fetchPolicy;\n\n        if (fetchPolicy === \"standby\") {\n          fetchPolicy = observable.options.initialFetchPolicy;\n        }\n\n        return observable.reobserve({\n          fetchPolicy,\n          // If `variables` is not given, reset back to empty variables by\n          // ensuring the key exists in options\n          variables: executeOptions?.variables,\n          context: executeOptions?.context ?? {},\n        });\n      },\n      [observable, calledDuringRender]\n    );\n\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n\n  const stableExecute = React.useCallback<typeof execute>(\n    (...args) => executeRef.current(...args),\n    []\n  );\n\n  const result = React.useMemo(() => {\n    const { partial, ...result } = observableResult;\n\n    return {\n      ...eagerMethods,\n      ...result,\n      client,\n      // eslint-disable-next-line react-hooks/refs\n      previousData: previousDataRef.current,\n      variables: observable.variables,\n      observable,\n      // eslint-disable-next-line react-hooks/refs\n      called: !!resultRef.current,\n    };\n  }, [client, observableResult, eagerMethods, observable]);\n\n  return [stableExecute, result as any];\n}\n\nconst initialResult: ObservableQuery.Result<any> = maybeDeepFreeze({\n  data: undefined,\n  dataState: \"empty\",\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  partial: true,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}