{"ast":null,"code":"import _objectWithoutProperties from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"id\", \"data\"],\n  _excluded2 = [\"data\", \"fragment\", \"fragmentName\"];\nimport { WeakCache } from \"@wry/caches\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { wrap } from \"optimism\";\nimport { distinctUntilChanged, map, Observable, ReplaySubject, share, shareReplay, tap, timer } from \"rxjs\";\nimport { cacheSizes, canonicalStringify } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { bindCacheKey, combineLatestBatched, equalByQuery, getApolloCacheMemoryInternals, getFragmentDefinition, getFragmentQueryDocument, mapObservableFragmentMemoized } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nexport class ApolloCache {\n  constructor() {\n    _defineProperty(this, \"assumeImmutableResults\", false);\n    _defineProperty(this, \"fragmentWatches\", new Trie(true));\n    /**\n     * Can be overridden by subclasses to delay calling the provided callback\n     * until after all broadcasts have been completed - e.g. in a cache scenario\n     * where many watchers are notified in parallel.\n     */\n    _defineProperty(this, \"onAfterBroadcast\", cb => cb());\n    // Make sure we compute the same (===) fragment query document every\n    // time we receive the same fragment in readFragment.\n    _defineProperty(this, \"getFragmentDoc\", wrap(getFragmentQueryDocument, {\n      max: cacheSizes[\"cache.fragmentQueryDocuments\"] || 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n      cache: WeakCache,\n      makeCacheKey: bindCacheKey(this)\n    }));\n  }\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  lookupFragment(fragmentName) {\n    return null;\n  }\n  // Transactional API\n  /**\n   * Executes multiple cache operations as a single batch, ensuring that\n   * watchers are only notified once after all operations complete. This is\n   * useful for improving performance when making multiple cache updates, as it\n   * prevents unnecessary re-renders or query refetches between individual\n   * operations.\n   *\n   * The `batch` method supports both optimistic and non-optimistic updates, and\n   * provides fine-grained control over which cache layer receives the updates\n   * and when watchers are notified.\n   *\n   * For usage instructions, see [Interacting with cached data: `cache.batch`](https://www.apollographql.com/docs/react/caching/cache-interaction#using-cachebatch).\n   *\n   * @example\n   *\n   * ```js\n   * cache.batch({\n   *   update(cache) {\n   *     cache.writeQuery({\n   *       query: GET_TODOS,\n   *       data: { todos: updatedTodos },\n   *     });\n   *     cache.evict({ id: \"Todo:123\" });\n   *   },\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```js\n   * // Optimistic update with a custom layer ID\n   * cache.batch({\n   *   optimistic: \"add-todo-optimistic\",\n   *   update(cache) {\n   *     cache.modify({\n   *       fields: {\n   *         todos(existing = []) {\n   *           return [...existing, newTodoRef];\n   *         },\n   *       },\n   *     });\n   *   },\n   * });\n   * ```\n   *\n   * @returns The return value of the `update` function.\n   */\n  batch(options) {\n    const optimisticId = typeof options.optimistic === \"string\" ? options.optimistic : options.optimistic === false ? null : void 0;\n    let updateResult;\n    this.performTransaction(() => updateResult = options.update(this), optimisticId);\n    return updateResult;\n  }\n  recordOptimisticTransaction(transaction, optimisticId) {\n    this.performTransaction(transaction, optimisticId);\n  }\n  // Optional API\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  transformDocument(document) {\n    return document;\n  }\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  transformForLink(document) {\n    return document;\n  }\n  identify(object) {\n    return;\n  }\n  gc() {\n    return [];\n  }\n  modify(options) {\n    return false;\n  }\n  readQuery(options) {\n    let optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !!options.optimistic;\n    return this.read(_objectSpread(_objectSpread({}, options), {}, {\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic\n    }));\n  }\n  /**\n  * Watches the cache store of the fragment according to the options specified\n  * and returns an `Observable`. We can subscribe to this\n  * `Observable` and receive updated results through an\n  * observer when the cache store changes.\n  * \n  * You must pass in a GraphQL document with a single fragment or a document\n  * with multiple fragments that represent what you are reading. If you pass\n  * in a document with multiple fragments then you must also specify a\n  * `fragmentName`.\n  * \n  * @since 3.10.0\n  * @param options - An object of type `WatchFragmentOptions` that allows\n  * the cache to identify the fragment and optionally specify whether to react\n  * to optimistic updates.\n  */\n  watchFragment(options) {\n    const {\n      fragment,\n      fragmentName,\n      from\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    const fromArray = Array.isArray(from) ? from : [from];\n    const ids = fromArray.map(value => {\n      // While our TypeScript types do not allow for `undefined` as a valid\n      // `from`, its possible `useFragment` gives us an `undefined` since it\n      // calls` cache.identify` and provides that value to `from`. We are\n      // adding this fix here however to ensure those using plain JavaScript\n      // and using `cache.identify` themselves will avoid seeing the obscure\n      // warning.\n      const id = value == null ? value : this.toCacheId(value);\n      if (__DEV__) {\n        const actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;\n        if (id === undefined) {\n          __DEV__ && invariant.warn(113, actualFragmentName);\n        }\n      }\n      return id;\n    });\n    if (!Array.isArray(from)) {\n      const observable = this.watchSingleFragment(ids[0], query, options);\n      // Unfortunately we forgot to allow for `null` on watchFragment in 4.0\n      // when `from` is a single record. As such, we need to fallback to {}\n      // when diff.result is null to maintain backwards compatibility. We\n      // should plan to change this in v5. We do however support `null` if\n      // `from` is explicitly `null`.\n      //\n      // NOTE: Using `from` with an array will maintain `null` properly\n      // without the need for a similar fallback since watchFragment with\n      // arrays is new functionality in v4.1.\n      return from === null ? observable : mapObservableFragmentMemoized(observable, Symbol.for(\"apollo.transform.individualResult\"), result => {\n        var _result$data;\n        return _objectSpread(_objectSpread({}, result), {}, {\n          data: (_result$data = result.data) !== null && _result$data !== void 0 ? _result$data : {}\n        });\n      });\n    }\n    let currentResult;\n    function toResult(results) {\n      const result = results.reduce((memo, result, idx) => {\n        memo.data.push(result.data);\n        memo.complete && (memo.complete = result.complete);\n        memo.dataState = memo.complete ? \"complete\" : \"partial\";\n        if (result.missing) {\n          memo.missing || (memo.missing = {});\n          memo.missing[idx] = result.missing;\n        }\n        return memo;\n      }, {\n        data: [],\n        dataState: \"complete\",\n        complete: true\n      });\n      if (!equal(currentResult, result)) {\n        currentResult = result;\n      }\n      return currentResult;\n    }\n    if (ids.length === 0) {\n      return emptyArrayObservable;\n    }\n    let subscribed = false;\n    const observables = ids.map(id => this.watchSingleFragment(id, query, options));\n    const observable = combineLatestBatched(observables).pipe(map(toResult), tap({\n      subscribe: () => subscribed = true,\n      unsubscribe: () => subscribed = false\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    return Object.assign(observable, {\n      getCurrentResult: () => {\n        if (subscribed && currentResult) {\n          return currentResult;\n        }\n        const results = observables.map(observable => observable.getCurrentResult());\n        return toResult(results);\n      }\n    });\n  }\n  watchSingleFragment(id, fragmentQuery, options) {\n    if (id === null) {\n      return nullObservable;\n    }\n    const {\n      optimistic = true,\n      variables\n    } = options;\n    const cacheKey = [fragmentQuery, canonicalStringify({\n      id,\n      optimistic,\n      variables\n    })];\n    const cacheEntry = this.fragmentWatches.lookupArray(cacheKey);\n    if (!cacheEntry.observable) {\n      let subscribed = false;\n      let currentResult;\n      function getNewestResult(diff) {\n        const data = diff.result;\n        if (!currentResult || !equalByQuery(fragmentQuery, {\n          data: currentResult.data\n        }, {\n          data\n        }, options.variables)) {\n          currentResult = {\n            data,\n            dataState: diff.complete ? \"complete\" : \"partial\",\n            complete: diff.complete\n          };\n          if (diff.missing) {\n            currentResult.missing = diff.missing.missing;\n          }\n        }\n        return currentResult;\n      }\n      const observable = new Observable(observer => {\n        subscribed = true;\n        const cleanup = this.watch({\n          variables,\n          returnPartialData: true,\n          id,\n          query: fragmentQuery,\n          optimistic,\n          immediate: true,\n          callback: diff => {\n            observable.dirty = true;\n            this.onAfterBroadcast(() => {\n              observer.next(getNewestResult(diff));\n              observable.dirty = false;\n            });\n          }\n        });\n        return () => {\n          subscribed = false;\n          cleanup();\n          this.fragmentWatches.removeArray(cacheKey);\n        };\n      }).pipe(distinctUntilChanged(), share({\n        connector: () => new ReplaySubject(1),\n        // debounce so a synchronous unsubscribe+resubscribe doesn't tear down the watch and create a new one\n        resetOnRefCountZero: () => timer(0)\n      }));\n      cacheEntry.observable = Object.assign(observable, {\n        dirty: false,\n        getCurrentResult: () => {\n          if (subscribed && currentResult) {\n            return currentResult;\n          }\n          return getNewestResult(this.diff({\n            id,\n            query: fragmentQuery,\n            returnPartialData: true,\n            optimistic,\n            variables\n          }));\n        }\n      });\n    }\n    return cacheEntry.observable;\n  }\n  readFragment(options) {\n    let optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !!options.optimistic;\n    const id = options.from !== undefined ? this.toCacheId(options.from) : options.id;\n    return this.read(_objectSpread(_objectSpread({}, options), {}, {\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: id,\n      optimistic\n    }));\n  }\n  writeQuery(_ref) {\n    let {\n        id,\n        data\n      } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded);\n    return this.write(Object.assign(options, {\n      dataId: id || \"ROOT_QUERY\",\n      result: data\n    }));\n  }\n  writeFragment(_ref2) {\n    let {\n        data,\n        fragment,\n        fragmentName\n      } = _ref2,\n      options = _objectWithoutProperties(_ref2, _excluded2);\n    const id = options.from !== undefined ? this.toCacheId(options.from) : options.id;\n    return this.write(Object.assign(options, {\n      query: this.getFragmentDoc(fragment, fragmentName),\n      dataId: id,\n      result: data\n    }));\n  }\n  updateQuery(options, update) {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery(_objectSpread(_objectSpread({}, options), {}, {\n          data\n        }));\n        return data;\n      }\n    });\n  }\n  updateFragment(options, update) {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment(_objectSpread(_objectSpread({}, options), {}, {\n          data\n        }));\n        return data;\n      }\n    });\n  }\n  toCacheId(from) {\n    return typeof from === \"string\" ? from : this.identify(from);\n  }\n}\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\nconst nullResult = Object.freeze({\n  data: null,\n  dataState: \"complete\",\n  complete: true\n});\nconst nullObservable = Object.assign(new Observable(observer => {\n  observer.next(nullResult);\n}), {\n  dirty: false,\n  getCurrentResult: () => nullResult\n});\nconst emptyArrayResult = Object.freeze({\n  data: [],\n  dataState: \"complete\",\n  complete: true\n});\nconst emptyArrayObservable = Object.assign(new Observable(observer => {\n  observer.next(emptyArrayResult);\n}), {\n  getCurrentResult: () => emptyArrayResult\n});","map":{"version":3,"names":["WeakCache","equal","Trie","wrap","distinctUntilChanged","map","Observable","ReplaySubject","share","shareReplay","tap","timer","cacheSizes","canonicalStringify","__DEV__","bindCacheKey","combineLatestBatched","equalByQuery","getApolloCacheMemoryInternals","getFragmentDefinition","getFragmentQueryDocument","mapObservableFragmentMemoized","invariant","ApolloCache","constructor","_defineProperty","cb","max","cache","makeCacheKey","lookupFragment","fragmentName","batch","options","optimisticId","optimistic","updateResult","performTransaction","update","recordOptimisticTransaction","transaction","transformDocument","document","transformForLink","identify","object","gc","modify","readQuery","arguments","length","undefined","read","_objectSpread","rootId","id","watchFragment","fragment","from","query","getFragmentDoc","fromArray","Array","isArray","ids","value","toCacheId","actualFragmentName","name","warn","observable","watchSingleFragment","Symbol","for","result","_result$data","data","currentResult","toResult","results","reduce","memo","idx","push","complete","dataState","missing","emptyArrayObservable","subscribed","observables","pipe","subscribe","unsubscribe","bufferSize","refCount","Object","assign","getCurrentResult","fragmentQuery","nullObservable","variables","cacheKey","cacheEntry","fragmentWatches","lookupArray","getNewestResult","diff","observer","cleanup","watch","returnPartialData","immediate","callback","dirty","onAfterBroadcast","next","removeArray","connector","resetOnRefCountZero","readFragment","writeQuery","_ref","_objectWithoutProperties","_excluded","write","dataId","writeFragment","_ref2","_excluded2","updateQuery","updateFragment","prototype","getMemoryInternals","nullResult","freeze","emptyArrayResult"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/cache/core/cache.ts"],"sourcesContent":["import { WeakCache } from \"@wry/caches\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { wrap } from \"optimism\";\nimport {\n  distinctUntilChanged,\n  map,\n  Observable,\n  ReplaySubject,\n  share,\n  shareReplay,\n  tap,\n  timer,\n} from \"rxjs\";\n\nimport type {\n  DataValue,\n  GetDataState,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport type { FragmentType, Unmasked } from \"@apollo/client/masking\";\nimport type { Reference, StoreObject } from \"@apollo/client/utilities\";\nimport { cacheSizes, canonicalStringify } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  IsAny,\n  NoInfer,\n  Prettify,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  bindCacheKey,\n  combineLatestBatched,\n  equalByQuery,\n  getApolloCacheMemoryInternals,\n  getFragmentDefinition,\n  getFragmentQueryDocument,\n  mapObservableFragmentMemoized,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\n\nimport type { Cache } from \"./types/Cache.js\";\nimport type { MissingTree } from \"./types/common.js\";\n\nexport type Transaction = (c: ApolloCache) => void;\n\nexport declare namespace ApolloCache {\n  /**\n   * Acceptable values provided to the `from` option.\n   */\n  export type FromOptionValue<TData> =\n    | StoreObject\n    | Reference\n    | FragmentType<NoInfer<TData>>\n    | string;\n\n  /**\n   * Watched fragment options.\n   */\n  export interface WatchFragmentOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /**\n     * A GraphQL fragment document parsed into an AST with the `gql`\n     * template literal.\n     *\n     * @docGroup 1. Required options\n     */\n    fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n    /**\n     * An object containing a `__typename` and primary key fields\n     * (such as `id`) identifying the entity object from which the fragment will\n     * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n     * (uncommon).\n     *\n     * @docGroup 1. Required options\n     */\n    from:\n      | ApolloCache.FromOptionValue<TData>\n      | Array<ApolloCache.FromOptionValue<TData> | null>\n      | null;\n    /**\n     * Any variables that the GraphQL fragment may depend on.\n     *\n     * @docGroup 2. Cache options\n     */\n    variables?: TVariables;\n    /**\n     * The name of the fragment defined in the fragment document.\n     *\n     * Required if the fragment document includes more than one fragment,\n     * optional otherwise.\n     *\n     * @docGroup 2. Cache options\n     */\n    fragmentName?: string;\n    /**\n     * If `true`, `watchFragment` returns optimistic results.\n     *\n     * The default value is `true`.\n     *\n     * @docGroup 2. Cache options\n     */\n    optimistic?: boolean;\n  }\n\n  /**\n   * Watched fragment results.\n   */\n  export type WatchFragmentResult<TData = unknown> =\n    true extends IsAny<TData> ?\n      | ({\n          complete: true;\n          missing?: never;\n        } & GetDataState<any, \"complete\">)\n      | ({\n          complete: false;\n          missing?: MissingTree;\n        } & GetDataState<any, \"partial\">)\n    : TData extends null | null[] ?\n      Prettify<\n        {\n          complete: true;\n          missing?: never;\n        } & GetDataState<TData, \"complete\">\n      >\n    : | Prettify<\n          {\n            complete: true;\n            missing?: never;\n          } & GetDataState<TData, \"complete\">\n        >\n      | {\n          complete: false;\n          missing?: MissingTree;\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n          data: TData extends Array<infer TItem> ?\n            Array<DataValue.Partial<TItem> | null>\n          : DataValue.Partial<TData>;\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n          dataState: \"partial\";\n        };\n\n  export interface ObservableFragment<TData = unknown>\n    extends Observable<ApolloCache.WatchFragmentResult<TData>> {\n    /**\n     * Return the current result for the fragment.\n     */\n    getCurrentResult: () => ApolloCache.WatchFragmentResult<TData>;\n  }\n}\n\nexport abstract class ApolloCache {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(query: Cache.ReadOptions<TData, TVariables>): Unmasked<TData> | null;\n  public abstract write<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(write: Cache.WriteOptions<TData, TVariables>): Reference | undefined;\n\n  /**\n   * Returns data read from the cache for a given query along with information\n   * about the cache result such as whether the result is complete and details\n   * about missing fields.\n   *\n   * Will return `complete` as `true` if it can fulfill the full cache result or\n   * `false` if not. When no data can be fulfilled from the cache, `null` is\n   * returned. When `returnPartialData` is `true`, non-null partial results are\n   * returned if it contains at least one field that can be fulfilled from the\n   * cache.\n   */\n  public abstract diff<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(query: Cache.DiffOptions<TData, TVariables>): Cache.DiffResult<TData>;\n  public abstract watch<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(watch: Cache.WatchOptions<TData, TVariables>): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(serializedState: unknown): this;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): unknown;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Used by data masking to determine if an inline fragment with a type\n  // condition matches a given typename. Also used by local resolvers to match a\n  // fragment against a typename.\n  //\n  // If not implemented by a cache subclass, data masking will effectively be\n  // disabled since we will not be able to accurately determine if a given type\n  // condition for a union or interface matches a particular type.\n  public abstract fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string\n  ): boolean;\n\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return null;\n  }\n\n  // Local state API\n\n  /**\n   * Determines whether a `@client` field can be resolved by the cache. Used\n   * when `LocalState` does not have a local resolver that can resolve the\n   * field.\n   *\n   * @remarks Cache implementations should return `true` if a mechanism in the\n   * cache is expected to provide a value for the field. `LocalState` will set\n   * the value of the field to `undefined` in order for the cache to handle it.\n   *\n   * Cache implementations should return `false` to indicate that it cannot\n   * handle resolving the field (either because it doesn't have a mechanism to\n   * do so, or because the user hasn't provided enough information to resolve\n   * the field). Returning `false` will emit a warning and set the value of the\n   * field to `null`.\n   *\n   * A cache that doesn't implement `resolvesClientField` will be treated the\n   * same as returning `false`.\n   */\n  public resolvesClientField?(typename: string, fieldName: string): boolean;\n\n  // Transactional API\n\n  /**\n   * Executes multiple cache operations as a single batch, ensuring that\n   * watchers are only notified once after all operations complete. This is\n   * useful for improving performance when making multiple cache updates, as it\n   * prevents unnecessary re-renders or query refetches between individual\n   * operations.\n   *\n   * The `batch` method supports both optimistic and non-optimistic updates, and\n   * provides fine-grained control over which cache layer receives the updates\n   * and when watchers are notified.\n   *\n   * For usage instructions, see [Interacting with cached data: `cache.batch`](https://www.apollographql.com/docs/react/caching/cache-interaction#using-cachebatch).\n   *\n   * @example\n   *\n   * ```js\n   * cache.batch({\n   *   update(cache) {\n   *     cache.writeQuery({\n   *       query: GET_TODOS,\n   *       data: { todos: updatedTodos },\n   *     });\n   *     cache.evict({ id: \"Todo:123\" });\n   *   },\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```js\n   * // Optimistic update with a custom layer ID\n   * cache.batch({\n   *   optimistic: \"add-todo-optimistic\",\n   *   update(cache) {\n   *     cache.modify({\n   *       fields: {\n   *         todos(existing = []) {\n   *           return [...existing, newTodoRef];\n   *         },\n   *       },\n   *     });\n   *   },\n   * });\n   * ```\n   *\n   * @returns The return value of the `update` function.\n   */\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\" ? options.optimistic\n      : options.optimistic === false ? null\n      : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  /**\n   * Read data from the cache for the specified query.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    query,\n    variables,\n    id,\n    optimistic,\n    returnPartialData,\n  }: Cache.ReadQueryOptions<TData, TVariables>): Unmasked<TData> | null;\n  /**\n   * {@inheritDoc @apollo/client!ApolloCache#readQuery:member(1)}\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadQueryOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadQueryOptions<TData, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<TData> | null {\n    return this.read({\n      ...options,\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic,\n    });\n  }\n\n  private fragmentWatches = new Trie<{\n    observable?: ApolloCache.ObservableFragment<any> & { dirty: boolean };\n  }>(true);\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables> & {\n      from: Array<ApolloCache.FromOptionValue<TData>>;\n    }\n  ): ApolloCache.ObservableFragment<Array<Unmasked<TData>>>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables> & {\n      from: Array<null>;\n    }\n  ): ApolloCache.ObservableFragment<Array<null>>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables> & {\n      from: Array<ApolloCache.FromOptionValue<TData> | null>;\n    }\n  ): ApolloCache.ObservableFragment<Array<Unmasked<TData> | null>>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables> & {\n      from: null;\n    }\n  ): ApolloCache.ObservableFragment<null>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables> & {\n      from: ApolloCache.FromOptionValue<TData>;\n    }\n  ): ApolloCache.ObservableFragment<Unmasked<TData>>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables>\n  ): ApolloCache.ObservableFragment<Unmasked<TData> | null>;\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables>\n  ):\n    | ApolloCache.ObservableFragment<Unmasked<TData> | null>\n    | ApolloCache.ObservableFragment<Array<Unmasked<TData> | null>> {\n    const { fragment, fragmentName, from } = options;\n    const query = this.getFragmentDoc(\n      fragment,\n      fragmentName\n    ) as TypedDocumentNode<TData, TVariables>;\n\n    const fromArray = Array.isArray(from) ? from : [from];\n\n    const ids = fromArray.map((value) => {\n      // While our TypeScript types do not allow for `undefined` as a valid\n      // `from`, its possible `useFragment` gives us an `undefined` since it\n      // calls` cache.identify` and provides that value to `from`. We are\n      // adding this fix here however to ensure those using plain JavaScript\n      // and using `cache.identify` themselves will avoid seeing the obscure\n      // warning.\n      const id = value == null ? value : this.toCacheId(value);\n\n      if (__DEV__) {\n        const actualFragmentName =\n          fragmentName || getFragmentDefinition(fragment).name.value;\n\n        if (id === undefined) {\n          invariant.warn(\n            \"Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object.\",\n            actualFragmentName\n          );\n        }\n      }\n\n      return id as string | null;\n    });\n\n    if (!Array.isArray(from)) {\n      const observable = this.watchSingleFragment(ids[0], query, options);\n      // Unfortunately we forgot to allow for `null` on watchFragment in 4.0\n      // when `from` is a single record. As such, we need to fallback to {}\n      // when diff.result is null to maintain backwards compatibility. We\n      // should plan to change this in v5. We do however support `null` if\n      // `from` is explicitly `null`.\n      //\n      // NOTE: Using `from` with an array will maintain `null` properly\n      // without the need for a similar fallback since watchFragment with\n      // arrays is new functionality in v4.1.\n      return from === null ? observable : (\n          mapObservableFragmentMemoized(\n            observable,\n            Symbol.for(\"apollo.transform.individualResult\"),\n            (result: ApolloCache.WatchFragmentResult<any>) => ({\n              ...result,\n              data: result.data ?? ({} as any),\n            })\n          )\n        );\n    }\n\n    let currentResult: ApolloCache.WatchFragmentResult<TData>;\n    function toResult(\n      results: Array<ApolloCache.WatchFragmentResult<TData>>\n    ): ApolloCache.WatchFragmentResult<any> {\n      const result = results.reduce(\n        (memo, result, idx) => {\n          memo.data.push(result.data);\n          memo.complete &&= result.complete;\n          memo.dataState = memo.complete ? \"complete\" : \"partial\";\n\n          if (result.missing) {\n            memo.missing ||= {};\n            (memo.missing as any)[idx] = result.missing;\n          }\n\n          return memo;\n        },\n        {\n          data: [],\n          dataState: \"complete\",\n          complete: true,\n        } as ApolloCache.WatchFragmentResult<TData>\n      );\n\n      if (!equal(currentResult, result)) {\n        currentResult = result;\n      }\n\n      return currentResult;\n    }\n\n    if (ids.length === 0) {\n      return emptyArrayObservable;\n    }\n\n    let subscribed = false;\n    const observables = ids.map((id) =>\n      this.watchSingleFragment(id, query, options)\n    ) as Array<ApolloCache.ObservableFragment<TData>>;\n\n    const observable = combineLatestBatched(observables).pipe(\n      map(toResult),\n      tap({\n        subscribe: () => (subscribed = true),\n        unsubscribe: () => (subscribed = false),\n      }),\n      shareReplay({ bufferSize: 1, refCount: true })\n    );\n\n    return Object.assign(observable, {\n      getCurrentResult: () => {\n        if (subscribed && currentResult) {\n          return currentResult as any;\n        }\n\n        const results = observables.map((observable) =>\n          observable.getCurrentResult()\n        );\n\n        return toResult(results);\n      },\n    } satisfies Pick<\n      | ApolloCache.ObservableFragment<Unmasked<TData> | null>\n      | ApolloCache.ObservableFragment<Array<Unmasked<TData> | null>>,\n      \"getCurrentResult\"\n    >) as any;\n  }\n\n  /**\n   * Can be overridden by subclasses to delay calling the provided callback\n   * until after all broadcasts have been completed - e.g. in a cache scenario\n   * where many watchers are notified in parallel.\n   */\n  protected onAfterBroadcast = (cb: () => void) => cb();\n  private watchSingleFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    id: string | null,\n    fragmentQuery: TypedDocumentNode<TData, TVariables>,\n    options: Omit<\n      ApolloCache.WatchFragmentOptions<TData, TVariables>,\n      \"from\" | \"fragment\" | \"fragmentName\"\n    >\n  ): ApolloCache.ObservableFragment<Unmasked<TData> | null> & {\n    dirty: boolean;\n  } {\n    if (id === null) {\n      return nullObservable as any;\n    }\n\n    const { optimistic = true, variables } = options;\n\n    const cacheKey = [\n      fragmentQuery,\n      canonicalStringify({ id, optimistic, variables }),\n    ];\n    const cacheEntry = this.fragmentWatches.lookupArray(cacheKey);\n\n    if (!cacheEntry.observable) {\n      let subscribed = false;\n      let currentResult: ApolloCache.WatchFragmentResult<TData>;\n\n      function getNewestResult(diff: Cache.DiffResult<TData>) {\n        const data = diff.result;\n\n        if (\n          !currentResult ||\n          !equalByQuery(\n            fragmentQuery,\n            { data: currentResult.data },\n            { data },\n            options.variables\n          )\n        ) {\n          currentResult = {\n            data,\n            dataState: diff.complete ? \"complete\" : \"partial\",\n            complete: diff.complete,\n          } as ApolloCache.WatchFragmentResult<TData>;\n\n          if (diff.missing) {\n            currentResult.missing = diff.missing.missing;\n          }\n        }\n\n        return currentResult;\n      }\n\n      const observable: Observable<ApolloCache.WatchFragmentResult<TData>> & {\n        dirty?: boolean;\n      } = new Observable<ApolloCache.WatchFragmentResult<TData>>((observer) => {\n        subscribed = true;\n        const cleanup = this.watch<TData, TVariables>({\n          variables,\n          returnPartialData: true,\n          id,\n          query: fragmentQuery,\n          optimistic,\n          immediate: true,\n          callback: (diff) => {\n            observable.dirty = true;\n            this.onAfterBroadcast(() => {\n              observer.next(getNewestResult(diff));\n              observable.dirty = false;\n            });\n          },\n        });\n        return () => {\n          subscribed = false;\n          cleanup();\n          this.fragmentWatches.removeArray(cacheKey);\n        };\n      }).pipe(\n        distinctUntilChanged(),\n        share({\n          connector: () => new ReplaySubject(1),\n          // debounce so a synchronous unsubscribe+resubscribe doesn't tear down the watch and create a new one\n          resetOnRefCountZero: () => timer(0),\n        })\n      );\n\n      cacheEntry.observable = Object.assign(observable, {\n        dirty: false,\n        getCurrentResult: () => {\n          if (subscribed && currentResult) {\n            return currentResult;\n          }\n\n          return getNewestResult(\n            this.diff<TData>({\n              id,\n              query: fragmentQuery,\n              returnPartialData: true,\n              optimistic,\n              variables,\n            })\n          );\n        },\n      });\n    }\n\n    return cacheEntry.observable as ApolloCache.ObservableFragment<Unmasked<TData> | null> & {\n      dirty: boolean;\n    };\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max:\n      cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n      defaultCacheSizes[\"cache.fragmentQueryDocuments\"],\n    cache: WeakCache,\n    makeCacheKey: bindCacheKey(this),\n  });\n\n  /**\n   * Read data from the cache for the specified fragment.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    fragment,\n    variables,\n    fragmentName,\n    id,\n    from,\n    optimistic,\n    returnPartialData,\n  }: Cache.ReadFragmentOptions<TData, TVariables>): Unmasked<TData> | null;\n\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadFragmentOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadFragmentOptions<TData, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<TData> | null {\n    const id =\n      options.from !== undefined ? this.toCacheId(options.from) : options.id;\n\n    return this.read({\n      ...options,\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: id,\n      optimistic,\n    });\n  }\n\n  /**\n   * Writes data to the root of the cache using the specified query to validate that\n   * the shape of the data you’re writing to the cache is the same as the shape of\n   * the data required by the query. Great for prepping the cache with initial data.\n   */\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    data,\n    query,\n    variables,\n    overwrite,\n    id,\n    broadcast,\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined;\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  /**\n   * Similar to `writeQuery` (writes data to the cache) but uses the specified\n   * fragment to validate that the shape of the data you’re writing to the cache\n   * is the same as the shape of the data required by the fragment.\n   */\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    data,\n    fragment,\n    fragmentName,\n    variables,\n    overwrite,\n    id,\n    from,\n    broadcast,\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined;\n\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    const id =\n      options.from !== undefined ? this.toCacheId(options.from) : options.id;\n\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  private toCacheId(from: ApolloCache.FromOptionValue<any>) {\n    return typeof from === \"string\" ? from : this.identify(from);\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public declare getMemoryInternals?: typeof getApolloCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n\nconst nullResult = Object.freeze({\n  data: null,\n  dataState: \"complete\",\n  complete: true,\n}) as ApolloCache.WatchFragmentResult<null>;\n\nconst nullObservable = Object.assign(\n  new Observable((observer) => {\n    observer.next(nullResult);\n  }),\n  { dirty: false, getCurrentResult: () => nullResult }\n);\n\nconst emptyArrayResult = Object.freeze({\n  data: [],\n  dataState: \"complete\",\n  complete: true,\n});\n\nconst emptyArrayObservable: ApolloCache.ObservableFragment<any[]> =\n  Object.assign(\n    new Observable<ApolloCache.WatchFragmentResult<never[]>>((observer) => {\n      observer.next(emptyArrayResult);\n    }),\n    { getCurrentResult: () => emptyArrayResult }\n  );\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}