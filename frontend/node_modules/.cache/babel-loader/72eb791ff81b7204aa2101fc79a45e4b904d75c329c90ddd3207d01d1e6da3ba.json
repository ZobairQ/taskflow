{"ast":null,"code":"import _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { equal } from \"@wry/equality\";\nimport { filter } from \"rxjs\";\nimport { createFulfilledPromise, createRejectedPromise, decoratePromise } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nconst QUERY_REFERENCE_SYMBOL = Symbol.for(\"apollo.internal.queryRef\");\nconst PROMISE_SYMBOL = Symbol.for(\"apollo.internal.refPromise\");\nexport function wrapQueryRef(internalQueryRef) {\n  return {\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise\n  };\n}\nexport function assertWrappedQueryRef(queryRef) {\n  invariant(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 27);\n}\nexport function getWrappedPromise(queryRef) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  return internalQueryRef.promise.status === \"fulfilled\" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nexport function updateWrappedQueryRef(queryRef, promise) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\nconst OBSERVED_CHANGED_OPTIONS = [\"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\nexport class InternalQueryReference {\n  constructor(observable, options) {\n    _defineProperty(this, \"result\", void 0);\n    _defineProperty(this, \"key\", {});\n    _defineProperty(this, \"observable\", void 0);\n    _defineProperty(this, \"promise\", void 0);\n    _defineProperty(this, \"queue\", void 0);\n    _defineProperty(this, \"subscription\", void 0);\n    _defineProperty(this, \"listeners\", new Set());\n    _defineProperty(this, \"autoDisposeTimeoutId\", void 0);\n    _defineProperty(this, \"resolve\", void 0);\n    _defineProperty(this, \"reject\", void 0);\n    _defineProperty(this, \"references\", 0);\n    _defineProperty(this, \"softReferences\", 0);\n    this.handleNext = this.handleNext.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    this.setResult();\n    this.subscribeToQuery();\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        var _options$autoDisposeT;\n        this.autoDisposeTimeoutId = setTimeout(this.dispose, (_options$autoDisposeT = options.autoDisposeTimeoutMs) !== null && _options$autoDisposeT !== void 0 ? _options$autoDisposeT : 30000);\n      }\n    };\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  get disposed() {\n    return this.subscription.closed;\n  }\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n  reinitialize() {\n    const {\n      observable\n    } = this;\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests = originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n    try {\n      if (avoidNetworkRequests) {\n        observable.applyOptions({\n          fetchPolicy: \"standby\"\n        });\n      } else {\n        observable.reset();\n        observable.applyOptions({\n          fetchPolicy: \"cache-first\"\n        });\n      }\n      if (!avoidNetworkRequests) {\n        this.setResult();\n      }\n      this.subscribeToQuery();\n    } finally {\n      observable.applyOptions({\n        fetchPolicy: originalFetchPolicy\n      });\n    }\n  }\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n    return () => {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      this.references--;\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n  didChangeOptions(watchQueryOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(option => option in watchQueryOptions && !equal(this.watchQueryOptions[option], watchQueryOptions[option]));\n  }\n  applyOptions(watchQueryOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy\n    } = this.watchQueryOptions;\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.applyOptions(watchQueryOptions);\n    }\n    return this.promise;\n  }\n  listen(listener) {\n    this.listeners.add(listener);\n    if (this.queue) {\n      this.deliver(this.queue);\n      this.queue = undefined;\n    }\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n  refetch(variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n  fetchMore(options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  }\n  dispose() {\n    this.subscription.unsubscribe();\n  }\n  onDispose() {\n    // noop. overridable by options\n  }\n  handleNext(result) {\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          // TODO: This can likely be removed once\n          // https://github.com/apollographql/apollo-client/issues/12667 is fixed\n          if (result.data === void 0) {\n            result.data = this.result.data;\n            if (result.data) {\n              result.dataState = \"complete\";\n            }\n          }\n          if (this.shouldReject(result)) {\n            var _this$reject;\n            (_this$reject = this.reject) === null || _this$reject === void 0 || _this$reject.call(this, result.error);\n          } else {\n            var _this$resolve;\n            this.result = result;\n            (_this$resolve = this.resolve) === null || _this$resolve === void 0 || _this$resolve.call(this, result);\n          }\n          break;\n        }\n      default:\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {\n            return;\n          }\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          if (this.shouldReject(result)) {\n            this.promise = createRejectedPromise(result.error);\n            this.deliver(this.promise);\n          } else {\n            this.result = result;\n            this.promise = createFulfilledPromise(result);\n            this.deliver(this.promise);\n          }\n          break;\n        }\n    }\n  }\n  deliver(promise) {\n    // Maintain a queue of the last item we tried to deliver so that we can\n    // deliver it as soon as we get the first listener. This helps in cases such\n    // as `@stream` where React may render a component and incremental results\n    // are loaded in between when the component renders and effects are run. If\n    // effects are run after the incremntal chunks are delivered, we'll have\n    // rendered a stale value. The queue ensures we can deliver the most\n    // up-to-date value as soon as the component is ready to listen for new\n    // values.\n    if (this.listeners.size === 0) {\n      this.queue = promise;\n    }\n    this.listeners.forEach(listener => listener(promise));\n  }\n  initiateFetch(returnedPromise) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise.then(() => {\n      // In the case of `fetchMore`, this promise is resolved before a cache\n      // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n      // fetch policy and runs `cache.batch` in its `.then` handler. Because\n      // the timing is different, we accidentally run this update twice\n      // causing an additional re-render with the `fetchMore` result by\n      // itself. By wrapping in `setTimeout`, this should provide a short\n      // delay to allow the `QueryInfo.notify` handler to run before this\n      // promise is checked.\n      // See https://github.com/apollographql/apollo-client/issues/11315 for\n      // more information\n      setTimeout(() => {\n        if (this.promise.status === \"pending\") {\n          var _this$resolve2;\n          // Use the current result from the observable instead of the value\n          // resolved from the promise. This avoids issues in some cases where\n          // the raw resolved value should not be the emitted value, such as\n          // when a `fetchMore` call returns an empty array after it has\n          // reached the end of the list.\n          //\n          // See the following for more information:\n          // https://github.com/apollographql/apollo-client/issues/11642\n          this.result = this.observable.getCurrentResult();\n          (_this$resolve2 = this.resolve) === null || _this$resolve2 === void 0 || _this$resolve2.call(this, this.result);\n        }\n      });\n    }).catch(error => {\n      var _this$reject2;\n      return (_this$reject2 = this.reject) === null || _this$reject2 === void 0 ? void 0 : _this$reject2.call(this, error);\n    });\n    return returnedPromise;\n  }\n  subscribeToQuery() {\n    this.subscription = this.observable.pipe(filter(result => !equal(result, this.result))).subscribe(this.handleNext);\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n  setResult() {\n    const result = this.observable.getCurrentResult();\n    if (equal(result, this.result)) {\n      return;\n    }\n    this.result = result;\n    this.promise = result.data ? createFulfilledPromise(result) : this.createPendingPromise();\n  }\n  shouldReject(result) {\n    const {\n      errorPolicy = \"none\"\n    } = this.watchQueryOptions;\n    return result.error && errorPolicy === \"none\";\n  }\n  createPendingPromise() {\n    return decoratePromise(new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    }));\n  }\n}","map":{"version":3,"names":["equal","filter","createFulfilledPromise","createRejectedPromise","decoratePromise","invariant","QUERY_REFERENCE_SYMBOL","Symbol","for","PROMISE_SYMBOL","wrapQueryRef","internalQueryRef","promise","assertWrappedQueryRef","queryRef","getWrappedPromise","unwrapQueryRef","status","updateWrappedQueryRef","OBSERVED_CHANGED_OPTIONS","InternalQueryReference","constructor","observable","options","_defineProperty","Set","handleNext","bind","dispose","onDispose","setResult","subscribeToQuery","startDisposeTimer","references","_options$autoDisposeT","autoDisposeTimeoutId","setTimeout","autoDisposeTimeoutMs","then","disposed","subscription","closed","watchQueryOptions","reinitialize","originalFetchPolicy","fetchPolicy","avoidNetworkRequests","applyOptions","reset","retain","clearTimeout","softRetain","softReferences","didChangeOptions","some","option","currentFetchPolicy","initiateFetch","reobserve","listen","listener","listeners","add","queue","deliver","undefined","delete","refetch","variables","fetchMore","unsubscribe","result","data","dataState","shouldReject","_this$reject","reject","call","error","_this$resolve","resolve","networkStatus","size","forEach","returnedPromise","createPendingPromise","catch","_this$resolve2","getCurrentResult","_this$reject2","pipe","subscribe","errorPolicy","Promise"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/react/internal/cache/QueryReference.ts"],"sourcesContent":["import type {\n  DocumentTypeDecoration,\n  ResultOf,\n  VariablesOf,\n} from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport type { Subscription } from \"rxjs\";\nimport { filter } from \"rxjs\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ObservableQuery,\n  OperationVariables,\n} from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DecoratedPromise } from \"@apollo/client/utilities/internal\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n  decoratePromise,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { QueryKey } from \"./types.js\";\n\ntype QueryRefPromise<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n> = DecoratedPromise<ObservableQuery.Result<MaybeMasked<TData>, TStates>>;\n\ntype Listener<TData, TStates extends DataState<TData>[\"dataState\"]> = (\n  promise: QueryRefPromise<TData, TStates>\n) => void;\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol.for(\n  \"apollo.internal.queryRef\"\n);\nconst PROMISE_SYMBOL: unique symbol = Symbol.for(\"apollo.internal.refPromise\");\ndeclare const QUERY_REF_BRAND: unique symbol;\ndeclare const PRELOADED_QUERY_REF_BRAND: unique symbol;\n/**\n * A `QueryReference` is an opaque object returned by `useBackgroundQuery`.\n * A child component reading the `QueryReference` via `useReadQuery` will\n * suspend until the promise resolves.\n */\nexport interface QueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> {\n  /** @internal */\n  [QUERY_REF_BRAND]?(variables: TVariables): { data: TData; states: TStates };\n}\n\nexport declare namespace QueryRef {\n  export type ForQuery<\n    Document extends DocumentTypeDecoration<any, any>,\n    TStates extends DataState<ResultOf<Document>>[\"dataState\"] =\n      | \"complete\"\n      | \"streaming\",\n  > = QueryRef<ResultOf<Document>, VariablesOf<Document>, TStates>;\n}\n\n/**\n * @internal\n * For usage in internal helpers only.\n */\ninterface WrappedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> extends QueryRef<TData, TVariables, TStates> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData, TStates>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData, TStates>;\n}\n\n/**\n * {@inheritDoc @apollo/client/react!QueryRef:interface}\n */\nexport interface PreloadedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> extends QueryRef<TData, TVariables, TStates> {\n  /** @internal */\n  [PRELOADED_QUERY_REF_BRAND]: typeof PRELOADED_QUERY_REF_BRAND;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(internalQueryRef: InternalQueryReference<TData, TStates>) {\n  return {\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  } as WrappedQueryRef<TData, TVariables, TStates>;\n}\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, TVariables, TStates>\n): asserts queryRef is WrappedQueryRef<TData, TVariables, TStates>;\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, TVariables, TStates> | undefined | null\n): asserts queryRef is\n  | WrappedQueryRef<TData, TVariables, TStates>\n  | undefined\n  | null;\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: QueryRef<TData, TVariables, TStates> | undefined | null) {\n  invariant(\n    !queryRef || QUERY_REFERENCE_SYMBOL in queryRef,\n    \"Expected a QueryRef object, but got something else instead.\"\n  );\n}\n\nexport function getWrappedPromise<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: WrappedQueryRef<TData, any, TStates>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: WrappedQueryRef<TData, any, TStates>\n): InternalQueryReference<TData, TStates>;\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: Partial<WrappedQueryRef<TData, any, TStates>>\n): undefined | InternalQueryReference<TData, TStates>;\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: Partial<WrappedQueryRef<TData, any, TStates>>) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: WrappedQueryRef<TData, any, TStates>,\n  promise: QueryRefPromise<TData, TStates>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  ApolloClient.WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<\n  TData = unknown,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n> {\n  public result!: ObservableQuery.Result<MaybeMasked<TData>, TStates>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData, TStates>;\n\n  private queue: QueryRefPromise<TData, TStates> | undefined;\n  private subscription!: Subscription;\n  private listeners = new Set<Listener<TData, TStates>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve:\n    | ((result: ObservableQuery.Result<MaybeMasked<TData>, TStates>) => void)\n    | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n  private softReferences = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests =\n      originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n\n    try {\n      if (avoidNetworkRequests) {\n        observable.applyOptions({ fetchPolicy: \"standby\" });\n      } else {\n        observable.reset();\n        observable.applyOptions({ fetchPolicy: \"cache-first\" });\n      }\n\n      if (!avoidNetworkRequests) {\n        this.setResult();\n      }\n      this.subscribeToQuery();\n    } finally {\n      observable.applyOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        option in watchQueryOptions &&\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const { fetchPolicy: currentFetchPolicy } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.applyOptions(watchQueryOptions);\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData, TStates>) {\n    this.listeners.add(listener);\n\n    if (this.queue) {\n      this.deliver(this.queue);\n      this.queue = undefined;\n    }\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: ObservableQuery.FetchMoreOptions<TData, any, any, any>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(\n    result: ObservableQuery.Result<MaybeMasked<TData>, TStates>\n  ) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        // TODO: This can likely be removed once\n        // https://github.com/apollographql/apollo-client/issues/12667 is fixed\n        if (result.data === void 0) {\n          result.data = this.result.data;\n\n          if (result.data) {\n            result.dataState = \"complete\" as any;\n          }\n        }\n\n        if (this.shouldReject(result)) {\n          this.reject?.(result.error);\n        } else {\n          this.result = result;\n          this.resolve?.(result);\n        }\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        if (this.shouldReject(result)) {\n          this.promise = createRejectedPromise(result.error);\n          this.deliver(this.promise);\n        } else {\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n        }\n        break;\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData, TStates>) {\n    // Maintain a queue of the last item we tried to deliver so that we can\n    // deliver it as soon as we get the first listener. This helps in cases such\n    // as `@stream` where React may render a component and incremental results\n    // are loaded in between when the component renders and effects are run. If\n    // effects are run after the incremntal chunks are delivered, we'll have\n    // rendered a stale value. The queue ensures we can deliver the most\n    // up-to-date value as soon as the component is ready to listen for new\n    // values.\n    if (this.listeners.size === 0) {\n      this.queue = promise;\n    }\n\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(\n    returnedPromise: Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>\n  ) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then(() => {\n        // In the case of `fetchMore`, this promise is resolved before a cache\n        // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n        // fetch policy and runs `cache.batch` in its `.then` handler. Because\n        // the timing is different, we accidentally run this update twice\n        // causing an additional re-render with the `fetchMore` result by\n        // itself. By wrapping in `setTimeout`, this should provide a short\n        // delay to allow the `QueryInfo.notify` handler to run before this\n        // promise is checked.\n        // See https://github.com/apollographql/apollo-client/issues/11315 for\n        // more information\n        setTimeout(() => {\n          if (this.promise.status === \"pending\") {\n            // Use the current result from the observable instead of the value\n            // resolved from the promise. This avoids issues in some cases where\n            // the raw resolved value should not be the emitted value, such as\n            // when a `fetchMore` call returns an empty array after it has\n            // reached the end of the list.\n            //\n            // See the following for more information:\n            // https://github.com/apollographql/apollo-client/issues/11642\n            this.result =\n              this.observable.getCurrentResult() as ObservableQuery.Result<\n                TData,\n                TStates\n              >;\n            this.resolve?.(this.result);\n          }\n        });\n      })\n      .catch((error) => this.reject?.(error));\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .pipe(filter((result) => !equal(result, this.result)))\n      .subscribe(this.handleNext as any);\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n\n  private setResult() {\n    const result = this.observable.getCurrentResult() as ObservableQuery.Result<\n      TData,\n      TStates\n    >;\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      result.data ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private shouldReject(result: ObservableQuery.Result<any>) {\n    const { errorPolicy = \"none\" } = this.watchQueryOptions;\n\n    return result.error && errorPolicy === \"none\";\n  }\n\n  private createPendingPromise() {\n    return decoratePromise(\n      new Promise<ObservableQuery.Result<MaybeMasked<TData>, TStates>>(\n        (resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        }\n      )\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}