{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { equal } from \"@wry/equality\";\nimport { BehaviorSubject, filter, Observable, share, Subject, tap } from \"rxjs\";\nimport { isNetworkRequestInFlight, isNetworkRequestSettled } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { compact, equalByQuery, extensionsSymbol, filterMap, getOperationDefinition, getOperationName, getQueryDefinition, preventUnhandledRejection, toQueryResult, variablesUnknownSymbol } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nconst {\n  assign,\n  hasOwnProperty\n} = Object;\nconst uninitialized = {\n  loading: true,\n  networkStatus: NetworkStatus.loading,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true\n};\nconst empty = {\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true\n};\nexport class ObservableQuery {\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  get query() {\n    return this.lastQuery;\n  }\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  get variables() {\n    return this.options.variables;\n  }\n  get networkStatus() {\n    return this.subject.getValue().result.networkStatus;\n  }\n  get cache() {\n    return this.queryManager.cache;\n  }\n  constructor(_ref) {\n    let {\n      queryManager,\n      options,\n      transformedQuery = queryManager.transform(options.query)\n    } = _ref;\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"queryName\", void 0);\n    _defineProperty(this, \"variablesUnknown\", false);\n    /**\n    * @internal will be read and written from `QueryInfo`\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    _defineProperty(this, \"_lastWrite\", void 0);\n    _defineProperty(this, \"unsubscribeFromCache\", void 0);\n    _defineProperty(this, \"input\", void 0);\n    _defineProperty(this, \"subject\", void 0);\n    _defineProperty(this, \"isTornDown\", void 0);\n    _defineProperty(this, \"queryManager\", void 0);\n    _defineProperty(this, \"subscriptions\", new Set());\n    /**\n     * If an `ObservableQuery` is created with a `network-only` fetch policy,\n     * it should actually start receiving cache updates, but not before it has\n     * received the first result from the network.\n     */\n    _defineProperty(this, \"waitForNetworkResult\", void 0);\n    _defineProperty(this, \"lastQuery\", void 0);\n    _defineProperty(this, \"linkSubscription\", void 0);\n    _defineProperty(this, \"pollingInfo\", void 0);\n    // We can't use Observable['subscribe'] here as the type as it conflicts with\n    // the ability to infer T from Subscribable<T>. This limits the surface area\n    // to the non-deprecated signature which works properly with type inference.\n    /**\n     * Subscribes to the `ObservableQuery`.\n     * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,\n     * or the `next` handler that is called for each value emitted from the subscribed Observable.\n     * @returns A subscription reference to the registered handlers.\n     */\n    _defineProperty(this, \"subscribe\", void 0);\n    /**\n     * Used to stitch together functional operators into a chain.\n     *\n     * @example\n     *\n     * ```ts\n     * import { filter, map } from 'rxjs';\n     *\n     * observableQuery\n     *   .pipe(\n     *     filter(...),\n     *     map(...),\n     *   )\n     *   .subscribe(x => console.log(x));\n     * ```\n     *\n     * @returns The Observable result of all the operators having been called\n     * in the order they were passed in.\n     */\n    _defineProperty(this, \"pipe\", void 0);\n    _defineProperty(this, Symbol.observable, void 0);\n    _defineProperty(this, \"@@observable\", void 0);\n    _defineProperty(this, \"stableLastResult\", void 0);\n    // Turns polling on or off based on this.options.pollInterval.\n    _defineProperty(this, \"didWarnCacheOnlyPolling\", false);\n    _defineProperty(this, \"dirty\", false);\n    _defineProperty(this, \"notifyTimeout\", void 0);\n    _defineProperty(this, \"activeOperations\", new Set());\n    _defineProperty(this, \"operator\", filterMap(notification => {\n      const {\n        query,\n        variables,\n        meta\n      } = notification;\n      if (notification.source === \"setResult\") {\n        return {\n          query,\n          variables,\n          result: notification.value,\n          meta\n        };\n      }\n      if (notification.kind === \"C\" || !isEqualQuery(notification, this)) {\n        return;\n      }\n      let result;\n      const previous = this.subject.getValue();\n      if (notification.source === \"cache\") {\n        result = notification.value;\n        if (result.networkStatus === NetworkStatus.ready && result.partial && (!this.options.returnPartialData || previous.result.networkStatus === NetworkStatus.error) && this.options.fetchPolicy !== \"cache-only\") {\n          return;\n        }\n      } else if (notification.source === \"network\") {\n        if (this.waitForNetworkResult) {\n          this.waitForNetworkResult = false;\n          this.resubscribeCache();\n        }\n        result = notification.kind === \"E\" ? _objectSpread(_objectSpread({}, isEqualQuery(previous, notification) ? previous.result : {\n          data: undefined,\n          dataState: \"empty\",\n          partial: true\n        }), {}, {\n          error: notification.error,\n          networkStatus: NetworkStatus.error,\n          loading: false\n        }) : notification.value;\n        if (notification.kind === \"E\" && result.dataState === \"streaming\") {\n          result.dataState = \"complete\";\n        }\n        if (result.error) {\n          meta.shouldEmit = 1 /* EmitBehavior.force */;\n        }\n      } else if (notification.source === \"newNetworkStatus\") {\n        const baseResult = isEqualQuery(previous, notification) ? previous.result : this.getInitialResult(meta.fetchPolicy);\n        const {\n          resetError\n        } = notification.value;\n        const error = resetError ? undefined : baseResult.error;\n        const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;\n        result = _objectSpread(_objectSpread({}, baseResult), {}, {\n          error,\n          networkStatus\n        });\n      }\n      // every code path until here should have either returned or set a result,\n      // but typescript needs a little help\n      invariant(result);\n      // normalize result shape\n      if (!result.error) delete result.error;\n      result.networkStatus = this.calculateNetworkStatus(result.networkStatus);\n      result.loading = isNetworkRequestInFlight(result.networkStatus);\n      result = this.maskResult(result);\n      return {\n        query,\n        variables,\n        result,\n        meta\n      };\n    }));\n    this.queryManager = queryManager;\n    // active state\n    this.waitForNetworkResult = options.fetchPolicy === \"network-only\";\n    this.isTornDown = false;\n    this.subscribeToMore = this.subscribeToMore.bind(this);\n    this.maskResult = this.maskResult.bind(this);\n    const {\n      watchQuery: {\n        fetchPolicy: defaultFetchPolicy = \"cache-first\"\n      } = {}\n    } = queryManager.defaultOptions;\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy\n    } = options;\n    if (options[variablesUnknownSymbol]) {\n      invariant(fetchPolicy === \"standby\", 80);\n      this.variablesUnknown = true;\n    }\n    this.lastQuery = transformedQuery;\n    this.options = _objectSpread(_objectSpread({}, options), {}, {\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n      variables: this.getVariablesWithDefaults(options.variables)\n    });\n    this.initializeObservablesQueue();\n    this[\"@@observable\"] = () => this;\n    if (Symbol.observable) {\n      this[Symbol.observable] = () => this;\n    }\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n  initializeObservablesQueue() {\n    this.subject = new BehaviorSubject({\n      query: this.query,\n      variables: this.variables,\n      result: uninitialized,\n      meta: {}\n    });\n    const observable = this.subject.pipe(tap({\n      subscribe: () => {\n        if (!this.subject.observed) {\n          this.reobserve();\n          // TODO: See if we can rework updatePolling to better handle this.\n          // reobserve calls updatePolling but this `subscribe` callback is\n          // called before the subject is subscribed to so `updatePolling`\n          // can't accurately detect if there is an active subscription.\n          // Calling it again here ensures that it can detect if it can poll\n          setTimeout(() => this.updatePolling());\n        }\n      },\n      unsubscribe: () => {\n        if (!this.subject.observed) {\n          this.tearDownQuery();\n        }\n      }\n    }), filterMap((_ref2, context) => {\n      let {\n        query,\n        variables,\n        result: current,\n        meta\n      } = _ref2;\n      const {\n        shouldEmit\n      } = meta;\n      if (current === uninitialized) {\n        // reset internal state after `ObservableQuery.reset()`\n        context.previous = undefined;\n        context.previousVariables = undefined;\n      }\n      if (this.options.fetchPolicy === \"standby\" || shouldEmit === 2 /* EmitBehavior.never */) return;\n      if (shouldEmit === 1 /* EmitBehavior.force */) return emit();\n      const {\n        previous,\n        previousVariables\n      } = context;\n      if (previous) {\n        const documentInfo = this.queryManager.getDocumentInfo(query);\n        const dataMasking = this.queryManager.dataMasking;\n        const maskedQuery = dataMasking ? documentInfo.nonReactiveQuery : query;\n        const resultIsEqual = dataMasking || documentInfo.hasNonreactiveDirective ? equalByQuery(maskedQuery, previous, current, variables) : equal(previous, current);\n        if (resultIsEqual && equal(previousVariables, variables)) {\n          return;\n        }\n      }\n      if (shouldEmit === 3 /* EmitBehavior.networkStatusChange */ && (!this.options.notifyOnNetworkStatusChange || equal(previous, current))) {\n        return;\n      }\n      return emit();\n      function emit() {\n        context.previous = current;\n        context.previousVariables = variables;\n        return current;\n      }\n    }, () => ({})));\n    this.pipe = observable.pipe.bind(observable);\n    this.subscribe = observable.subscribe.bind(observable);\n    this.input = new Subject();\n    // we want to feed many streams into `this.subject`, but none of them should\n    // be able to close `this.input`\n    this.input.complete = () => {};\n    this.input.pipe(this.operator).subscribe(this.subject);\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  getCacheDiff() {\n    let {\n      optimistic = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.cache.diff({\n      query: this.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic\n    });\n  }\n  getInitialResult(initialFetchPolicy) {\n    let fetchPolicy = initialFetchPolicy || this.options.fetchPolicy;\n    if (this.queryManager.prioritizeCacheValues && (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")) {\n      fetchPolicy = \"cache-first\";\n    }\n    const cacheResult = () => {\n      var _diff$result;\n      const diff = this.getCacheDiff();\n      // TODO: queryInfo.getDiff should handle this since cache.diff returns a\n      // null when returnPartialData is false\n      const data = this.options.returnPartialData || diff.complete ? (_diff$result = diff.result) !== null && _diff$result !== void 0 ? _diff$result : undefined : undefined;\n      return this.maskResult({\n        data,\n        dataState: diff.complete ? \"complete\" : data === undefined ? \"empty\" : \"partial\",\n        loading: !diff.complete,\n        networkStatus: diff.complete ? NetworkStatus.ready : NetworkStatus.loading,\n        partial: !diff.complete\n      });\n    };\n    switch (fetchPolicy) {\n      case \"cache-only\":\n        {\n          return _objectSpread(_objectSpread({}, cacheResult()), {}, {\n            loading: false,\n            networkStatus: NetworkStatus.ready\n          });\n        }\n      case \"cache-first\":\n        return cacheResult();\n      case \"cache-and-network\":\n        return _objectSpread(_objectSpread({}, cacheResult()), {}, {\n          loading: true,\n          networkStatus: NetworkStatus.loading\n        });\n      case \"standby\":\n        return empty;\n      default:\n        return uninitialized;\n    }\n  }\n  resubscribeCache() {\n    const {\n      variables,\n      fetchPolicy\n    } = this.options;\n    const query = this.query;\n    const shouldUnsubscribe = fetchPolicy === \"standby\" || fetchPolicy === \"no-cache\" || this.waitForNetworkResult;\n    const shouldResubscribe = !isEqualQuery({\n      query,\n      variables\n    }, this.unsubscribeFromCache) && !this.waitForNetworkResult;\n    if (shouldUnsubscribe || shouldResubscribe) {\n      var _this$unsubscribeFrom;\n      (_this$unsubscribeFrom = this.unsubscribeFromCache) === null || _this$unsubscribeFrom === void 0 || _this$unsubscribeFrom.call(this);\n    }\n    if (shouldUnsubscribe || !shouldResubscribe) {\n      return;\n    }\n    const watch = {\n      query,\n      variables,\n      optimistic: true,\n      watcher: this,\n      callback: diff => {\n        const info = this.queryManager.getDocumentInfo(query);\n        if (info.hasClientExports || info.hasForcedResolvers) {\n          // If this is not set to something different than `diff`, we will\n          // not be notified about future cache changes with an equal `diff`.\n          // That would be the case if we are working with client-only fields\n          // that are forced or with `exports` fields that might change, causing\n          // local resolvers to return a new result.\n          // This is based on an implementation detail of `InMemoryCache`, which\n          // is not optimal - but the only alternative to this would be to\n          // resubscribe to the cache asynchonouly, which would bear the risk of\n          // missing further synchronous updates.\n          watch.lastDiff = undefined;\n        }\n        if (watch.lastOwnDiff === diff) {\n          // skip cache updates that were caused by our own writes\n          return;\n        }\n        const {\n          result: previousResult\n        } = this.subject.getValue();\n        if (!diff.complete && (\n        // If we are trying to deliver an incomplete cache result, we avoid\n        // reporting it if the query has errored, otherwise we let the broadcast try\n        // and repair the partial result by refetching the query. This check avoids\n        // a situation where a query that errors and another succeeds with\n        // overlapping data does not report the partial data result to the errored\n        // query.\n        //\n        // See https://github.com/apollographql/apollo-client/issues/11400 for more\n        // information on this issue.\n        previousResult.error ||\n        // Prevent to schedule a notify directly after the `ObservableQuery`\n        // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)\n        // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.\n        previousResult === uninitialized || previousResult === empty)) {\n          return;\n        }\n        if (!equal(previousResult.data, diff.result)) {\n          this.scheduleNotify();\n        }\n      }\n    };\n    const cancelWatch = this.cache.watch(watch);\n    this.unsubscribeFromCache = Object.assign(() => {\n      this.unsubscribeFromCache = undefined;\n      cancelWatch();\n    }, {\n      query,\n      variables\n    });\n  }\n  getCurrentResult() {\n    const {\n      result: current\n    } = this.subject.getValue();\n    let value = \n    // if the `current` result is in an error state, we will always return that\n    // error state, even if we have no observers\n    current.networkStatus === NetworkStatus.error ||\n    // if we have observers, we are watching the cache and\n    // this.subject.getValue() will always be up to date\n    this.hasObservers() ||\n    // if we are using a `no-cache` fetch policy in which case this\n    // `ObservableQuery` cannot have been updated from the outside - in\n    // that case, we prefer to keep the current value\n    this.options.fetchPolicy === \"no-cache\" ? current\n    // otherwise, the `current` value might be outdated due to missed\n    // external updates - calculate it again\n    : this.getInitialResult();\n    if (value === uninitialized) {\n      value = this.getInitialResult();\n    }\n    if (!equal(this.stableLastResult, value)) {\n      this.stableLastResult = value;\n    }\n    return this.stableLastResult;\n  }\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * Returns a `ResultPromise` with an additional `.retain()` method. Calling\n   * `.retain()` keeps the network operation running even if the `ObservableQuery`\n   * no longer requires the result.\n   *\n   * Note: `refetch()` guarantees that a value will be emitted from the\n   * observable, even if the result is deep equal to the previous value.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  refetch(variables) {\n    const {\n      fetchPolicy\n    } = this.options;\n    const reobserveOptions = {\n      // Always disable polling for refetches.\n      pollInterval: 0\n    };\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some(v => v.variable.name.value === \"variables\")) {\n        var _queryDef$name;\n        __DEV__ && invariant.warn(81, variables, ((_queryDef$name = queryDef.name) === null || _queryDef$name === void 0 ? void 0 : _queryDef$name.value) || queryDef);\n      }\n    }\n    if (variables && !equal(this.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = this.getVariablesWithDefaults(_objectSpread(_objectSpread({}, this.variables), variables));\n    }\n    this._lastWrite = undefined;\n    return this._reobserve(reobserveOptions, {\n      newNetworkStatus: NetworkStatus.refetch\n    });\n  }\n  fetchMore(_ref3) {\n    let {\n      query,\n      variables,\n      context,\n      errorPolicy,\n      updateQuery\n    } = _ref3;\n    invariant(this.options.fetchPolicy !== \"cache-only\", 82, getOperationName(this.query, \"(anonymous)\"));\n    const combinedOptions = _objectSpread(_objectSpread({}, compact(this.options, {\n      errorPolicy: \"none\"\n    }, {\n      query,\n      context,\n      errorPolicy\n    })), {}, {\n      variables: query ? variables : _objectSpread(_objectSpread({}, this.variables), variables),\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n      notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange\n    });\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery = query ? this.transformDocument(this.options.query) : combinedOptions.query;\n    let wasUpdated = false;\n    const isCached = this.options.fetchPolicy !== \"no-cache\";\n    if (!isCached) {\n      invariant(updateQuery, 83);\n    }\n    const {\n      finalize,\n      pushNotification\n    } = this.pushOperation(NetworkStatus.fetchMore);\n    pushNotification({\n      source: \"newNetworkStatus\",\n      kind: \"N\",\n      value: {}\n    }, {\n      shouldEmit: 3 /* EmitBehavior.networkStatusChange */\n    });\n    const {\n      promise,\n      operator\n    } = getTrackingOperatorPromise();\n    const {\n      observable\n    } = this.queryManager.fetchObservableWithInfo(combinedOptions, {\n      networkStatus: NetworkStatus.fetchMore,\n      exposeExtensions: true\n    });\n    const subscription = observable.pipe(operator, filter(notification => notification.kind === \"N\" && notification.source === \"network\")).subscribe({\n      next: notification => {\n        wasUpdated = false;\n        const fetchMoreResult = notification.value;\n        const extensions = fetchMoreResult[extensionsSymbol];\n        if (isNetworkRequestSettled(notification.value.networkStatus)) {\n          finalize();\n        }\n        if (isCached) {\n          // Separately getting a diff here before the batch - `onWatchUpdated` might be\n          // called with an `undefined` `lastDiff` on the watcher if the cache was just subscribed to.\n          const lastDiff = this.getCacheDiff();\n          // Performing this cache update inside a cache.batch transaction ensures\n          // any affected cache.watch watchers are notified at most once about any\n          // updates. Most watchers will be using the QueryInfo class, which\n          // responds to notifications by calling reobserveCacheFirst to deliver\n          // fetchMore cache results back to this ObservableQuery.\n          this.cache.batch({\n            update: cache => {\n              if (updateQuery) {\n                cache.updateQuery({\n                  query: this.query,\n                  variables: this.variables,\n                  returnPartialData: true,\n                  optimistic: false,\n                  extensions\n                }, previous => updateQuery(previous, {\n                  fetchMoreResult: fetchMoreResult.data,\n                  variables: combinedOptions.variables\n                }));\n              } else {\n                // If we're using a field policy instead of updateQuery, the only\n                // thing we need to do is write the new data to the cache using\n                // combinedOptions.variables (instead of this.variables, which is\n                // what this.updateQuery uses, because it works by abusing the\n                // original field value, keyed by the original variables).\n                cache.writeQuery({\n                  query: combinedOptions.query,\n                  variables: combinedOptions.variables,\n                  data: fetchMoreResult.data,\n                  extensions\n                });\n              }\n            },\n            onWatchUpdated: (watch, diff) => {\n              if (watch.watcher === this && !equal(diff.result, lastDiff.result)) {\n                wasUpdated = true;\n                const lastResult = this.getCurrentResult();\n                // Let the cache watch from resubscribeCache handle the final\n                // result\n                if (isNetworkRequestInFlight(fetchMoreResult.networkStatus)) {\n                  pushNotification({\n                    kind: \"N\",\n                    source: \"network\",\n                    value: _objectSpread(_objectSpread({}, lastResult), {}, {\n                      networkStatus: fetchMoreResult.networkStatus === NetworkStatus.error ? NetworkStatus.ready : fetchMoreResult.networkStatus,\n                      // will be overwritten anyways, just here for types sake\n                      loading: false,\n                      data: diff.result,\n                      dataState: fetchMoreResult.dataState === \"streaming\" ? \"streaming\" : \"complete\"\n                    })\n                  });\n                }\n              }\n            }\n          });\n        } else {\n          // There is a possibility `lastResult` may not be set when\n          // `fetchMore` is called which would cause this to crash. This should\n          // only happen if we haven't previously reported a result. We don't\n          // quite know what the right behavior should be here since this block\n          // of code runs after the fetch result has executed on the network.\n          // We plan to let it crash in the meantime.\n          //\n          // If we get bug reports due to the `data` property access on\n          // undefined, this should give us a real-world scenario that we can\n          // use to test against and determine the right behavior. If we do end\n          // up changing this behavior, this may require, for example, an\n          // adjustment to the types on `updateQuery` since that function\n          // expects that the first argument always contains previous result\n          // data, but not `undefined`.\n          const lastResult = this.getCurrentResult();\n          const data = updateQuery(lastResult.data, {\n            fetchMoreResult: fetchMoreResult.data,\n            variables: combinedOptions.variables\n          });\n          pushNotification({\n            kind: \"N\",\n            value: _objectSpread(_objectSpread({}, lastResult), {}, {\n              networkStatus: NetworkStatus.ready,\n              // will be overwritten anyways, just here for types sake\n              loading: false,\n              data: data,\n              dataState: lastResult.dataState === \"streaming\" ? \"streaming\" : \"complete\"\n            }),\n            source: \"network\"\n          });\n        }\n      }\n    });\n    return preventUnhandledRejection(promise.then(result => toQueryResult(this.maskResult(result))).finally(() => {\n      subscription.unsubscribe();\n      finalize();\n      if (isCached && !wasUpdated) {\n        const lastResult = this.getCurrentResult();\n        if (lastResult.dataState === \"streaming\") {\n          pushNotification({\n            kind: \"N\",\n            source: \"network\",\n            value: _objectSpread(_objectSpread({}, lastResult), {}, {\n              dataState: \"complete\",\n              networkStatus: NetworkStatus.ready\n            })\n          });\n        } else {\n          pushNotification({\n            kind: \"N\",\n            source: \"newNetworkStatus\",\n            value: {}\n          }, {\n            shouldEmit: 1 /* EmitBehavior.force */\n          });\n        }\n      }\n    }));\n  }\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  subscribeToMore(options) {\n    const subscription = this.queryManager.startGraphQLSubscription({\n      query: options.document,\n      variables: options.variables,\n      context: options.context\n    }).subscribe({\n      next: subscriptionData => {\n        const {\n          updateQuery,\n          onError\n        } = options;\n        const {\n          error\n        } = subscriptionData;\n        if (error) {\n          if (onError) {\n            onError(error);\n          } else {\n            invariant.error(84, error);\n          }\n          return;\n        }\n        if (updateQuery) {\n          this.updateQuery((previous, updateOptions) => updateQuery(previous, _objectSpread({\n            subscriptionData: subscriptionData\n          }, updateOptions)));\n        }\n      }\n    });\n    this.subscriptions.add(subscription);\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  applyOptions(newOptions) {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n    this.updatePolling();\n  }\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: `setVariables()` guarantees that a value will be emitted from the\n   * observable, even if the result is deeply equal to the previous value.\n   *\n   * Note: the promise will resolve with the last emitted result\n   * when either the variables match the current variables or there\n   * are no subscribers to the query.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  async setVariables(variables) {\n    variables = this.getVariablesWithDefaults(variables);\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return toQueryResult(this.getCurrentResult());\n    }\n    this.options.variables = variables;\n    // See comment above\n    if (!this.hasObservers()) {\n      return toQueryResult(this.getCurrentResult());\n    }\n    return this._reobserve({\n      // Reset options.fetchPolicy to its original value.\n      fetchPolicy: this.options.initialFetchPolicy,\n      variables\n    }, {\n      newNetworkStatus: NetworkStatus.setVariables\n    });\n  }\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  updateQuery(mapFn) {\n    const {\n      queryManager\n    } = this;\n    const {\n      result,\n      complete\n    } = this.getCacheDiff({\n      optimistic: false\n    });\n    const newResult = mapFn(result, {\n      variables: this.variables,\n      complete: !!complete,\n      previousData: result\n    });\n    if (newResult) {\n      this.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables\n      });\n      queryManager.broadcastQueries();\n    }\n  }\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  startPolling(pollInterval) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  applyNextFetchPolicy(reason,\n  // It's possible to use this method to apply options.nextFetchPolicy to\n  // options.fetchPolicy even if options !== this.options, though that happens\n  // most often when the options are temporary, used for only one request and\n  // then thrown away, so nextFetchPolicy may not end up mattering.\n  options) {\n    if (options.nextFetchPolicy) {\n      const {\n        fetchPolicy = \"cache-first\",\n        initialFetchPolicy = fetchPolicy\n      } = options;\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.reobserve.\n        options.fetchPolicy = options.nextFetchPolicy.call(options, fetchPolicy, {\n          reason,\n          options,\n          observable: this,\n          initialFetchPolicy\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n    return options.fetchPolicy;\n  }\n  fetch(options, networkStatus, fetchQuery, operator) {\n    var _options$context;\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    const initialFetchPolicy = this.options.fetchPolicy;\n    (_options$context = options.context) !== null && _options$context !== void 0 ? _options$context : options.context = {};\n    let synchronouslyEmitted = false;\n    const onCacheHit = () => {\n      synchronouslyEmitted = true;\n    };\n    const fetchQueryOperator =\n    // we cannot use `tap` here, since it allows only for a \"before subscription\"\n\n    // hook with `subscribe` and we care for \"directly before and after subscription\"\n    source => new Observable(subscriber => {\n      try {\n        return source.subscribe({\n          next(value) {\n            synchronouslyEmitted = true;\n            subscriber.next(value);\n          },\n          error: error => subscriber.error(error),\n          complete: () => subscriber.complete()\n        });\n      } finally {\n        if (!synchronouslyEmitted) {\n          operation.override = networkStatus;\n          this.input.next({\n            kind: \"N\",\n            source: \"newNetworkStatus\",\n            value: {\n              resetError: true\n            },\n            query,\n            variables,\n            meta: {\n              shouldEmit: 3 /* EmitBehavior.networkStatusChange */,\n\n              /*\n               * The moment this notification is emitted, `nextFetchPolicy`\n               * might already have switched from a `network-only` to a\n               * `cache-something` policy, so we want to ensure that the\n               * loading state emit doesn't accidentally read from the cache\n               * in those cases.\n               */\n              fetchPolicy: initialFetchPolicy\n            }\n          });\n        }\n      }\n    });\n    let {\n      observable,\n      fromLink\n    } = this.queryManager.fetchObservableWithInfo(options, {\n      networkStatus,\n      query: fetchQuery,\n      onCacheHit,\n      fetchQueryOperator,\n      observableQuery: this\n    });\n    // track query and variables from the start of the operation\n    const {\n      query,\n      variables\n    } = this;\n    const operation = {\n      abort: () => {\n        subscription.unsubscribe();\n      },\n      query,\n      variables\n    };\n    this.activeOperations.add(operation);\n    let forceFirstValueEmit = networkStatus == NetworkStatus.refetch || networkStatus == NetworkStatus.setVariables;\n    observable = observable.pipe(operator, share());\n    const subscription = observable.pipe(tap({\n      next: notification => {\n        if (notification.source === \"newNetworkStatus\" || notification.kind === \"N\" && notification.value.loading) {\n          operation.override = networkStatus;\n        } else {\n          delete operation.override;\n        }\n      },\n      finalize: () => this.activeOperations.delete(operation)\n    })).subscribe({\n      next: value => {\n        const meta = {};\n        if (forceFirstValueEmit && value.kind === \"N\" && \"loading\" in value.value && !value.value.loading) {\n          forceFirstValueEmit = false;\n          meta.shouldEmit = 1 /* EmitBehavior.force */;\n        }\n        this.input.next(_objectSpread(_objectSpread({}, value), {}, {\n          query,\n          variables,\n          meta\n        }));\n      }\n    });\n    return {\n      fromLink,\n      subscription,\n      observable\n    };\n  }\n  updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n    const {\n      pollingInfo,\n      options: {\n        fetchPolicy,\n        pollInterval\n      }\n    } = this;\n    if (!pollInterval || !this.hasObservers() || fetchPolicy === \"cache-only\") {\n      if (__DEV__) {\n        if (!this.didWarnCacheOnlyPolling && pollInterval && fetchPolicy === \"cache-only\") {\n          __DEV__ && invariant.warn(85, getOperationName(this.query, \"(anonymous)\"));\n          this.didWarnCacheOnlyPolling = true;\n        }\n      }\n      this.cancelPolling();\n      return;\n    }\n    if ((pollingInfo === null || pollingInfo === void 0 ? void 0 : pollingInfo.interval) === pollInterval) {\n      return;\n    }\n    const info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        var _this$options$skipPol, _this$options;\n        if (!isNetworkRequestInFlight(this.networkStatus) && !((_this$options$skipPol = (_this$options = this.options).skipPollAttempt) !== null && _this$options$skipPol !== void 0 && _this$options$skipPol.call(_this$options))) {\n          this._reobserve({\n            // Most fetchPolicy options don't make sense to use in a polling context, as\n            // users wouldn't want to be polling the cache directly. However, network-only and\n            // no-cache are both useful for when the user wants to control whether or not the\n            // polled results are written to the cache.\n            fetchPolicy: this.options.initialFetchPolicy === \"no-cache\" ? \"no-cache\" : \"network-only\"\n          }, {\n            newNetworkStatus: NetworkStatus.poll\n          }).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n    poll();\n  }\n  // This differs from stopPolling in that it does not set pollInterval to 0\n  cancelPolling() {\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      delete this.pollingInfo;\n    }\n  }\n  /**\n   * Reevaluate the query, optionally against new options. New options will be\n   * merged with the current options when given.\n   *\n   * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with\n   * `variables: undefined`.\n   */\n  reobserve(newOptions) {\n    return this._reobserve(newOptions);\n  }\n  _reobserve(newOptions, internalOptions) {\n    this.isTornDown = false;\n    let {\n      newNetworkStatus\n    } = internalOptions || {};\n    this.queryManager.obsQueries.add(this);\n    const useDisposableObservable =\n    // Refetching uses a disposable Observable to allow refetches using different\n    // options, without permanently altering the options of the\n    // original ObservableQuery.\n    newNetworkStatus === NetworkStatus.refetch ||\n    // Polling uses a disposable Observable so the polling options (which force\n    // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n    newNetworkStatus === NetworkStatus.poll;\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n    const mergedOptions = compact(this.options, newOptions || {});\n    // This request will hit the network, so even if there are no variables,\n    // we now know that's intentional. (see #12996)\n    // Even if that happens only once, we want `variablesUnknown` to stay false permanently.\n    this.variablesUnknown && (this.variablesUnknown = mergedOptions.fetchPolicy === \"standby\");\n    const options = useDisposableObservable ?\n    // Disposable Observable fetches receive a shallow copy of this.options\n    // (merged with newOptions), leaving this.options unmodified.\n    mergedOptions : assign(this.options, mergedOptions);\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n    this.lastQuery = query;\n    // Reevaluate variables to allow resetting variables with variables: undefined,\n    // otherwise `compact` will ignore the `variables` key in `newOptions`. We\n    // do this after we run the query transform to ensure we get default\n    // variables from the transformed query.\n    //\n    // Note: updating options.variables may mutate this.options.variables\n    // in the case of a non-disposable query. This is intentional.\n    if (newOptions && \"variables\" in newOptions) {\n      options.variables = this.getVariablesWithDefaults(newOptions.variables);\n    }\n    if (!useDisposableObservable) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) &&\n      // Don't mess with the fetchPolicy if it's currently \"standby\".\n      options.fetchPolicy !== \"standby\" && (\n      // If we're changing the fetchPolicy anyway, don't try to change it here\n      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n      options.fetchPolicy === oldFetchPolicy ||\n      // A `nextFetchPolicy` function has even higher priority, though,\n      // so in that case `applyNextFetchPolicy` must be called.\n      typeof options.nextFetchPolicy === \"function\")) {\n        // This might mutate options.fetchPolicy\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n    const oldNetworkStatus = this.networkStatus;\n    if (!newNetworkStatus) {\n      newNetworkStatus = NetworkStatus.loading;\n      if (oldNetworkStatus !== NetworkStatus.loading && newOptions !== null && newOptions !== void 0 && newOptions.variables && !equal(newOptions.variables, oldVariables)) {\n        newNetworkStatus = NetworkStatus.setVariables;\n      }\n      // QueryManager does not emit any values for standby fetch policies so we\n      // want ensure that the networkStatus remains ready.\n      if (options.fetchPolicy === \"standby\") {\n        newNetworkStatus = NetworkStatus.ready;\n      }\n    }\n    if (options.fetchPolicy === \"standby\") {\n      this.cancelPolling();\n    }\n    this.resubscribeCache();\n    const {\n      promise,\n      operator: promiseOperator\n    } = getTrackingOperatorPromise(\n    // This default value should only be used when using a `fetchPolicy` of\n    // `standby` since that fetch policy completes without emitting a\n    // result. Since we are converting this to a QueryResult type, we\n    // omit the extra fields from ApolloQueryResult in the default value.\n    options.fetchPolicy === \"standby\" ? {\n      data: undefined\n    } : undefined);\n    const {\n      subscription,\n      observable,\n      fromLink\n    } = this.fetch(options, newNetworkStatus, query, promiseOperator);\n    if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {\n      if (this.linkSubscription) {\n        this.linkSubscription.unsubscribe();\n      }\n      this.linkSubscription = subscription;\n    }\n    const ret = Object.assign(preventUnhandledRejection(promise.then(result => toQueryResult(this.maskResult(result))).finally(() => {\n      if (!this.hasObservers() && this.activeOperations.size === 0) {\n        // If `reobserve` was called on a query without any observers,\n        // the teardown logic would never be called, so we need to\n        // call it here to ensure the query is properly torn down.\n        this.tearDownQuery();\n      }\n    })), {\n      retain: () => {\n        const subscription = observable.subscribe({});\n        const unsubscribe = () => subscription.unsubscribe();\n        promise.then(unsubscribe, unsubscribe);\n        return ret;\n      }\n    });\n    return ret;\n  }\n  hasObservers() {\n    return this.subject.observed;\n  }\n  /**\n   * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.\n   */\n  stop() {\n    this.subject.complete();\n    this.initializeObservablesQueue();\n    this.tearDownQuery();\n  }\n  tearDownQuery() {\n    var _this$unsubscribeFrom2;\n    if (this.isTornDown) return;\n    this.resetNotifications();\n    (_this$unsubscribeFrom2 = this.unsubscribeFromCache) === null || _this$unsubscribeFrom2 === void 0 || _this$unsubscribeFrom2.call(this);\n    if (this.linkSubscription) {\n      this.linkSubscription.unsubscribe();\n      delete this.linkSubscription;\n    }\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.obsQueries.delete(this);\n    this.isTornDown = true;\n    this.abortActiveOperations();\n    this._lastWrite = undefined;\n  }\n  transformDocument(document) {\n    return this.queryManager.transform(document);\n  }\n  maskResult(result) {\n    const masked = this.queryManager.maskOperation({\n      document: this.query,\n      data: result.data,\n      fetchPolicy: this.options.fetchPolicy,\n      cause: this\n    });\n    // Maintain object identity as much as possible\n    return masked === result.data ? result : _objectSpread(_objectSpread({}, result), {}, {\n      data: masked\n    });\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  resetNotifications() {\n    if (this.notifyTimeout) {\n      clearTimeout(this.notifyTimeout);\n      this.notifyTimeout = void 0;\n    }\n    this.dirty = false;\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  scheduleNotify() {\n    if (this.dirty) return;\n    this.dirty = true;\n    if (!this.notifyTimeout) {\n      this.notifyTimeout = setTimeout(() => this.notify(true), 0);\n    }\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  notify() {\n    let scheduled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!scheduled) {\n      // For queries with client exports or forced resolvers, we don't want to\n      // synchronously reobserve the cache on broadcast,\n      // but actually wait for the `scheduleNotify` timeout triggered by the\n      // `cache.watch` callback from `resubscribeCache`.\n      const info = this.queryManager.getDocumentInfo(this.query);\n      if (info.hasClientExports || info.hasForcedResolvers) {\n        return;\n      }\n    }\n    const {\n      dirty\n    } = this;\n    this.resetNotifications();\n    if (dirty && (this.options.fetchPolicy === \"cache-only\" || this.options.fetchPolicy === \"cache-and-network\" || !this.activeOperations.size)) {\n      const diff = this.getCacheDiff();\n      if (\n      // `fromOptimisticTransaction` is not available through the `cache.diff`\n      // code path, so we need to check it this way\n      equal(diff.result, this.getCacheDiff({\n        optimistic: false\n      }).result)) {\n        //If this diff did not come from an optimistic transaction\n        // make the ObservableQuery \"reobserve\" the latest data\n        // using a temporary fetch policy of \"cache-first\", so complete cache\n        // results have a chance to be delivered without triggering additional\n        // network requests, even when options.fetchPolicy is \"network-only\"\n        // or \"cache-and-network\". All other fetch policies are preserved by\n        // this method, and are handled by calling oq.reobserve(). If this\n        // reobservation is spurious, distinctUntilChanged still has a\n        // chance to catch it before delivery to ObservableQuery subscribers.\n        this.reobserveCacheFirst();\n      } else {\n        // If this diff came from an optimistic transaction, deliver the\n        // current cache data to the ObservableQuery, but don't perform a\n        // reobservation, since oq.reobserveCacheFirst might make a network\n        // request, and we never want to trigger network requests in the\n        // middle of optimistic updates.\n        this.input.next({\n          kind: \"N\",\n          value: {\n            data: diff.result,\n            dataState: diff.complete ? \"complete\" : diff.result ? \"partial\" : \"empty\",\n            networkStatus: NetworkStatus.ready,\n            loading: false,\n            error: undefined,\n            partial: !diff.complete\n          },\n          source: \"cache\",\n          query: this.query,\n          variables: this.variables,\n          meta: {}\n        });\n      }\n    }\n  }\n  pushOperation(networkStatus) {\n    let aborted = false;\n    // track query and variables from the start of the operation\n    const {\n      query,\n      variables\n    } = this;\n    const finalize = () => {\n      this.activeOperations.delete(operation);\n    };\n    const operation = {\n      override: networkStatus,\n      abort: () => {\n        aborted = true;\n        finalize();\n      },\n      query,\n      variables\n    };\n    this.activeOperations.add(operation);\n    return {\n      finalize,\n      pushNotification: (notification, additionalMeta) => {\n        if (!aborted) {\n          this.input.next(_objectSpread(_objectSpread({}, notification), {}, {\n            query,\n            variables,\n            meta: _objectSpread({}, additionalMeta)\n          }));\n        }\n      }\n    };\n  }\n  calculateNetworkStatus(baseNetworkStatus) {\n    var _operation$override;\n    if (baseNetworkStatus === NetworkStatus.streaming) {\n      return baseNetworkStatus;\n    }\n    // in the future, this could be more complex logic, e.g. \"refetch\" and\n    // \"fetchMore\" having priority over \"polling\" or \"loading\" network statuses\n    // as for now we just take the \"latest\" operation that is still active,\n    // as that lines up best with previous behavior[]\n    const operation = Array.from(this.activeOperations.values()).reverse().find(operation => isEqualQuery(operation, this) && operation.override !== undefined);\n    return (_operation$override = operation === null || operation === void 0 ? void 0 : operation.override) !== null && _operation$override !== void 0 ? _operation$override : baseNetworkStatus;\n  }\n  abortActiveOperations() {\n    this.activeOperations.forEach(operation => operation.abort());\n  }\n  /**\n  * @internal\n  * Called from `clearStore`.\n  *\n  * - resets the query to its initial state\n  * - cancels all active operations and their subscriptions\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  reset() {\n    // exception for cache-only queries - we reset them into a \"ready\" state\n    // as we won't trigger a refetch for them\n    const resetToEmpty = this.options.fetchPolicy === \"cache-only\";\n    this.setResult(resetToEmpty ? empty : uninitialized, {\n      shouldEmit: resetToEmpty ? 1 /* EmitBehavior.force */ : 2 /* EmitBehavior.never */\n    });\n    this.abortActiveOperations();\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  setResult(result, additionalMeta) {\n    this.input.next({\n      source: \"setResult\",\n      kind: \"N\",\n      value: result,\n      query: this.query,\n      variables: this.variables,\n      meta: _objectSpread({}, additionalMeta)\n    });\n  }\n  // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n  // delivery of any new data from the cache, possibly falling back to the network\n  // if any cache data are missing. This allows _complete_ cache results to be\n  // delivered without also kicking off unnecessary network requests when\n  // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n  // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n  // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n  reobserveCacheFirst() {\n    const {\n      fetchPolicy,\n      nextFetchPolicy\n    } = this.options;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n      this.reobserve({\n        fetchPolicy: \"cache-first\",\n        // Use a temporary nextFetchPolicy function that replaces itself with the\n        // previous nextFetchPolicy value and returns the original fetchPolicy.\n        nextFetchPolicy(currentFetchPolicy, context) {\n          // Replace this nextFetchPolicy function in the options object with the\n          // original this.options.nextFetchPolicy value.\n          this.nextFetchPolicy = nextFetchPolicy;\n          // If the original nextFetchPolicy value was a function, give it a\n          // chance to decide what happens here.\n          if (typeof this.nextFetchPolicy === \"function\") {\n            return this.nextFetchPolicy(currentFetchPolicy, context);\n          }\n          // Otherwise go back to the original this.options.fetchPolicy.\n          return fetchPolicy;\n        }\n      });\n    } else {\n      this.reobserve();\n    }\n  }\n  getVariablesWithDefaults(variables) {\n    return this.queryManager.getVariables(this.query, variables);\n  }\n}\nexport function logMissingFieldErrors(missing) {\n  if (__DEV__ && missing) {\n    __DEV__ && invariant.debug(86, missing);\n  }\n}\nfunction isEqualQuery(a, b) {\n  return !!(a && b && a.query === b.query && equal(a.variables, b.variables));\n}\nfunction getTrackingOperatorPromise(defaultValue) {\n  let lastValue = defaultValue,\n    resolve,\n    reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const operator = tap({\n    next(value) {\n      if (value.kind === \"E\") {\n        return reject(value.error);\n      }\n      if (value.kind === \"N\" && value.source !== \"newNetworkStatus\" && !value.value.loading) {\n        lastValue = value.value;\n      }\n    },\n    finalize: () => {\n      if (lastValue) {\n        resolve(lastValue);\n      } else {\n        const message = \"The operation was aborted.\";\n        const name = \"AbortError\";\n        reject(typeof DOMException !== \"undefined\" ? new DOMException(message, name)\n        // some environments do not have `DOMException`, e.g. node\n        // uses a normal `Error` with a `name` property instead: https://github.com/phryneas/node/blob/d0579b64f0f6b722f8e49bf8a471dd0d0604a21e/lib/internal/errors.js#L964\n        // error.code is a legacy property that is not used anymore,\n        // and also inconsistent across environments (in supporting\n        // browsers it is `20`, in node `'ABORT_ERR'`) so we omit that.\n        : Object.assign(new Error(message), {\n          name\n        }));\n      }\n    }\n  });\n  return {\n    promise,\n    operator\n  };\n}","map":{"version":3,"names":["equal","BehaviorSubject","filter","Observable","share","Subject","tap","isNetworkRequestInFlight","isNetworkRequestSettled","__DEV__","compact","equalByQuery","extensionsSymbol","filterMap","getOperationDefinition","getOperationName","getQueryDefinition","preventUnhandledRejection","toQueryResult","variablesUnknownSymbol","invariant","NetworkStatus","assign","hasOwnProperty","Object","uninitialized","loading","networkStatus","data","undefined","dataState","partial","empty","ready","ObservableQuery","query","lastQuery","variables","options","subject","getValue","result","cache","queryManager","constructor","_ref","transformedQuery","transform","_defineProperty","Set","Symbol","observable","notification","meta","source","value","kind","isEqualQuery","previous","returnPartialData","error","fetchPolicy","waitForNetworkResult","resubscribeCache","_objectSpread","shouldEmit","baseResult","getInitialResult","resetError","calculateNetworkStatus","maskResult","isTornDown","subscribeToMore","bind","watchQuery","defaultFetchPolicy","defaultOptions","initialFetchPolicy","variablesUnknown","getVariablesWithDefaults","initializeObservablesQueue","opDef","queryName","name","pipe","subscribe","observed","reobserve","setTimeout","updatePolling","unsubscribe","tearDownQuery","_ref2","context","current","previousVariables","emit","documentInfo","getDocumentInfo","dataMasking","maskedQuery","nonReactiveQuery","resultIsEqual","hasNonreactiveDirective","notifyOnNetworkStatusChange","input","complete","operator","getCacheDiff","optimistic","arguments","length","diff","prioritizeCacheValues","cacheResult","_diff$result","shouldUnsubscribe","shouldResubscribe","unsubscribeFromCache","_this$unsubscribeFrom","call","watch","watcher","callback","info","hasClientExports","hasForcedResolvers","lastDiff","lastOwnDiff","previousResult","scheduleNotify","cancelWatch","getCurrentResult","hasObservers","stableLastResult","refetch","reobserveOptions","pollInterval","queryDef","vars","variableDefinitions","some","v","variable","_queryDef$name","warn","_lastWrite","_reobserve","newNetworkStatus","fetchMore","_ref3","errorPolicy","updateQuery","combinedOptions","transformDocument","wasUpdated","isCached","finalize","pushNotification","pushOperation","promise","getTrackingOperatorPromise","fetchObservableWithInfo","exposeExtensions","subscription","next","fetchMoreResult","extensions","batch","update","writeQuery","onWatchUpdated","lastResult","then","finally","startGraphQLSubscription","document","subscriptionData","onError","updateOptions","subscriptions","add","delete","applyOptions","newOptions","mergedOptions","setVariables","mapFn","newResult","previousData","broadcastQueries","startPolling","stopPolling","applyNextFetchPolicy","reason","nextFetchPolicy","fetch","fetchQuery","_options$context","synchronouslyEmitted","onCacheHit","fetchQueryOperator","subscriber","operation","override","fromLink","observableQuery","abort","activeOperations","forceFirstValueEmit","ssrMode","pollingInfo","didWarnCacheOnlyPolling","cancelPolling","interval","maybeFetch","_this$options$skipPol","_this$options","skipPollAttempt","poll","clearTimeout","timeout","internalOptions","obsQueries","useDisposableObservable","oldVariables","oldFetchPolicy","oldNetworkStatus","promiseOperator","linkSubscription","ret","size","retain","stop","_this$unsubscribeFrom2","resetNotifications","forEach","sub","clear","abortActiveOperations","masked","maskOperation","cause","notifyTimeout","dirty","notify","scheduled","reobserveCacheFirst","aborted","additionalMeta","baseNetworkStatus","_operation$override","streaming","Array","from","values","reverse","find","reset","resetToEmpty","setResult","currentFetchPolicy","getVariables","logMissingFieldErrors","missing","debug","a","b","defaultValue","lastValue","resolve","reject","Promise","res","rej","message","DOMException","Error"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/core/ObservableQuery.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport type {\n  InteropObservable,\n  MonoTypeOperatorFunction,\n  Observer,\n  OperatorFunction,\n  Subscribable,\n  Subscription,\n} from \"rxjs\";\nimport { BehaviorSubject, filter, Observable, share, Subject, tap } from \"rxjs\";\n\nimport type { Cache, MissingFieldError } from \"@apollo/client/cache\";\nimport type { MissingTree } from \"@apollo/client/cache\";\nimport type { MaybeMasked, Unmasked } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport {\n  isNetworkRequestInFlight,\n  isNetworkRequestSettled,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  compact,\n  equalByQuery,\n  extensionsSymbol,\n  filterMap,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  preventUnhandledRejection,\n  toQueryResult,\n  variablesUnknownSymbol,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  DataState,\n  DefaultContext,\n  ErrorLike,\n  GetDataState,\n  OperationVariables,\n  QueryNotification,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  NextFetchPolicyContext,\n  RefetchWritePolicy,\n  SubscribeToMoreUpdateQueryFn,\n  UpdateQueryMapFn,\n  UpdateQueryOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nconst { assign, hasOwnProperty } = Object;\n\ninterface TrackedOperation {\n  /**\n   * This NetworkStatus will be used to override the current networkStatus\n   */\n  override?: NetworkStatus;\n  /**\n   * Will abort tracking the operation from this ObservableQuery and remove it from `activeOperations`\n   */\n  abort: () => void;\n  /**\n   * `query` that was used by the `ObservableQuery` as the \"main query\" at the time the operation was started\n   * This is not necessarily the same query as the query the operation itself is doing.\n   */\n  query: DocumentNode;\n  variables: OperationVariables;\n}\n\nconst uninitialized: ObservableQuery.Result<any> = {\n  loading: true,\n  networkStatus: NetworkStatus.loading,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true,\n};\n\nconst empty: ObservableQuery.Result<any> = {\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true,\n};\n\nconst enum EmitBehavior {\n  /**\n   * Emit will be calculated by the normal rules. (`undefined` will be treated the same as this)\n   */\n  default = 0,\n  /**\n   * This result should always be emitted, even if the result is equal to the\n   * previous result. (e.g. the first value after a `refetch`)\n   */\n  force = 1,\n  /**\n   * Never emit this result, it is only used to update `currentResult`.\n   */\n  never = 2,\n  /**\n   * This is a result carrying only a \"network status change\"/loading state update,\n   * emit according to the `notifyOnNetworkStatusChange` option.\n   */\n  networkStatusChange = 3,\n}\ninterface Meta {\n  shouldEmit?: EmitBehavior;\n  /** can be used to override `ObservableQuery.options.fetchPolicy` for this notification */\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport declare namespace ObservableQuery {\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n    initialFetchPolicy: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n    variables: TVariables;\n  };\n\n  export type FetchMoreOptions<\n    TData,\n    TVariables extends OperationVariables,\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query?: DocumentNode | TypedDocumentNode<TFetchData, TFetchVars>;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n    variables?: Partial<NoInfer<TFetchVars>>;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n    updateQuery?: (\n      previousQueryResult: Unmasked<TData>,\n      options: {\n        fetchMoreResult: Unmasked<TFetchData>;\n        variables: TFetchVars;\n      }\n    ) => Unmasked<TData>;\n  };\n\n  export interface SubscribeToMoreOptions<\n    // eslint-disable-next-line local-rules/tdata-tvariables-order\n    TData = unknown,\n    TSubscriptionVariables extends OperationVariables = OperationVariables,\n    TSubscriptionData = TData,\n    TVariables extends OperationVariables = TSubscriptionVariables,\n  > {\n    document:\n      | DocumentNode\n      | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;\n    variables?: TSubscriptionVariables;\n    updateQuery?: SubscribeToMoreUpdateQueryFn<\n      TData,\n      TVariables,\n      TSubscriptionData\n    >;\n    onError?: (error: ErrorLike) => void;\n    context?: DefaultContext;\n  }\n\n  /**\n   * @internal\n   * This describes the `WatchOptions` used by `ObservableQuery` to\n   * subscribe to the cache.\n   */\n  interface CacheWatchOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > extends Cache.WatchOptions<TData, TVariables> {\n    /**\n     * @internal\n     * We cannot suppress the broadcast completely, since that would\n     * result in external updates to be lost if we go from\n     * (external A) -> (own B) -> (external C) when A and C have the same\n     * value.\n     * Without the `own B` being broadcast, the `cache.watch` would swallow\n     * C.\n     * So instead we track the last \"own diff\" and suppress further processing\n     * in the callback.\n     */\n    lastOwnDiff?: Cache.DiffResult<TData>;\n  }\n\n  export type Result<\n    TData,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n    error?: ErrorLike;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n    loading: boolean;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n    networkStatus: NetworkStatus;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#partial:member} */\n    partial: boolean;\n  } & GetDataState<TData, TStates>;\n\n  /**\n   * Promise returned by `reobserve` and `refetch` methods.\n   *\n   * By default, if the `ObservableQuery` is not interested in the result\n   * of this operation anymore, the network operation will be cancelled.\n   *\n   * This has an additional `retain` method that can be used to keep the\n   * network operation running until it is finished nonetheless.\n   */\n  interface ResultPromise<T> extends Promise<T> {\n    /**\n     * Keep the network operation running until it is finished, even if\n     * `ObservableQuery` unsubscribed from the operation.\n     */\n    retain(): this;\n  }\n\n  export namespace DocumentationTypes {\n    type OperatorFunctionChain<From, To> = [];\n    interface ObservableMethods<TData, OperatorResult> {\n      /** {@inheritDoc @apollo/client!ObservableQuery#pipe:member} */\n      pipe(\n        ...operators: OperatorFunctionChain<\n          ObservableQuery.Result<TData>,\n          OperatorResult\n        >\n      ): Observable<OperatorResult>;\n\n      /** {@inheritDoc @apollo/client!ObservableQuery#subscribe:member} */\n      subscribe(\n        observerOrNext:\n          | Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>>\n          | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)\n      ): Subscription;\n    }\n  }\n}\n\ninterface SubjectValue<TData, TVariables extends OperationVariables> {\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  variables: TVariables;\n  result: ObservableQuery.Result<TData>;\n  meta: Meta;\n}\n\nexport class ObservableQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >\n  implements\n    Subscribable<ObservableQuery.Result<MaybeMasked<TData>>>,\n    InteropObservable<ObservableQuery.Result<MaybeMasked<TData>>>\n{\n  public readonly options: ObservableQuery.Options<TData, TVariables>;\n  public readonly queryName?: string;\n  private variablesUnknown: boolean = false;\n\n  /** @internal will be read and written from `QueryInfo` */\n  public _lastWrite?: unknown;\n\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  public get query(): TypedDocumentNode<TData, TVariables> {\n    return this.lastQuery;\n  }\n\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  public get variables(): TVariables {\n    return this.options.variables;\n  }\n\n  private unsubscribeFromCache?: {\n    (): void;\n    query: TypedDocumentNode<TData, TVariables>;\n    variables: TVariables;\n  };\n  private input!: Subject<\n    QueryNotification.Value<TData> & {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      meta: Meta;\n    }\n  >;\n  private subject!: BehaviorSubject<\n    SubjectValue<MaybeMasked<TData>, TVariables>\n  >;\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager;\n  private subscriptions = new Set<Subscription>();\n\n  /**\n   * If an `ObservableQuery` is created with a `network-only` fetch policy,\n   * it should actually start receiving cache updates, but not before it has\n   * received the first result from the network.\n   */\n  private waitForNetworkResult: boolean;\n  private lastQuery: DocumentNode;\n\n  private linkSubscription?: Subscription;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  private get networkStatus(): NetworkStatus {\n    return this.subject.getValue().result.networkStatus;\n  }\n\n  private get cache() {\n    return this.queryManager.cache;\n  }\n\n  constructor({\n    queryManager,\n    options,\n    transformedQuery = queryManager.transform(options.query),\n  }: {\n    queryManager: QueryManager;\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>;\n    transformedQuery?: DocumentNode | TypedDocumentNode<TData, TVariables>;\n    queryId?: string;\n  }) {\n    this.queryManager = queryManager;\n\n    // active state\n    this.waitForNetworkResult = options.fetchPolicy === \"network-only\";\n    this.isTornDown = false;\n\n    this.subscribeToMore = this.subscribeToMore.bind(this);\n    this.maskResult = this.maskResult.bind(this);\n\n    const {\n      watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {},\n    } = queryManager.defaultOptions;\n\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : (\n        fetchPolicy\n      ),\n    } = options;\n\n    if (options[variablesUnknownSymbol]) {\n      invariant(\n        fetchPolicy === \"standby\",\n        \"The `variablesUnknown` option can only be used together with a `standby` fetch policy.\"\n      );\n      this.variablesUnknown = true;\n    }\n\n    this.lastQuery = transformedQuery;\n\n    this.options = {\n      ...options,\n\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n      variables: this.getVariablesWithDefaults(options.variables),\n    };\n\n    this.initializeObservablesQueue();\n\n    this[\"@@observable\"] = () => this;\n    if (Symbol.observable) {\n      this[Symbol.observable] = () => this;\n    }\n\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n\n  private initializeObservablesQueue() {\n    this.subject = new BehaviorSubject<\n      SubjectValue<MaybeMasked<TData>, TVariables>\n    >({\n      query: this.query,\n      variables: this.variables,\n      result: uninitialized,\n      meta: {},\n    });\n    const observable = this.subject.pipe(\n      tap({\n        subscribe: () => {\n          if (!this.subject.observed) {\n            this.reobserve();\n\n            // TODO: See if we can rework updatePolling to better handle this.\n            // reobserve calls updatePolling but this `subscribe` callback is\n            // called before the subject is subscribed to so `updatePolling`\n            // can't accurately detect if there is an active subscription.\n            // Calling it again here ensures that it can detect if it can poll\n            setTimeout(() => this.updatePolling());\n          }\n        },\n        unsubscribe: () => {\n          if (!this.subject.observed) {\n            this.tearDownQuery();\n          }\n        },\n      }),\n      filterMap(\n        (\n          { query, variables, result: current, meta },\n          context: {\n            previous?: ObservableQuery.Result<TData>;\n            previousVariables?: TVariables;\n          }\n        ) => {\n          const { shouldEmit } = meta;\n\n          if (current === uninitialized) {\n            // reset internal state after `ObservableQuery.reset()`\n            context.previous = undefined;\n            context.previousVariables = undefined;\n          }\n          if (\n            this.options.fetchPolicy === \"standby\" ||\n            shouldEmit === EmitBehavior.never\n          )\n            return;\n          if (shouldEmit === EmitBehavior.force) return emit();\n\n          const { previous, previousVariables } = context;\n\n          if (previous) {\n            const documentInfo = this.queryManager.getDocumentInfo(query);\n            const dataMasking = this.queryManager.dataMasking;\n            const maskedQuery =\n              dataMasking ? documentInfo.nonReactiveQuery : query;\n\n            const resultIsEqual =\n              dataMasking || documentInfo.hasNonreactiveDirective ?\n                equalByQuery(maskedQuery, previous, current, variables)\n              : equal(previous, current);\n\n            if (resultIsEqual && equal(previousVariables, variables)) {\n              return;\n            }\n          }\n\n          if (\n            shouldEmit === EmitBehavior.networkStatusChange &&\n            (!this.options.notifyOnNetworkStatusChange ||\n              equal(previous, current))\n          ) {\n            return;\n          }\n          return emit();\n\n          function emit() {\n            context.previous = current;\n            context.previousVariables = variables;\n            return current;\n          }\n        },\n        () => ({})\n      )\n    );\n\n    this.pipe = observable.pipe.bind(observable);\n    this.subscribe = observable.subscribe.bind(observable);\n\n    this.input = new Subject();\n    // we want to feed many streams into `this.subject`, but none of them should\n    // be able to close `this.input`\n    this.input.complete = () => {};\n    this.input.pipe(this.operator).subscribe(this.subject);\n  }\n\n  // We can't use Observable['subscribe'] here as the type as it conflicts with\n  // the ability to infer T from Subscribable<T>. This limits the surface area\n  // to the non-deprecated signature which works properly with type inference.\n  /**\n   * Subscribes to the `ObservableQuery`.\n   * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @returns A subscription reference to the registered handlers.\n   */\n  public subscribe!: (\n    observerOrNext:\n      | Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>>\n      | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)\n  ) => Subscription;\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * @example\n   *\n   * ```ts\n   * import { filter, map } from 'rxjs';\n   *\n   * observableQuery\n   *   .pipe(\n   *     filter(...),\n   *     map(...),\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @returns The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  public pipe!: Observable<ObservableQuery.Result<MaybeMasked<TData>>>[\"pipe\"];\n\n  public [Symbol.observable]!: () => Subscribable<\n    ObservableQuery.Result<MaybeMasked<TData>>\n  >;\n  public [\"@@observable\"]: () => Subscribable<\n    ObservableQuery.Result<MaybeMasked<TData>>\n  >;\n\n  /**\n   * @internal\n   */\n  public getCacheDiff({ optimistic = true } = {}) {\n    return this.cache.diff<TData>({\n      query: this.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic,\n    });\n  }\n\n  private getInitialResult(\n    initialFetchPolicy?: WatchQueryFetchPolicy\n  ): ObservableQuery.Result<MaybeMasked<TData>> {\n    let fetchPolicy = initialFetchPolicy || this.options.fetchPolicy;\n    if (\n      this.queryManager.prioritizeCacheValues &&\n      (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")\n    ) {\n      fetchPolicy = \"cache-first\";\n    }\n\n    const cacheResult = (): ObservableQuery.Result<TData> => {\n      const diff = this.getCacheDiff();\n      // TODO: queryInfo.getDiff should handle this since cache.diff returns a\n      // null when returnPartialData is false\n      const data =\n        this.options.returnPartialData || diff.complete ?\n          (diff.result as TData) ?? undefined\n        : undefined;\n\n      return this.maskResult({\n        data,\n        dataState:\n          diff.complete ? \"complete\"\n          : data === undefined ? \"empty\"\n          : \"partial\",\n        loading: !diff.complete,\n        networkStatus:\n          diff.complete ? NetworkStatus.ready : NetworkStatus.loading,\n        partial: !diff.complete,\n      } as ObservableQuery.Result<TData>);\n    };\n\n    switch (fetchPolicy) {\n      case \"cache-only\": {\n        return {\n          ...cacheResult(),\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n      }\n      case \"cache-first\":\n        return cacheResult();\n      case \"cache-and-network\":\n        return {\n          ...cacheResult(),\n          loading: true,\n          networkStatus: NetworkStatus.loading,\n        };\n      case \"standby\":\n        return empty;\n\n      default:\n        return uninitialized;\n    }\n  }\n\n  private resubscribeCache() {\n    const { variables, fetchPolicy } = this.options;\n    const query = this.query;\n\n    const shouldUnsubscribe =\n      fetchPolicy === \"standby\" ||\n      fetchPolicy === \"no-cache\" ||\n      this.waitForNetworkResult;\n\n    const shouldResubscribe =\n      !isEqualQuery({ query, variables }, this.unsubscribeFromCache) &&\n      !this.waitForNetworkResult;\n\n    if (shouldUnsubscribe || shouldResubscribe) {\n      this.unsubscribeFromCache?.();\n    }\n\n    if (shouldUnsubscribe || !shouldResubscribe) {\n      return;\n    }\n\n    const watch: ObservableQuery.CacheWatchOptions<TData, TVariables> = {\n      query,\n      variables,\n      optimistic: true,\n      watcher: this,\n      callback: (diff) => {\n        const info = this.queryManager.getDocumentInfo(query);\n        if (info.hasClientExports || info.hasForcedResolvers) {\n          // If this is not set to something different than `diff`, we will\n          // not be notified about future cache changes with an equal `diff`.\n          // That would be the case if we are working with client-only fields\n          // that are forced or with `exports` fields that might change, causing\n          // local resolvers to return a new result.\n          // This is based on an implementation detail of `InMemoryCache`, which\n          // is not optimal - but the only alternative to this would be to\n          // resubscribe to the cache asynchonouly, which would bear the risk of\n          // missing further synchronous updates.\n          watch.lastDiff = undefined;\n        }\n        if (watch.lastOwnDiff === diff) {\n          // skip cache updates that were caused by our own writes\n          return;\n        }\n\n        const { result: previousResult } = this.subject.getValue();\n\n        if (\n          !diff.complete &&\n          // If we are trying to deliver an incomplete cache result, we avoid\n          // reporting it if the query has errored, otherwise we let the broadcast try\n          // and repair the partial result by refetching the query. This check avoids\n          // a situation where a query that errors and another succeeds with\n          // overlapping data does not report the partial data result to the errored\n          // query.\n          //\n          // See https://github.com/apollographql/apollo-client/issues/11400 for more\n          // information on this issue.\n          (previousResult.error ||\n            // Prevent to schedule a notify directly after the `ObservableQuery`\n            // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)\n            // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.\n            previousResult === uninitialized ||\n            previousResult === empty)\n        ) {\n          return;\n        }\n\n        if (!equal(previousResult.data, diff.result)) {\n          this.scheduleNotify();\n        }\n      },\n    };\n    const cancelWatch = this.cache.watch(watch);\n\n    this.unsubscribeFromCache = Object.assign(\n      () => {\n        this.unsubscribeFromCache = undefined;\n        cancelWatch();\n      },\n      { query, variables }\n    );\n  }\n\n  private stableLastResult?: ObservableQuery.Result<MaybeMasked<TData>>;\n  public getCurrentResult(): ObservableQuery.Result<MaybeMasked<TData>> {\n    const { result: current } = this.subject.getValue();\n    let value =\n      (\n        // if the `current` result is in an error state, we will always return that\n        // error state, even if we have no observers\n        current.networkStatus === NetworkStatus.error ||\n        // if we have observers, we are watching the cache and\n        // this.subject.getValue() will always be up to date\n        this.hasObservers() ||\n        // if we are using a `no-cache` fetch policy in which case this\n        // `ObservableQuery` cannot have been updated from the outside - in\n        // that case, we prefer to keep the current value\n        this.options.fetchPolicy === \"no-cache\"\n      ) ?\n        current\n        // otherwise, the `current` value might be outdated due to missed\n        // external updates - calculate it again\n      : this.getInitialResult();\n\n    if (value === uninitialized) {\n      value = this.getInitialResult();\n    }\n    if (!equal(this.stableLastResult, value)) {\n      this.stableLastResult = value;\n    }\n    return this.stableLastResult!;\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * Returns a `ResultPromise` with an additional `.retain()` method. Calling\n   * `.retain()` keeps the network operation running even if the `ObservableQuery`\n   * no longer requires the result.\n   *\n   * Note: `refetch()` guarantees that a value will be emitted from the\n   * observable, even if the result is deep equal to the previous value.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(\n    variables?: Partial<TVariables>\n  ): ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>> {\n    const { fetchPolicy } = this.options;\n\n    const reobserveOptions: Partial<\n      ObservableQuery.Options<TData, TVariables>\n    > = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n        invariant.warn(\n          `Called refetch(%o) for query %o, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`,\n          variables,\n          queryDef.name?.value || queryDef\n        );\n      }\n    }\n\n    if (variables && !equal(this.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables =\n        this.getVariablesWithDefaults({ ...this.variables, ...variables });\n    }\n\n    this._lastWrite = undefined;\n    return this._reobserve(reobserveOptions, {\n      newNetworkStatus: NetworkStatus.refetch,\n    });\n  }\n\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >(\n    options: ObservableQuery.FetchMoreOptions<\n      TData,\n      TVariables,\n      TFetchData,\n      TFetchVars\n    >\n  ): Promise<ApolloClient.QueryResult<TFetchData>>;\n\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >({\n    query,\n    variables,\n    context,\n    errorPolicy,\n    updateQuery,\n  }: ObservableQuery.FetchMoreOptions<\n    TData,\n    TVariables,\n    TFetchData,\n    TFetchVars\n  >): Promise<ApolloClient.QueryResult<TFetchData>> {\n    invariant(\n      this.options.fetchPolicy !== \"cache-only\",\n      \"Cannot execute `fetchMore` for 'cache-only' query '%s'. Please use a different fetch policy.\",\n      getOperationName(this.query, \"(anonymous)\")\n    );\n    const combinedOptions = {\n      ...compact(\n        this.options,\n        { errorPolicy: \"none\" },\n        {\n          query,\n          context,\n          errorPolicy,\n        }\n      ),\n      variables: (query ? variables : (\n        {\n          ...this.variables,\n          ...variables,\n        }\n      )) as TFetchVars,\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n      notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange,\n    } as ApolloClient.QueryOptions<TFetchData, TFetchVars>;\n\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery =\n      query ?\n        this.transformDocument(this.options.query)\n      : combinedOptions.query;\n\n    let wasUpdated = false;\n    const isCached = this.options.fetchPolicy !== \"no-cache\";\n\n    if (!isCached) {\n      invariant(\n        updateQuery,\n        \"You must provide an `updateQuery` function when using `fetchMore` with a `no-cache` fetch policy.\"\n      );\n    }\n\n    const { finalize, pushNotification } = this.pushOperation(\n      NetworkStatus.fetchMore\n    );\n\n    pushNotification(\n      {\n        source: \"newNetworkStatus\",\n        kind: \"N\",\n        value: {},\n      },\n      { shouldEmit: EmitBehavior.networkStatusChange }\n    );\n\n    const { promise, operator } = getTrackingOperatorPromise<TFetchData>();\n\n    const { observable } = this.queryManager.fetchObservableWithInfo(\n      combinedOptions,\n      { networkStatus: NetworkStatus.fetchMore, exposeExtensions: true }\n    );\n\n    const subscription = observable\n      .pipe(\n        operator,\n        filter(\n          (\n            notification\n          ): notification is Extract<\n            QueryNotification.FromNetwork<TFetchData>,\n            { kind: \"N\" }\n          > => notification.kind === \"N\" && notification.source === \"network\"\n        )\n      )\n      .subscribe({\n        next: (notification) => {\n          wasUpdated = false;\n          const fetchMoreResult: QueryManager.Result<TFetchData> =\n            notification.value;\n          const extensions = fetchMoreResult[extensionsSymbol];\n\n          if (isNetworkRequestSettled(notification.value.networkStatus)) {\n            finalize();\n          }\n\n          if (isCached) {\n            // Separately getting a diff here before the batch - `onWatchUpdated` might be\n            // called with an `undefined` `lastDiff` on the watcher if the cache was just subscribed to.\n            const lastDiff = this.getCacheDiff();\n            // Performing this cache update inside a cache.batch transaction ensures\n            // any affected cache.watch watchers are notified at most once about any\n            // updates. Most watchers will be using the QueryInfo class, which\n            // responds to notifications by calling reobserveCacheFirst to deliver\n            // fetchMore cache results back to this ObservableQuery.\n            this.cache.batch({\n              update: (cache) => {\n                if (updateQuery) {\n                  cache.updateQuery(\n                    {\n                      query: this.query,\n                      variables: this.variables,\n                      returnPartialData: true,\n                      optimistic: false,\n                      extensions,\n                    },\n                    (previous) =>\n                      updateQuery(previous! as any, {\n                        fetchMoreResult: fetchMoreResult.data as any,\n                        variables: combinedOptions.variables as TFetchVars,\n                      })\n                  );\n                } else {\n                  // If we're using a field policy instead of updateQuery, the only\n                  // thing we need to do is write the new data to the cache using\n                  // combinedOptions.variables (instead of this.variables, which is\n                  // what this.updateQuery uses, because it works by abusing the\n                  // original field value, keyed by the original variables).\n                  cache.writeQuery({\n                    query: combinedOptions.query,\n                    variables: combinedOptions.variables,\n                    data: fetchMoreResult.data as Unmasked<any>,\n                    extensions,\n                  });\n                }\n              },\n\n              onWatchUpdated: (watch, diff) => {\n                if (\n                  watch.watcher === this &&\n                  !equal(diff.result, lastDiff.result)\n                ) {\n                  wasUpdated = true;\n                  const lastResult = this.getCurrentResult();\n\n                  // Let the cache watch from resubscribeCache handle the final\n                  // result\n                  if (isNetworkRequestInFlight(fetchMoreResult.networkStatus)) {\n                    pushNotification({\n                      kind: \"N\",\n                      source: \"network\",\n                      value: {\n                        ...lastResult,\n                        networkStatus:\n                          (\n                            fetchMoreResult.networkStatus ===\n                            NetworkStatus.error\n                          ) ?\n                            NetworkStatus.ready\n                          : fetchMoreResult.networkStatus,\n                        // will be overwritten anyways, just here for types sake\n                        loading: false,\n                        data: diff.result,\n                        dataState:\n                          fetchMoreResult.dataState === \"streaming\" ?\n                            \"streaming\"\n                          : \"complete\",\n                      },\n                    });\n                  }\n                }\n              },\n            });\n          } else {\n            // There is a possibility `lastResult` may not be set when\n            // `fetchMore` is called which would cause this to crash. This should\n            // only happen if we haven't previously reported a result. We don't\n            // quite know what the right behavior should be here since this block\n            // of code runs after the fetch result has executed on the network.\n            // We plan to let it crash in the meantime.\n            //\n            // If we get bug reports due to the `data` property access on\n            // undefined, this should give us a real-world scenario that we can\n            // use to test against and determine the right behavior. If we do end\n            // up changing this behavior, this may require, for example, an\n            // adjustment to the types on `updateQuery` since that function\n            // expects that the first argument always contains previous result\n            // data, but not `undefined`.\n            const lastResult = this.getCurrentResult();\n            const data = updateQuery!(lastResult.data as Unmasked<TData>, {\n              fetchMoreResult: fetchMoreResult.data as Unmasked<TFetchData>,\n              variables: combinedOptions.variables as TFetchVars,\n            });\n\n            pushNotification({\n              kind: \"N\",\n              value: {\n                ...lastResult,\n                networkStatus: NetworkStatus.ready,\n                // will be overwritten anyways, just here for types sake\n                loading: false,\n                data: data as any,\n                dataState:\n                  lastResult.dataState === \"streaming\" ?\n                    \"streaming\"\n                  : \"complete\",\n              },\n              source: \"network\",\n            });\n          }\n        },\n      });\n\n    return preventUnhandledRejection(\n      promise\n        .then((result) => toQueryResult(this.maskResult(result)))\n        .finally(() => {\n          subscription.unsubscribe();\n          finalize();\n\n          if (isCached && !wasUpdated) {\n            const lastResult = this.getCurrentResult();\n\n            if (lastResult.dataState === \"streaming\") {\n              pushNotification({\n                kind: \"N\",\n                source: \"network\",\n                value: {\n                  ...lastResult,\n                  dataState: \"complete\",\n                  networkStatus: NetworkStatus.ready,\n                } as any,\n              });\n            } else {\n              pushNotification(\n                {\n                  kind: \"N\",\n                  source: \"newNetworkStatus\",\n                  value: {},\n                },\n                { shouldEmit: EmitBehavior.force }\n              );\n            }\n          }\n        })\n    );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables extends OperationVariables = TVariables,\n  >(\n    options: ObservableQuery.SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData,\n      TVariables\n    >\n  ): () => void {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData) => {\n          const { updateQuery, onError } = options;\n          const { error } = subscriptionData;\n\n          if (error) {\n            if (onError) {\n              onError(error);\n            } else {\n              invariant.error(\"Unhandled GraphQL subscription error\", error);\n            }\n\n            return;\n          }\n\n          if (updateQuery) {\n            this.updateQuery((previous, updateOptions) =>\n              updateQuery(previous, {\n                subscriptionData: subscriptionData as {\n                  data: Unmasked<TSubscriptionData>;\n                },\n                ...updateOptions,\n              })\n            );\n          }\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  /** @internal */\n  public applyOptions(\n    newOptions: Partial<ObservableQuery.Options<TData, TVariables>>\n  ): void {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n    this.updatePolling();\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: `setVariables()` guarantees that a value will be emitted from the\n   * observable, even if the result is deeply equal to the previous value.\n   *\n   * Note: the promise will resolve with the last emitted result\n   * when either the variables match the current variables or there\n   * are no subscribers to the query.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public async setVariables(\n    variables: TVariables\n  ): Promise<ApolloClient.QueryResult<TData>> {\n    variables = this.getVariablesWithDefaults(variables);\n\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return toQueryResult(this.getCurrentResult());\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.hasObservers()) {\n      return toQueryResult(this.getCurrentResult());\n    }\n\n    return this._reobserve(\n      {\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables,\n      },\n      { newNetworkStatus: NetworkStatus.setVariables }\n    );\n  }\n\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  public updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void {\n    const { queryManager } = this;\n    const { result, complete } = this.getCacheDiff({ optimistic: false });\n\n    const newResult = mapFn(\n      result! as DeepPartial<Unmasked<TData>>,\n      {\n        variables: this.variables,\n        complete: !!complete,\n        previousData: result,\n      } as UpdateQueryOptions<TData, TVariables>\n    );\n\n    if (newResult) {\n      this.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  private applyNextFetchPolicy(\n    reason: NextFetchPolicyContext<TData, TVariables>[\"reason\"],\n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ) {\n    if (options.nextFetchPolicy) {\n      const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } =\n        options;\n\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.reobserve.\n        options.fetchPolicy = options.nextFetchPolicy.call(\n          options as any,\n          fetchPolicy,\n          { reason, options, observable: this, initialFetchPolicy }\n        );\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n\n    return options.fetchPolicy;\n  }\n\n  private fetch(\n    options: ObservableQuery.Options<TData, TVariables>,\n    networkStatus: NetworkStatus,\n    fetchQuery: DocumentNode,\n    operator: MonoTypeOperatorFunction<QueryNotification.Value<TData>>\n  ) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    const initialFetchPolicy = this.options.fetchPolicy;\n    options.context ??= {};\n\n    let synchronouslyEmitted = false;\n    const onCacheHit = () => {\n      synchronouslyEmitted = true;\n    };\n    const fetchQueryOperator = // we cannot use `tap` here, since it allows only for a \"before subscription\"\n      // hook with `subscribe` and we care for \"directly before and after subscription\"\n      <T>(source: Observable<T>) =>\n        new Observable<T>((subscriber) => {\n          try {\n            return source.subscribe({\n              next(value) {\n                synchronouslyEmitted = true;\n                subscriber.next(value);\n              },\n              error: (error) => subscriber.error(error),\n              complete: () => subscriber.complete(),\n            });\n          } finally {\n            if (!synchronouslyEmitted) {\n              operation.override = networkStatus;\n              this.input.next({\n                kind: \"N\",\n                source: \"newNetworkStatus\",\n                value: {\n                  resetError: true,\n                },\n                query,\n                variables,\n                meta: {\n                  shouldEmit: EmitBehavior.networkStatusChange,\n                  /*\n                   * The moment this notification is emitted, `nextFetchPolicy`\n                   * might already have switched from a `network-only` to a\n                   * `cache-something` policy, so we want to ensure that the\n                   * loading state emit doesn't accidentally read from the cache\n                   * in those cases.\n                   */\n                  fetchPolicy: initialFetchPolicy,\n                },\n              });\n            }\n          }\n        });\n\n    let { observable, fromLink } = this.queryManager.fetchObservableWithInfo(\n      options,\n      {\n        networkStatus,\n        query: fetchQuery,\n        onCacheHit,\n        fetchQueryOperator,\n        observableQuery: this,\n      }\n    );\n\n    // track query and variables from the start of the operation\n    const { query, variables } = this;\n    const operation: TrackedOperation = {\n      abort: () => {\n        subscription.unsubscribe();\n      },\n      query,\n      variables,\n    };\n    this.activeOperations.add(operation);\n\n    let forceFirstValueEmit =\n      networkStatus == NetworkStatus.refetch ||\n      networkStatus == NetworkStatus.setVariables;\n    observable = observable.pipe(operator, share());\n    const subscription = observable\n      .pipe(\n        tap({\n          next: (notification) => {\n            if (\n              notification.source === \"newNetworkStatus\" ||\n              (notification.kind === \"N\" && notification.value.loading)\n            ) {\n              operation.override = networkStatus;\n            } else {\n              delete operation.override;\n            }\n          },\n          finalize: () => this.activeOperations.delete(operation),\n        })\n      )\n      .subscribe({\n        next: (value) => {\n          const meta: Meta = {};\n\n          if (\n            forceFirstValueEmit &&\n            value.kind === \"N\" &&\n            \"loading\" in value.value &&\n            !value.value.loading\n          ) {\n            forceFirstValueEmit = false;\n            meta.shouldEmit = EmitBehavior.force;\n          }\n\n          this.input.next({ ...value, query, variables, meta });\n        },\n      });\n\n    return { fromLink, subscription, observable };\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private didWarnCacheOnlyPolling = false;\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: { fetchPolicy, pollInterval },\n    } = this;\n\n    if (!pollInterval || !this.hasObservers() || fetchPolicy === \"cache-only\") {\n      if (__DEV__) {\n        if (\n          !this.didWarnCacheOnlyPolling &&\n          pollInterval &&\n          fetchPolicy === \"cache-only\"\n        ) {\n          invariant.warn(\n            \"Cannot poll on 'cache-only' query '%s' and as such, polling is disabled. Please use a different fetch policy.\",\n            getOperationName(this.query, \"(anonymous)\")\n          );\n          this.didWarnCacheOnlyPolling = true;\n        }\n      }\n\n      this.cancelPolling();\n      return;\n    }\n\n    if (pollingInfo?.interval === pollInterval) {\n      return;\n    }\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (\n          !isNetworkRequestInFlight(this.networkStatus) &&\n          !this.options.skipPollAttempt?.()\n        ) {\n          this._reobserve(\n            {\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy:\n                this.options.initialFetchPolicy === \"no-cache\" ?\n                  \"no-cache\"\n                : \"network-only\",\n            },\n            {\n              newNetworkStatus: NetworkStatus.poll,\n            }\n          ).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  // This differs from stopPolling in that it does not set pollInterval to 0\n  private cancelPolling() {\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      delete this.pollingInfo;\n    }\n  }\n\n  /**\n   * Reevaluate the query, optionally against new options. New options will be\n   * merged with the current options when given.\n   *\n   * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with\n   * `variables: undefined`.\n   */\n  public reobserve(\n    newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>\n  ): ObservableQuery.ResultPromise<\n    ApolloClient.QueryResult<MaybeMasked<TData>>\n  > {\n    return this._reobserve(newOptions);\n  }\n  private _reobserve(\n    newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>,\n    internalOptions?: {\n      newNetworkStatus?: NetworkStatus;\n    }\n  ): ObservableQuery.ResultPromise<\n    ApolloClient.QueryResult<MaybeMasked<TData>>\n  > {\n    this.isTornDown = false;\n    let { newNetworkStatus } = internalOptions || {};\n\n    this.queryManager.obsQueries.add(this);\n\n    const useDisposableObservable =\n      // Refetching uses a disposable Observable to allow refetches using different\n      // options, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // Polling uses a disposable Observable so the polling options (which force\n      // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n\n    const mergedOptions = compact(this.options, newOptions || {});\n\n    // This request will hit the network, so even if there are no variables,\n    // we now know that's intentional. (see #12996)\n    // Even if that happens only once, we want `variablesUnknown` to stay false permanently.\n    this.variablesUnknown &&= mergedOptions.fetchPolicy === \"standby\";\n\n    const options =\n      useDisposableObservable ?\n        // Disposable Observable fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      : assign(this.options, mergedOptions);\n\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n\n    this.lastQuery = query;\n\n    // Reevaluate variables to allow resetting variables with variables: undefined,\n    // otherwise `compact` will ignore the `variables` key in `newOptions`. We\n    // do this after we run the query transform to ensure we get default\n    // variables from the transformed query.\n    //\n    // Note: updating options.variables may mutate this.options.variables\n    // in the case of a non-disposable query. This is intentional.\n    if (newOptions && \"variables\" in newOptions) {\n      options.variables = this.getVariablesWithDefaults(newOptions.variables);\n    }\n\n    if (!useDisposableObservable) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !equal(newOptions.variables, oldVariables) &&\n        // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" &&\n        // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        (options.fetchPolicy === oldFetchPolicy ||\n          // A `nextFetchPolicy` function has even higher priority, though,\n          // so in that case `applyNextFetchPolicy` must be called.\n          typeof options.nextFetchPolicy === \"function\")\n      ) {\n        // This might mutate options.fetchPolicy\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    const oldNetworkStatus = this.networkStatus;\n\n    if (!newNetworkStatus) {\n      newNetworkStatus = NetworkStatus.loading;\n\n      if (\n        oldNetworkStatus !== NetworkStatus.loading &&\n        newOptions?.variables &&\n        !equal(newOptions.variables, oldVariables)\n      ) {\n        newNetworkStatus = NetworkStatus.setVariables;\n      }\n\n      // QueryManager does not emit any values for standby fetch policies so we\n      // want ensure that the networkStatus remains ready.\n      if (options.fetchPolicy === \"standby\") {\n        newNetworkStatus = NetworkStatus.ready;\n      }\n    }\n\n    if (options.fetchPolicy === \"standby\") {\n      this.cancelPolling();\n    }\n\n    this.resubscribeCache();\n    const { promise, operator: promiseOperator } = getTrackingOperatorPromise(\n      // This default value should only be used when using a `fetchPolicy` of\n      // `standby` since that fetch policy completes without emitting a\n      // result. Since we are converting this to a QueryResult type, we\n      // omit the extra fields from ApolloQueryResult in the default value.\n      options.fetchPolicy === \"standby\" ?\n        ({ data: undefined } as ObservableQuery.Result<TData>)\n      : undefined\n    );\n    const { subscription, observable, fromLink } = this.fetch(\n      options,\n      newNetworkStatus,\n      query,\n      promiseOperator\n    );\n\n    if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {\n      if (this.linkSubscription) {\n        this.linkSubscription.unsubscribe();\n      }\n\n      this.linkSubscription = subscription;\n    }\n\n    const ret = Object.assign(\n      preventUnhandledRejection(\n        promise\n          .then((result) => toQueryResult(this.maskResult(result)))\n          .finally(() => {\n            if (!this.hasObservers() && this.activeOperations.size === 0) {\n              // If `reobserve` was called on a query without any observers,\n              // the teardown logic would never be called, so we need to\n              // call it here to ensure the query is properly torn down.\n              this.tearDownQuery();\n            }\n          })\n      ),\n      {\n        retain: () => {\n          const subscription = observable.subscribe({});\n          const unsubscribe = () => subscription.unsubscribe();\n          promise.then(unsubscribe, unsubscribe);\n          return ret;\n        },\n      }\n    );\n    return ret;\n  }\n\n  public hasObservers() {\n    return this.subject.observed;\n  }\n\n  /**\n   * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.\n   */\n  public stop() {\n    this.subject.complete();\n    this.initializeObservablesQueue();\n    this.tearDownQuery();\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n\n    this.resetNotifications();\n    this.unsubscribeFromCache?.();\n    if (this.linkSubscription) {\n      this.linkSubscription.unsubscribe();\n      delete this.linkSubscription;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach((sub) => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.obsQueries.delete(this);\n    this.isTornDown = true;\n    this.abortActiveOperations();\n    this._lastWrite = undefined;\n  }\n\n  private transformDocument(document: DocumentNode) {\n    return this.queryManager.transform(document);\n  }\n\n  private maskResult<T extends { data: any }>(result: T): T {\n    const masked = this.queryManager.maskOperation({\n      document: this.query,\n      data: result.data,\n      fetchPolicy: this.options.fetchPolicy,\n      cause: this,\n    });\n\n    // Maintain object identity as much as possible\n    return masked === result.data ? result : { ...result, data: masked };\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  /** @internal */\n  private resetNotifications() {\n    if (this.notifyTimeout) {\n      clearTimeout(this.notifyTimeout);\n      this.notifyTimeout = void 0;\n    }\n    this.dirty = false;\n  }\n\n  /** @internal */\n  private scheduleNotify() {\n    if (this.dirty) return;\n    this.dirty = true;\n    if (!this.notifyTimeout) {\n      this.notifyTimeout = setTimeout(() => this.notify(true), 0);\n    }\n  }\n\n  /** @internal */\n  public notify(scheduled = false) {\n    if (!scheduled) {\n      // For queries with client exports or forced resolvers, we don't want to\n      // synchronously reobserve the cache on broadcast,\n      // but actually wait for the `scheduleNotify` timeout triggered by the\n      // `cache.watch` callback from `resubscribeCache`.\n      const info = this.queryManager.getDocumentInfo(this.query);\n      if (info.hasClientExports || info.hasForcedResolvers) {\n        return;\n      }\n    }\n\n    const { dirty } = this;\n    this.resetNotifications();\n\n    if (\n      dirty &&\n      (this.options.fetchPolicy === \"cache-only\" ||\n        this.options.fetchPolicy === \"cache-and-network\" ||\n        !this.activeOperations.size)\n    ) {\n      const diff = this.getCacheDiff();\n      if (\n        // `fromOptimisticTransaction` is not available through the `cache.diff`\n        // code path, so we need to check it this way\n        equal(diff.result, this.getCacheDiff({ optimistic: false }).result)\n      ) {\n        //If this diff did not come from an optimistic transaction\n        // make the ObservableQuery \"reobserve\" the latest data\n        // using a temporary fetch policy of \"cache-first\", so complete cache\n        // results have a chance to be delivered without triggering additional\n        // network requests, even when options.fetchPolicy is \"network-only\"\n        // or \"cache-and-network\". All other fetch policies are preserved by\n        // this method, and are handled by calling oq.reobserve(). If this\n        // reobservation is spurious, distinctUntilChanged still has a\n        // chance to catch it before delivery to ObservableQuery subscribers.\n        this.reobserveCacheFirst();\n      } else {\n        // If this diff came from an optimistic transaction, deliver the\n        // current cache data to the ObservableQuery, but don't perform a\n        // reobservation, since oq.reobserveCacheFirst might make a network\n        // request, and we never want to trigger network requests in the\n        // middle of optimistic updates.\n        this.input.next({\n          kind: \"N\",\n          value: {\n            data: diff.result,\n            dataState:\n              diff.complete ? \"complete\"\n              : diff.result ? \"partial\"\n              : \"empty\",\n            networkStatus: NetworkStatus.ready,\n            loading: false,\n            error: undefined,\n            partial: !diff.complete,\n          } as ObservableQuery.Result<TData>,\n          source: \"cache\",\n          query: this.query,\n          variables: this.variables,\n          meta: {},\n        });\n      }\n    }\n  }\n\n  private activeOperations = new Set<TrackedOperation>();\n  private pushOperation(networkStatus: NetworkStatus): {\n    finalize: () => void;\n    pushNotification: (\n      notification: QueryNotification.Value<TData>,\n      additionalMeta?: Omit<Meta, \"query\" | \"variables\">\n    ) => void;\n  } {\n    let aborted = false;\n    // track query and variables from the start of the operation\n    const { query, variables } = this;\n    const finalize = () => {\n      this.activeOperations.delete(operation);\n    };\n    const operation: TrackedOperation = {\n      override: networkStatus,\n      abort: () => {\n        aborted = true;\n        finalize();\n      },\n      query,\n      variables,\n    };\n    this.activeOperations.add(operation);\n    return {\n      finalize,\n      pushNotification: (\n        notification: QueryNotification.Value<TData>,\n        additionalMeta?: Meta\n      ) => {\n        if (!aborted) {\n          this.input.next({\n            ...notification,\n            query,\n            variables,\n            meta: { ...additionalMeta },\n          });\n        }\n      },\n    };\n  }\n\n  private calculateNetworkStatus(baseNetworkStatus: NetworkStatus) {\n    if (baseNetworkStatus === NetworkStatus.streaming) {\n      return baseNetworkStatus;\n    }\n    // in the future, this could be more complex logic, e.g. \"refetch\" and\n    // \"fetchMore\" having priority over \"polling\" or \"loading\" network statuses\n    // as for now we just take the \"latest\" operation that is still active,\n    // as that lines up best with previous behavior[]\n\n    const operation = Array.from(this.activeOperations.values())\n      .reverse()\n      .find(\n        (operation) =>\n          isEqualQuery(operation, this) && operation.override !== undefined\n      );\n    return operation?.override ?? baseNetworkStatus;\n  }\n\n  private abortActiveOperations() {\n    this.activeOperations.forEach((operation) => operation.abort());\n  }\n\n  /**\n   * @internal\n   * Called from `clearStore`.\n   *\n   * - resets the query to its initial state\n   * - cancels all active operations and their subscriptions\n   */\n  public reset() {\n    // exception for cache-only queries - we reset them into a \"ready\" state\n    // as we won't trigger a refetch for them\n    const resetToEmpty = this.options.fetchPolicy === \"cache-only\";\n    this.setResult(resetToEmpty ? empty : uninitialized, {\n      shouldEmit: resetToEmpty ? EmitBehavior.force : EmitBehavior.never,\n    });\n\n    this.abortActiveOperations();\n  }\n\n  /** @internal */\n  private setResult(\n    result: ObservableQuery.Result<TData>,\n    additionalMeta?: Meta\n  ) {\n    this.input.next({\n      source: \"setResult\",\n      kind: \"N\",\n      value: result,\n      query: this.query,\n      variables: this.variables,\n      meta: { ...additionalMeta },\n    });\n  }\n\n  private operator: OperatorFunction<\n    QueryNotification.Value<TData> & {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      meta: Meta;\n    },\n    SubjectValue<TData, TVariables>\n  > = filterMap((notification) => {\n    const { query, variables, meta } = notification;\n\n    if (notification.source === \"setResult\") {\n      return { query, variables, result: notification.value, meta };\n    }\n\n    if (notification.kind === \"C\" || !isEqualQuery(notification, this)) {\n      return;\n    }\n\n    let result: ObservableQuery.Result<TData>;\n    const previous = this.subject.getValue();\n\n    if (notification.source === \"cache\") {\n      result = notification.value;\n      if (\n        result.networkStatus === NetworkStatus.ready &&\n        result.partial &&\n        (!this.options.returnPartialData ||\n          previous.result.networkStatus === NetworkStatus.error) &&\n        this.options.fetchPolicy !== \"cache-only\"\n      ) {\n        return;\n      }\n    } else if (notification.source === \"network\") {\n      if (this.waitForNetworkResult) {\n        this.waitForNetworkResult = false;\n        this.resubscribeCache();\n      }\n      result =\n        notification.kind === \"E\" ?\n          ({\n            ...(isEqualQuery(previous, notification) ?\n              previous.result\n            : { data: undefined, dataState: \"empty\", partial: true }),\n            error: notification.error,\n            networkStatus: NetworkStatus.error,\n            loading: false,\n          } as ObservableQuery.Result<TData>)\n        : notification.value;\n\n      if (notification.kind === \"E\" && result.dataState === \"streaming\") {\n        result.dataState = \"complete\" as any;\n      }\n\n      if (result.error) {\n        meta.shouldEmit = EmitBehavior.force;\n      }\n    } else if (notification.source === \"newNetworkStatus\") {\n      const baseResult =\n        isEqualQuery(previous, notification) ?\n          previous.result\n        : this.getInitialResult(meta.fetchPolicy);\n      const { resetError } = notification.value;\n      const error = resetError ? undefined : baseResult.error;\n      const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;\n      result = {\n        ...baseResult,\n        error,\n        networkStatus,\n      };\n    }\n    // every code path until here should have either returned or set a result,\n    // but typescript needs a little help\n    invariant(result!);\n\n    // normalize result shape\n    if (!result.error) delete result.error;\n    result.networkStatus = this.calculateNetworkStatus(result.networkStatus);\n    result.loading = isNetworkRequestInFlight(result.networkStatus);\n    result = this.maskResult(result);\n\n    return { query, variables, result, meta };\n  });\n\n  // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n  // delivery of any new data from the cache, possibly falling back to the network\n  // if any cache data are missing. This allows _complete_ cache results to be\n  // delivered without also kicking off unnecessary network requests when\n  // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n  // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n  // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n  private reobserveCacheFirst(): void {\n    const { fetchPolicy, nextFetchPolicy } = this.options;\n\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n      this.reobserve({\n        fetchPolicy: \"cache-first\",\n        // Use a temporary nextFetchPolicy function that replaces itself with the\n        // previous nextFetchPolicy value and returns the original fetchPolicy.\n        nextFetchPolicy(\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) {\n          // Replace this nextFetchPolicy function in the options object with the\n          // original this.options.nextFetchPolicy value.\n          this.nextFetchPolicy = nextFetchPolicy;\n          // If the original nextFetchPolicy value was a function, give it a\n          // chance to decide what happens here.\n          if (typeof this.nextFetchPolicy === \"function\") {\n            return this.nextFetchPolicy(currentFetchPolicy, context);\n          }\n          // Otherwise go back to the original this.options.fetchPolicy.\n          return fetchPolicy!;\n        },\n      });\n    } else {\n      this.reobserve();\n    }\n  }\n\n  private getVariablesWithDefaults(variables: TVariables | undefined) {\n    return this.queryManager.getVariables(this.query, variables);\n  }\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError | MissingTree | undefined\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: %o`, missing);\n  }\n}\n\nfunction isEqualQuery(\n  a?: { query: DocumentNode; variables: OperationVariables },\n  b?: { query: DocumentNode; variables: OperationVariables }\n) {\n  return !!(a && b && a.query === b.query && equal(a.variables, b.variables));\n}\n\nfunction getTrackingOperatorPromise<TData>(\n  defaultValue?: ObservableQuery.Result<TData>\n) {\n  let lastValue = defaultValue,\n    resolve: (value: ObservableQuery.Result<TData>) => void,\n    reject: (error: unknown) => void;\n  const promise = new Promise<ObservableQuery.Result<TData>>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const operator: MonoTypeOperatorFunction<QueryNotification.Value<TData>> =\n    tap({\n      next(value) {\n        if (value.kind === \"E\") {\n          return reject(value.error);\n        }\n\n        if (\n          value.kind === \"N\" &&\n          value.source !== \"newNetworkStatus\" &&\n          !value.value.loading\n        ) {\n          lastValue = value.value;\n        }\n      },\n      finalize: () => {\n        if (lastValue) {\n          resolve(lastValue);\n        } else {\n          const message = \"The operation was aborted.\";\n          const name = \"AbortError\";\n          reject(\n            typeof DOMException !== \"undefined\" ?\n              new DOMException(message, name)\n              // some environments do not have `DOMException`, e.g. node\n              // uses a normal `Error` with a `name` property instead: https://github.com/phryneas/node/blob/d0579b64f0f6b722f8e49bf8a471dd0d0604a21e/lib/internal/errors.js#L964\n              // error.code is a legacy property that is not used anymore,\n              // and also inconsistent across environments (in supporting\n              // browsers it is `20`, in node `'ABORT_ERR'`) so we omit that.\n            : Object.assign(new Error(message), { name })\n          );\n        }\n      },\n    });\n  return { promise, operator };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}