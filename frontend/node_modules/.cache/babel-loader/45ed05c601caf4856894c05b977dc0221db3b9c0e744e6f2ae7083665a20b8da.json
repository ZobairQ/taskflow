{"ast":null,"code":"import { canonicalStringify } from \"./canonicalStringify.js\";\nconst KNOWN_DIRECTIVES = [\"connection\", \"include\", \"skip\", \"client\", \"rest\", \"export\", \"nonreactive\", \"stream\"];\n// Default stable JSON.stringify implementation used by getStoreKeyName. Can be\n// updated/replaced with something better by calling\n// getStoreKeyName.setStringify(newStringifyFunction).\nlet storeKeyNameStringify = canonicalStringify;\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport const getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n  if (args && directives && directives[\"connection\"] && directives[\"connection\"][\"key\"]) {\n    if (directives[\"connection\"][\"filter\"] && directives[\"connection\"][\"filter\"].length > 0) {\n      const filterKeys = directives[\"connection\"][\"filter\"] ? directives[\"connection\"][\"filter\"] : [];\n      filterKeys.sort();\n      const filteredArgs = {};\n      filterKeys.forEach(key => {\n        filteredArgs[key] = args[key];\n      });\n      const stringifiedArgs = storeKeyNameStringify(filteredArgs);\n      if (stringifiedArgs !== \"{}\") {\n        return \"\".concat(directives[\"connection\"][\"key\"], \"(\").concat(stringifiedArgs, \")\");\n      }\n    }\n    return directives[\"connection\"][\"key\"];\n  }\n  let completeFieldName = fieldName;\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs = storeKeyNameStringify(args);\n    if (stringifiedArgs !== \"{}\") {\n      completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n    }\n  }\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += \"@\".concat(key, \"(\").concat(storeKeyNameStringify(directives[key]), \")\");\n      } else {\n        completeFieldName += \"@\".concat(key);\n      }\n    });\n  }\n  return completeFieldName;\n}, {\n  setStringify(s) {\n    const previous = storeKeyNameStringify;\n    storeKeyNameStringify = s;\n    return previous;\n  }\n});","map":{"version":3,"names":["canonicalStringify","KNOWN_DIRECTIVES","storeKeyNameStringify","getStoreKeyName","Object","assign","fieldName","args","directives","length","filterKeys","sort","filteredArgs","forEach","key","stringifiedArgs","concat","completeFieldName","keys","indexOf","setStringify","s","previous"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/utilities/internal/getStoreKeyName.ts"],"sourcesContent":["import { canonicalStringify } from \"./canonicalStringify.js\";\n\ntype Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  \"connection\",\n  \"include\",\n  \"skip\",\n  \"client\",\n  \"rest\",\n  \"export\",\n  \"nonreactive\",\n  \"stream\",\n];\n\n// Default stable JSON.stringify implementation used by getStoreKeyName. Can be\n// updated/replaced with something better by calling\n// getStoreKeyName.setStringify(newStringifyFunction).\nlet storeKeyNameStringify: (value: any) => string = canonicalStringify;\n\n/** @internal */\nexport const getStoreKeyName = Object.assign(\n  function (\n    fieldName: string,\n    args?: Record<string, any> | null,\n    directives?: Directives\n  ): string {\n    if (\n      args &&\n      directives &&\n      directives[\"connection\"] &&\n      directives[\"connection\"][\"key\"]\n    ) {\n      if (\n        directives[\"connection\"][\"filter\"] &&\n        (directives[\"connection\"][\"filter\"] as string[]).length > 0\n      ) {\n        const filterKeys =\n          directives[\"connection\"][\"filter\"] ?\n            (directives[\"connection\"][\"filter\"] as string[])\n          : [];\n        filterKeys.sort();\n\n        const filteredArgs = {} as { [key: string]: any };\n        filterKeys.forEach((key) => {\n          filteredArgs[key] = args[key];\n        });\n\n        const stringifiedArgs: string = storeKeyNameStringify(filteredArgs);\n        if (stringifiedArgs !== \"{}\") {\n          return `${directives[\"connection\"][\"key\"]}(${stringifiedArgs})`;\n        }\n      }\n      return directives[\"connection\"][\"key\"];\n    }\n\n    let completeFieldName: string = fieldName;\n\n    if (args) {\n      // We can't use `JSON.stringify` here since it's non-deterministic,\n      // and can lead to different store key names being created even though\n      // the `args` object used during creation has the same properties/values.\n      const stringifiedArgs: string = storeKeyNameStringify(args);\n      if (stringifiedArgs !== \"{}\") {\n        completeFieldName += `(${stringifiedArgs})`;\n      }\n    }\n\n    if (directives) {\n      Object.keys(directives).forEach((key) => {\n        if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n        if (directives[key] && Object.keys(directives[key]).length) {\n          completeFieldName += `@${key}(${storeKeyNameStringify(\n            directives[key]\n          )})`;\n        } else {\n          completeFieldName += `@${key}`;\n        }\n      });\n    }\n\n    return completeFieldName;\n  },\n  {\n    setStringify(s: typeof storeKeyNameStringify) {\n      const previous = storeKeyNameStringify;\n      storeKeyNameStringify = s;\n      return previous;\n    },\n  }\n);\n"],"mappings":"AAAA,SAASA,kBAAT,QAAmC,yBAAyB;AAQ5D,MAAMC,gBAAN,GAAmC,CACjC,YAAY,EACZ,SAAS,EACT,MAAM,EACN,QAAQ,EACR,MAAM,EACN,QAAQ,EACR,aAAa,EACb,QAAQ,CACT;AAED;AACA;AACA;AACA,IAAIC,qBAAJ,GAAoDF,kBAAkB;;;;;;AAGtE,OAAO,MAAMG,eAAb,GAA+BC,MAAM,CAACC,MAAM,CAC1C,UACEC,SAAiB,EACjBC,IAAiC,EACjCC,UAAuB,EAJ3B;EAMI,IACED,IADN,IAEMC,UAAN,IACMA,UAAU,CAAC,YAAY,KACvBA,UAAU,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,EAC/B;IACA,IACEA,UAAU,CAAC,YAAY,CAAC,CAAC,QAAQ,KAChCA,UAAU,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAc,CAACC,MAAzD,GAAkE,CAAC,EAC3D;MACA,MAAMC,UAAd,GACUF,UAAU,CAAC,YAAY,CAAC,CAAC,QAAQ,IAC9BA,UAAU,CAAC,YAAY,CAAC,CAAC,QAAQ,IAClC,EAAE;MACNE,UAAU,CAACC,IAAI,CAAvB,CAAyB;MAEjB,MAAMC,YAAd,GAA6B,CAA7B,CAAyD;MACjDF,UAAU,CAACG,OAAO,CAAEC,GAAG,IAA/B;QACUF,YAAY,CAACE,GAAG,IAAIP,IAAI,CAACO,GAAG,CAAC;MAC/B,CAAC,CAAC;MAEF,MAAMC,eAAd,GAAwCb,qBAAqB,CAACU,YAAY,CAAC;MACnE,IAAIG,eAAZ,KAAgC,IAAI,EAAE;QAC5B,UAAAC,MAAA,CAAUR,UAAU,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,OAAAQ,MAAA,CAAID,eAAe;MAC9D;IACF;IACA,OAAOP,UAAU,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC;EACxC;EAEA,IAAIS,iBAAR,GAAoCX,SAAS;EAEzC,IAAIC,IAAI,EAAE;IACR;IACA;IACA;IACA,MAAMQ,eAAZ,GAAsCb,qBAAqB,CAACK,IAAI,CAAC;IAC3D,IAAIQ,eAAV,KAA8B,IAAI,EAAE;MAC5BE,iBAAR,QAAAD,MAAA,CAAiCD,eAAe,MAAG;IAC7C;EACF;EAEA,IAAIP,UAAU,EAAE;IACdJ,MAAM,CAACc,IAAI,CAACV,UAAU,CAAC,CAACK,OAAO,CAAEC,GAAG,IAA1C;MACQ,IAAIb,gBAAgB,CAACkB,OAAO,CAACL,GAAG,MAAM,CAAC,CAAC,EAAE;MAC1C,IAAIN,UAAU,CAACM,GAAG,KAAKV,MAAM,CAACc,IAAI,CAACV,UAAU,CAACM,GAAG,CAAC,CAAC,CAACL,MAAM,EAAE;QAC1DQ,iBAAV,QAAAD,MAAA,CAAmCF,GAAG,OAAAE,MAAA,CAAId,qBAAqB,CACnDM,UAAU,CAACM,GAAG,CAAC,CAChB,MAAG;MACN,OAAO;QACLG,iBAAV,QAAAD,MAAA,CAAmCF,GAAG,CAAE;MAChC;IACF,CAAC,CAAC;EACJ;EAEA,OAAOG,iBAAiB;AAC1B,CAAC,EACD;EACEG,YAAYA,CAACC,CAA+B,EAAhD;IACM,MAAMC,QAAZ,GAAuBpB,qBAAqB;IACtCA,qBAAN,GAA8BmB,CAAC;IACzB,OAAOC,QAAQ;EACjB;AACJ,CAAG,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}