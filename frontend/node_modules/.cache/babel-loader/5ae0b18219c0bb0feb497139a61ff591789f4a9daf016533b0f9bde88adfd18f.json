{"ast":null,"code":"import * as React from \"react\";\nimport { canonicalStringify } from \"@apollo/client/utilities\";\nimport { skipToken } from \"../constants.js\";\nexport function useSuspenseHookCacheKey(query, options) {\n  const {\n    queryKey = [],\n    variables\n  } = options;\n  const canonicalVariables = canonicalStringify(variables);\n  // This state value let's us maintain the variables used for the cache key\n  // when `skipToken` is used to skip a query after its been executed.\n  // Since options aren't provided when using `skipToken`, `variables` would\n  // otherwise disappear which means we'd return a new cache key without a\n  // variables value which creates a new `ObservableQuery` instance. This was\n  // particularly problematic when `refetchQueries` was used because it meant\n  // refetching against an `ObservableQuery` instance that had no variables.\n  let [cacheKeyVariables, setCacheKeyVariables] = React.useState(canonicalVariables);\n  if (options !== skipToken && cacheKeyVariables !== canonicalVariables) {\n    setCacheKeyVariables(cacheKeyVariables = canonicalVariables);\n  }\n  return [query, cacheKeyVariables, ...[].concat(queryKey)];\n}","map":{"version":3,"names":["React","canonicalStringify","skipToken","useSuspenseHookCacheKey","query","options","queryKey","variables","canonicalVariables","cacheKeyVariables","setCacheKeyVariables","useState","concat"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/react/hooks/internal/useSuspenseHookCacheKey.ts"],"sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type { OperationVariables } from \"@apollo/client\";\nimport type { CacheKey } from \"@apollo/client/react/internal\";\nimport { canonicalStringify } from \"@apollo/client/utilities\";\n\nimport type { SkipToken } from \"../constants.js\";\nimport { skipToken } from \"../constants.js\";\n\nexport declare namespace useSuspenseHookCacheKey {\n  export interface Options {\n    variables?: OperationVariables;\n    queryKey?: string | number | any[];\n  }\n}\n\nexport function useSuspenseHookCacheKey(\n  query: DocumentNode,\n  options:\n    | (SkipToken & Partial<useSuspenseHookCacheKey.Options>)\n    | useSuspenseHookCacheKey.Options\n) {\n  const { queryKey = [], variables } = options;\n  const canonicalVariables = canonicalStringify(variables);\n\n  // This state value let's us maintain the variables used for the cache key\n  // when `skipToken` is used to skip a query after its been executed.\n  // Since options aren't provided when using `skipToken`, `variables` would\n  // otherwise disappear which means we'd return a new cache key without a\n  // variables value which creates a new `ObservableQuery` instance. This was\n  // particularly problematic when `refetchQueries` was used because it meant\n  // refetching against an `ObservableQuery` instance that had no variables.\n  let [cacheKeyVariables, setCacheKeyVariables] =\n    React.useState(canonicalVariables);\n\n  if (options !== skipToken && cacheKeyVariables !== canonicalVariables) {\n    setCacheKeyVariables((cacheKeyVariables = canonicalVariables));\n  }\n\n  return [\n    query,\n    cacheKeyVariables,\n    ...([] as any[]).concat(queryKey),\n  ] satisfies CacheKey;\n}\n"],"mappings":"AACA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAI9B,SAASC,kBAAkB,QAAQ,0BAA0B;AAG7D,SAASC,SAAS,QAAQ,iBAAiB;AAS3C,OAAM,SAAUC,uBAAuBA,CACrCC,KAAmB,EACnBC,OAEmC;EAEnC,MAAM;IAAEC,QAAQ,GAAG,EAAE;IAAEC;EAAS,CAAE,GAAGF,OAAO;EAC5C,MAAMG,kBAAkB,GAAGP,kBAAkB,CAACM,SAAS,CAAC;EAExD;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,CAACE,iBAAiB,EAAEC,oBAAoB,CAAC,GAC3CV,KAAK,CAACW,QAAQ,CAACH,kBAAkB,CAAC;EAEpC,IAAIH,OAAO,KAAKH,SAAS,IAAIO,iBAAiB,KAAKD,kBAAkB,EAAE;IACrEE,oBAAoB,CAAED,iBAAiB,GAAGD,kBAAmB,CAAC;EAChE;EAEA,OAAO,CACLJ,KAAK,EACLK,iBAAiB,EACjB,GAAI,EAAY,CAACG,MAAM,CAACN,QAAQ,CAAC,CACf;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}