{"ast":null,"code":"import { EMPTY, Observable } from \"rxjs\";\n/**\n * Like `combineLatest` but with some differences:\n *\n * - It only works on arrays as an input\n * - Batches updates to each array index that contains a referentially equal\n *   observable\n * - Doesn't allow for custom scheduler\n * - Expects array of constructed observables instead of `Array<ObservableInput>`\n */\nexport function combineLatestBatched(observables) {\n  if (observables.length === 0) {\n    return EMPTY;\n  }\n  return new Observable(observer => {\n    const {\n      length\n    } = observables;\n    // Keeps track of current values for each observable\n    const values = new Array(length);\n    // Used to batch an update each item in the array that share an observable\n    // so that they can be emitted together.\n    const indexesByObservable = new Map();\n    observables.forEach((source, idx) => {\n      if (!indexesByObservable.has(source)) {\n        indexesByObservable.set(source, new Set());\n      }\n      indexesByObservable.get(source).add(idx);\n    });\n    // Track the number of active subscriptions so we know when to complete this\n    // observable\n    let active = indexesByObservable.size;\n    // Track how many observables are left to emit their first value\n    let remainingFirstValues = indexesByObservable.size;\n    let currentBatch;\n    // Subscribe to each unique observable instead of the raw source array of\n    // observables since we want at most 1-subscription per unique observable.\n    // This ensures an update can write to multiple indexes before emitting the\n    // result.\n    indexesByObservable.forEach((indexes, source) => {\n      let hasFirstValue = false;\n      const subscription = source.subscribe({\n        next: value => {\n          indexes.forEach(idx => values[idx] = value);\n          if (!hasFirstValue) {\n            hasFirstValue = true;\n            remainingFirstValues--;\n          }\n          if (!remainingFirstValues) {\n            currentBatch || (currentBatch = new Set(observables.filter(obs => obs.dirty)));\n            currentBatch.delete(source);\n            if (!currentBatch.size) {\n              observer.next(values.slice());\n              currentBatch = undefined;\n            }\n          }\n        },\n        complete: () => {\n          active--;\n          if (!active) {\n            observer.complete();\n          }\n        },\n        error: observer.error.bind(observer)\n      });\n      observer.add(subscription);\n    });\n  });\n}","map":{"version":3,"names":["EMPTY","Observable","combineLatestBatched","observables","length","observer","values","Array","indexesByObservable","Map","forEach","source","idx","has","set","Set","get","add","active","size","remainingFirstValues","currentBatch","indexes","hasFirstValue","subscription","subscribe","next","value","filter","obs","dirty","delete","slice","undefined","complete","error","bind"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/utilities/internal/combineLatestBatched.ts"],"sourcesContent":["import { EMPTY, Observable } from \"rxjs\";\n\n/**\n * Like `combineLatest` but with some differences:\n *\n * - It only works on arrays as an input\n * - Batches updates to each array index that contains a referentially equal\n *   observable\n * - Doesn't allow for custom scheduler\n * - Expects array of constructed observables instead of `Array<ObservableInput>`\n */\nexport function combineLatestBatched<T>(\n  observables: Array<Observable<T> & { dirty?: boolean }>\n) {\n  if (observables.length === 0) {\n    return EMPTY;\n  }\n\n  return new Observable<Array<T>>((observer) => {\n    const { length } = observables;\n    // Keeps track of current values for each observable\n    const values: T[] = new Array(length);\n    // Used to batch an update each item in the array that share an observable\n    // so that they can be emitted together.\n    const indexesByObservable = new Map<Observable<T>, Set<number>>();\n\n    observables.forEach((source, idx) => {\n      if (!indexesByObservable.has(source)) {\n        indexesByObservable.set(source, new Set());\n      }\n\n      indexesByObservable.get(source)!.add(idx);\n    });\n\n    // Track the number of active subscriptions so we know when to complete this\n    // observable\n    let active = indexesByObservable.size;\n    // Track how many observables are left to emit their first value\n    let remainingFirstValues = indexesByObservable.size;\n\n    let currentBatch: Set<Observable<T>> | undefined;\n\n    // Subscribe to each unique observable instead of the raw source array of\n    // observables since we want at most 1-subscription per unique observable.\n    // This ensures an update can write to multiple indexes before emitting the\n    // result.\n    indexesByObservable.forEach((indexes, source) => {\n      let hasFirstValue = false;\n      const subscription = source.subscribe({\n        next: (value) => {\n          indexes.forEach((idx) => (values[idx] = value));\n\n          if (!hasFirstValue) {\n            hasFirstValue = true;\n            remainingFirstValues--;\n          }\n\n          if (!remainingFirstValues) {\n            currentBatch ||= new Set(observables.filter((obs) => obs.dirty));\n            currentBatch.delete(source);\n            if (!currentBatch.size) {\n              observer.next(values.slice());\n              currentBatch = undefined;\n            }\n          }\n        },\n        complete: () => {\n          active--;\n\n          if (!active) {\n            observer.complete();\n          }\n        },\n        error: observer.error.bind(observer),\n      });\n\n      observer.add(subscription);\n    });\n  });\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,UAAU,QAAQ,MAAM;AAExC;;;;;;;;;AASA,OAAM,SAAUC,oBAAoBA,CAClCC,WAAuD;EAEvD,IAAIA,WAAW,CAACC,MAAM,KAAK,CAAC,EAAE;IAC5B,OAAOJ,KAAK;EACd;EAEA,OAAO,IAAIC,UAAU,CAAYI,QAAQ,IAAI;IAC3C,MAAM;MAAED;IAAM,CAAE,GAAGD,WAAW;IAC9B;IACA,MAAMG,MAAM,GAAQ,IAAIC,KAAK,CAACH,MAAM,CAAC;IACrC;IACA;IACA,MAAMI,mBAAmB,GAAG,IAAIC,GAAG,EAA8B;IAEjEN,WAAW,CAACO,OAAO,CAAC,CAACC,MAAM,EAAEC,GAAG,KAAI;MAClC,IAAI,CAACJ,mBAAmB,CAACK,GAAG,CAACF,MAAM,CAAC,EAAE;QACpCH,mBAAmB,CAACM,GAAG,CAACH,MAAM,EAAE,IAAII,GAAG,EAAE,CAAC;MAC5C;MAEAP,mBAAmB,CAACQ,GAAG,CAACL,MAAM,CAAE,CAACM,GAAG,CAACL,GAAG,CAAC;IAC3C,CAAC,CAAC;IAEF;IACA;IACA,IAAIM,MAAM,GAAGV,mBAAmB,CAACW,IAAI;IACrC;IACA,IAAIC,oBAAoB,GAAGZ,mBAAmB,CAACW,IAAI;IAEnD,IAAIE,YAA4C;IAEhD;IACA;IACA;IACA;IACAb,mBAAmB,CAACE,OAAO,CAAC,CAACY,OAAO,EAAEX,MAAM,KAAI;MAC9C,IAAIY,aAAa,GAAG,KAAK;MACzB,MAAMC,YAAY,GAAGb,MAAM,CAACc,SAAS,CAAC;QACpCC,IAAI,EAAGC,KAAK,IAAI;UACdL,OAAO,CAACZ,OAAO,CAAEE,GAAG,IAAMN,MAAM,CAACM,GAAG,CAAC,GAAGe,KAAM,CAAC;UAE/C,IAAI,CAACJ,aAAa,EAAE;YAClBA,aAAa,GAAG,IAAI;YACpBH,oBAAoB,EAAE;UACxB;UAEA,IAAI,CAACA,oBAAoB,EAAE;YACzBC,YAAY,KAAZA,YAAY,GAAK,IAAIN,GAAG,CAACZ,WAAW,CAACyB,MAAM,CAAEC,GAAG,IAAKA,GAAG,CAACC,KAAK,CAAC,CAAC;YAChET,YAAY,CAACU,MAAM,CAACpB,MAAM,CAAC;YAC3B,IAAI,CAACU,YAAY,CAACF,IAAI,EAAE;cACtBd,QAAQ,CAACqB,IAAI,CAACpB,MAAM,CAAC0B,KAAK,EAAE,CAAC;cAC7BX,YAAY,GAAGY,SAAS;YAC1B;UACF;QACF,CAAC;QACDC,QAAQ,EAAEA,CAAA,KAAK;UACbhB,MAAM,EAAE;UAER,IAAI,CAACA,MAAM,EAAE;YACXb,QAAQ,CAAC6B,QAAQ,EAAE;UACrB;QACF,CAAC;QACDC,KAAK,EAAE9B,QAAQ,CAAC8B,KAAK,CAACC,IAAI,CAAC/B,QAAQ;OACpC,CAAC;MAEFA,QAAQ,CAACY,GAAG,CAACO,YAAY,CAAC;IAC5B,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}