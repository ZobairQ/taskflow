{"ast":null,"code":"import _objectWithoutProperties from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"];\nimport { __rest } from \"tslib\";\nimport { mergeDeep } from \"@apollo/client/utilities/internal\";\n/**\n * A basic pagination field policy that always concatenates new\n * results onto the existing array, without examining options.args.\n *\n * @param keyArgs - `keyArgs` that should be applied to the field policy\n * @returns The field policy that handles concatenating field results.\n */\nexport function concatPagination() {\n  let keyArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    keyArgs,\n    merge(existing, incoming) {\n      return existing ? [...existing, ...incoming] : incoming;\n    }\n  };\n}\n/**\n * A basic field policy that uses `options.args.{offset,limit}` to splice\n * the incoming data into the existing array. If your arguments are called\n * something different (like `args.{start,count}`), feel free to copy/paste\n * this implementation and make the appropriate changes.\n *\n * @param keyArgs - `keyArgs` that should be applied to the field policy\n * @returns The field policy that handles offset/limit pagination\n */\nexport function offsetLimitPagination() {\n  let keyArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    keyArgs,\n    merge(existing, incoming, _ref) {\n      let {\n        args\n      } = _ref;\n      const merged = existing ? existing.slice(0) : [];\n      if (incoming) {\n        if (args) {\n          // Assume an offset of 0 if args.offset omitted.\n          const {\n            offset = 0\n          } = args;\n          for (let i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          // It's unusual (probably a mistake) for a paginated field not\n          // to receive any arguments, so you might prefer to throw an\n          // exception here, instead of recovering by appending incoming\n          // onto the existing array.\n          merged.push(...incoming);\n        }\n      }\n      return merged;\n    }\n  };\n}\n// As proof of the flexibility of field policies, this function generates\n// one that handles Relay-style pagination, without Apollo Client knowing\n// anything about connections, edges, cursors, or pageInfo objects.\n/**\n * A field policy that attempts to handle pagination for fields that adhere to\n * the [Relay Connections Spec](https://relay.dev/graphql/connections.htm).\n *\n * @param keyArgs - `keyArgs` that should be applied to the field policy\n * @returns The field policy that handles Relay pagination\n */\nexport function relayStylePagination() {\n  let keyArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    keyArgs,\n    read(existing, _ref2) {\n      let {\n        canRead,\n        readField\n      } = _ref2;\n      if (!existing) return existing;\n      const edges = [];\n      let firstEdgeCursor = \"\";\n      let lastEdgeCursor = \"\";\n      existing.edges.forEach(edge => {\n        // Edges themselves could be Reference objects, so it's important\n        // to use readField to access the edge.edge.node property.\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n      if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {\n        firstEdgeCursor = \"\";\n      }\n      const {\n        startCursor,\n        endCursor\n      } = existing.pageInfo || {};\n      return _objectSpread(_objectSpread({}, getExtras(existing)), {}, {\n        edges,\n        pageInfo: _objectSpread(_objectSpread({}, existing.pageInfo), {}, {\n          // If existing.pageInfo.{start,end}Cursor are undefined or \"\", default\n          // to firstEdgeCursor and/or lastEdgeCursor.\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor\n        })\n      });\n    },\n    merge(existing, incoming, _ref3) {\n      let {\n        args,\n        isReference,\n        readField\n      } = _ref3;\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n      if (!incoming) {\n        return existing;\n      }\n      const incomingEdges = incoming.edges ? incoming.edges.map(edge => {\n        if (isReference(edge = _objectSpread({}, edge))) {\n          // In case edge is a Reference, we read out its cursor field and\n          // store it as an extra property of the Reference object.\n          edge.cursor = readField(\"cursor\", edge);\n        }\n        return edge;\n      }) : [];\n      if (incoming.pageInfo) {\n        const {\n          pageInfo\n        } = incoming;\n        const {\n          startCursor,\n          endCursor\n        } = pageInfo;\n        const firstEdge = incomingEdges[0];\n        const lastEdge = incomingEdges[incomingEdges.length - 1];\n        // In case we did not request the cursor field for edges in this\n        // query, we can still infer cursors from pageInfo.\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n        // Cursors can also come from edges, so we default\n        // pageInfo.{start,end}Cursor to {first,last}Edge.cursor.\n        const firstCursor = firstEdge && firstEdge.cursor;\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor\n            }\n          });\n        }\n        const lastCursor = lastEdge && lastEdge.cursor;\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor\n            }\n          });\n        }\n      }\n      let prefix = existing.edges;\n      let suffix = [];\n      if (args && args.after) {\n        // This comparison does not need to use readField(\"cursor\", edge),\n        // because we stored the cursor field of any Reference edges as an\n        // extra property of the Reference object.\n        const index = prefix.findIndex(edge => edge.cursor === args.after);\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n          // suffix = []; // already true\n        }\n      } else if (args && args.before) {\n        const index = prefix.findIndex(edge => edge.cursor === args.before);\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        // If we have neither args.after nor args.before, the incoming\n        // edges cannot be spliced into the existing edges, so they must\n        // replace the existing edges. See #6592 for a motivating example.\n        prefix = [];\n      }\n      const edges = [...prefix, ...incomingEdges, ...suffix];\n      const pageInfo = _objectSpread(_objectSpread({}, incoming.pageInfo), existing.pageInfo);\n      if (incoming.pageInfo) {\n        const _incoming$pageInfo = incoming.pageInfo,\n          {\n            hasPreviousPage,\n            hasNextPage,\n            startCursor,\n            endCursor\n          } = _incoming$pageInfo,\n          extras = _objectWithoutProperties(_incoming$pageInfo, _excluded);\n        // If incoming.pageInfo had any extra non-standard properties,\n        // assume they should take precedence over any existing properties\n        // of the same name, regardless of where this page falls with\n        // respect to the existing data.\n        Object.assign(pageInfo, extras);\n        // Keep existing.pageInfo.has{Previous,Next}Page unless the\n        // placement of the incoming edges means incoming.hasPreviousPage\n        // or incoming.hasNextPage should become the new values for those\n        // properties in existing.pageInfo. Note that these updates are\n        // only permitted when the beginning or end of the incoming page\n        // coincides with the beginning or end of the existing data, as\n        // determined using prefix.length and suffix.length.\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n      return _objectSpread(_objectSpread(_objectSpread({}, getExtras(existing)), getExtras(incoming)), {}, {\n        edges,\n        pageInfo\n      });\n    }\n  };\n}\n// Returns any unrecognized properties of the given object.\nconst getExtras = obj => __rest(obj, notExtras);\nconst notExtras = [\"edges\", \"pageInfo\"];\nfunction makeEmptyData() {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\"\n    }\n  };\n}","map":{"version":3,"names":["__rest","mergeDeep","concatPagination","keyArgs","arguments","length","undefined","merge","existing","incoming","offsetLimitPagination","_ref","args","merged","slice","offset","i","push","relayStylePagination","read","_ref2","canRead","readField","edges","firstEdgeCursor","lastEdgeCursor","forEach","edge","cursor","startCursor","endCursor","pageInfo","_objectSpread","getExtras","_ref3","isReference","makeEmptyData","incomingEdges","map","firstEdge","lastEdge","firstCursor","lastCursor","prefix","suffix","after","index","findIndex","before","_incoming$pageInfo","hasPreviousPage","hasNextPage","extras","_objectWithoutProperties","_excluded","Object","assign","obj","notExtras"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/utilities/policies/pagination.ts"],"sourcesContent":["import { __rest } from \"tslib\";\n\nimport type { FieldPolicy, Reference } from \"@apollo/client/cache\";\nimport { mergeDeep } from \"@apollo/client/utilities/internal\";\n\ntype KeyArgs = FieldPolicy<any>[\"keyArgs\"];\n\n/**\n * A basic pagination field policy that always concatenates new\n * results onto the existing array, without examining options.args.\n *\n * @param keyArgs - `keyArgs` that should be applied to the field policy\n * @returns The field policy that handles concatenating field results.\n */\nexport function concatPagination<T = Reference>(\n  keyArgs: KeyArgs = false\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming) {\n      return existing ? [...existing, ...incoming] : incoming;\n    },\n  };\n}\n\n/**\n * A basic field policy that uses `options.args.{offset,limit}` to splice\n * the incoming data into the existing array. If your arguments are called\n * something different (like `args.{start,count}`), feel free to copy/paste\n * this implementation and make the appropriate changes.\n *\n * @param keyArgs - `keyArgs` that should be applied to the field policy\n * @returns The field policy that handles offset/limit pagination\n */\nexport function offsetLimitPagination<T = Reference>(\n  keyArgs: KeyArgs = false\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming, { args }) {\n      const merged = existing ? existing.slice(0) : [];\n\n      if (incoming) {\n        if (args) {\n          // Assume an offset of 0 if args.offset omitted.\n          const { offset = 0 } = args;\n          for (let i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          // It's unusual (probably a mistake) for a paginated field not\n          // to receive any arguments, so you might prefer to throw an\n          // exception here, instead of recovering by appending incoming\n          // onto the existing array.\n          merged.push(...incoming);\n        }\n      }\n\n      return merged;\n    },\n  };\n}\n\n// Whether TRelayEdge<TNode> is a normalized Reference or a non-normalized\n// object, it needs a .cursor property where the relayStylePagination\n// merge function can store cursor strings taken from pageInfo. Storing an\n// extra reference.cursor property should be safe, and is easier than\n// attempting to update the cursor field of the normalized StoreObject\n// that the reference refers to, or managing edge wrapper objects\n// (something I attempted in #7023, but abandoned because of #7088).\ntype TRelayEdge<TNode> =\n  | {\n      cursor?: string;\n      node: TNode;\n    }\n  | (Reference & { cursor?: string });\n\nexport type TRelayPageInfo = {\n  hasPreviousPage: boolean;\n  hasNextPage: boolean;\n  startCursor: string;\n  endCursor: string;\n};\n\ntype TExistingRelay<TNode> = Readonly<{\n  edges: TRelayEdge<TNode>[];\n  pageInfo: TRelayPageInfo;\n}>;\n\ntype TIncomingRelay<TNode> = {\n  edges?: TRelayEdge<TNode>[];\n  pageInfo?: TRelayPageInfo;\n};\n\ntype RelayFieldPolicy<TNode> = FieldPolicy<\n  TExistingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null\n>;\n\n// As proof of the flexibility of field policies, this function generates\n// one that handles Relay-style pagination, without Apollo Client knowing\n// anything about connections, edges, cursors, or pageInfo objects.\n/**\n * A field policy that attempts to handle pagination for fields that adhere to\n * the [Relay Connections Spec](https://relay.dev/graphql/connections.htm).\n *\n * @param keyArgs - `keyArgs` that should be applied to the field policy\n * @returns The field policy that handles Relay pagination\n */\nexport function relayStylePagination<TNode extends Reference = Reference>(\n  keyArgs: KeyArgs = false\n): RelayFieldPolicy<TNode> {\n  return {\n    keyArgs,\n\n    read(existing, { canRead, readField }) {\n      if (!existing) return existing;\n\n      const edges: TRelayEdge<TNode>[] = [];\n      let firstEdgeCursor = \"\";\n      let lastEdgeCursor = \"\";\n      existing.edges.forEach((edge) => {\n        // Edges themselves could be Reference objects, so it's important\n        // to use readField to access the edge.edge.node property.\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n\n      if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {\n        firstEdgeCursor = \"\";\n      }\n\n      const { startCursor, endCursor } = existing.pageInfo || {};\n\n      return {\n        // Some implementations return additional Connection fields, such\n        // as existing.totalCount. These fields are saved by the merge\n        // function, so the read function should also preserve them.\n        ...getExtras(existing),\n        edges,\n        pageInfo: {\n          ...existing.pageInfo,\n          // If existing.pageInfo.{start,end}Cursor are undefined or \"\", default\n          // to firstEdgeCursor and/or lastEdgeCursor.\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor,\n        },\n      };\n    },\n\n    merge(existing, incoming, { args, isReference, readField }) {\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n\n      if (!incoming) {\n        return existing;\n      }\n\n      const incomingEdges =\n        incoming.edges ?\n          incoming.edges.map((edge) => {\n            if (isReference((edge = { ...edge }))) {\n              // In case edge is a Reference, we read out its cursor field and\n              // store it as an extra property of the Reference object.\n              edge.cursor = readField<string>(\"cursor\", edge);\n            }\n            return edge;\n          })\n        : [];\n\n      if (incoming.pageInfo) {\n        const { pageInfo } = incoming;\n        const { startCursor, endCursor } = pageInfo;\n        const firstEdge = incomingEdges[0];\n        const lastEdge = incomingEdges[incomingEdges.length - 1];\n        // In case we did not request the cursor field for edges in this\n        // query, we can still infer cursors from pageInfo.\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n        // Cursors can also come from edges, so we default\n        // pageInfo.{start,end}Cursor to {first,last}Edge.cursor.\n        const firstCursor = firstEdge && firstEdge.cursor;\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor,\n            },\n          });\n        }\n        const lastCursor = lastEdge && lastEdge.cursor;\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor,\n            },\n          });\n        }\n      }\n\n      let prefix = existing.edges;\n      let suffix: typeof prefix = [];\n\n      if (args && args.after) {\n        // This comparison does not need to use readField(\"cursor\", edge),\n        // because we stored the cursor field of any Reference edges as an\n        // extra property of the Reference object.\n        const index = prefix.findIndex((edge) => edge.cursor === args.after);\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n          // suffix = []; // already true\n        }\n      } else if (args && args.before) {\n        const index = prefix.findIndex((edge) => edge.cursor === args.before);\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        // If we have neither args.after nor args.before, the incoming\n        // edges cannot be spliced into the existing edges, so they must\n        // replace the existing edges. See #6592 for a motivating example.\n        prefix = [];\n      }\n\n      const edges = [...prefix, ...incomingEdges, ...suffix];\n\n      const pageInfo: TRelayPageInfo = {\n        // The ordering of these two ...spreads may be surprising, but it\n        // makes sense because we want to combine PageInfo properties with a\n        // preference for existing values, *unless* the existing values are\n        // overridden by the logic below, which is permitted only when the\n        // incoming page falls at the beginning or end of the data.\n        ...incoming.pageInfo,\n        ...existing.pageInfo,\n      };\n\n      if (incoming.pageInfo) {\n        const {\n          hasPreviousPage,\n          hasNextPage,\n          startCursor,\n          endCursor,\n          ...extras\n        } = incoming.pageInfo;\n\n        // If incoming.pageInfo had any extra non-standard properties,\n        // assume they should take precedence over any existing properties\n        // of the same name, regardless of where this page falls with\n        // respect to the existing data.\n        Object.assign(pageInfo, extras);\n\n        // Keep existing.pageInfo.has{Previous,Next}Page unless the\n        // placement of the incoming edges means incoming.hasPreviousPage\n        // or incoming.hasNextPage should become the new values for those\n        // properties in existing.pageInfo. Note that these updates are\n        // only permitted when the beginning or end of the incoming page\n        // coincides with the beginning or end of the existing data, as\n        // determined using prefix.length and suffix.length.\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage)\n            pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return {\n        ...getExtras(existing),\n        ...getExtras(incoming),\n        edges,\n        pageInfo,\n      };\n    },\n  };\n}\n\n// Returns any unrecognized properties of the given object.\nconst getExtras = (obj: Record<string, any>) => __rest(obj, notExtras);\nconst notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData(): TExistingRelay<any> {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\",\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}