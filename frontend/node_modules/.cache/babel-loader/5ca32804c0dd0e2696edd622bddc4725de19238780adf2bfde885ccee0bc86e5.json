{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { addTypenameToDocument, cacheSizes, canonicalStringify, isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { DeepMerger, getDefaultValues, getFragmentFromSelection, getMainDefinition, getQueryDefinition, isArray, isField, isNonNullObject, makeReference, maybeDeepFreeze, mergeDeepArray, resultKeyNameFromField, shouldInclude } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError } from \"@apollo/client/utilities/invariant\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { extractFragmentContext, getTypenameFromStoreObject } from \"./helpers.js\";\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context];\n}\nexport class StoreReader {\n  constructor(config) {\n    // cached version of executeSelectionSet\n    _defineProperty(this, \"executeSelectionSet\", void 0);\n    // cached version of executeSubSelectedArray\n    _defineProperty(this, \"executeSubSelectedArray\", void 0);\n    _defineProperty(this, \"config\", void 0);\n    _defineProperty(this, \"knownResults\", new WeakMap());\n    this.config = config;\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(options => {\n      const peekArgs = execSelectionSetKeyArgs(options);\n      const other = this.executeSelectionSet.peek(...peekArgs);\n      if (other) {\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return this.execSelectionSetImpl(options);\n    }, {\n      max: cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey(selectionSet, parent, context) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(options => {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return this.execSubSelectedArrayImpl(options);\n    }, {\n      max: cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n      makeCacheKey(_ref) {\n        let {\n          field,\n          array,\n          context\n        } = _ref;\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  diffQueryAgainstStore(_ref2) {\n    let {\n      store,\n      query,\n      rootId = \"ROOT_QUERY\",\n      variables,\n      returnPartialData = true\n    } = _ref2;\n    const policies = this.config.cache.policies;\n    variables = _objectSpread(_objectSpread({}, getDefaultValues(getQueryDefinition(query))), variables);\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: _objectSpread({\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables)\n      }, extractFragmentContext(query, this.config.fragments))\n    });\n    let missing;\n    if (execResult.missing) {\n      missing = new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables);\n    }\n    const complete = !missing;\n    const {\n      result\n    } = execResult;\n    return {\n      result: complete ? result : returnPartialData ? Object.keys(result).length === 0 ? null : result : null,\n      complete,\n      missing\n    };\n  }\n  isFresh(result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      const latest = this.executeSelectionSet.peek(selectionSet, parent, context);\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n  // Uncached version of executeSelectionSet.\n  execSelectionSetImpl(_ref3) {\n    let {\n      selectionSet,\n      objectOrReference,\n      enclosingRef,\n      context\n    } = _ref3;\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: {},\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n    const {\n      variables,\n      policies,\n      store\n    } = context;\n    const typename = store.getFieldValue(objectOrReference, \"__typename\");\n    const objectsToMerge = [];\n    let missing;\n    const missingMerger = new DeepMerger();\n    if (typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one. Note that this field can be overridden by other\n      // merged objects.\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n    function handleMissing(result, resultName) {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing\n        });\n      }\n      return result.result;\n    }\n    const workSet = new Set(selectionSet.selections);\n    workSet.forEach(selection => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n      if (isField(selection)) {\n        let fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        const resultName = resultKeyNameFromField(selection);\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2))\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef,\n              context\n            }), resultName);\n          }\n        } else if (!selection.selectionSet) {\n          // do nothing\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context\n          }), resultName);\n        }\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({\n            [resultName]: fieldValue\n          });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(selection, context.lookupFragment);\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(107, selection.name.value);\n        }\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult = {\n      result,\n      missing\n    };\n    const frozen = maybeDeepFreeze(finalResult);\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n    return frozen;\n  }\n  // Uncached version of executeSubSelectedArray.\n  execSubSelectedArrayImpl(_ref4) {\n    let {\n      field,\n      array,\n      enclosingRef,\n      context\n    } = _ref4;\n    let missing;\n    let missingMerger = new DeepMerger();\n    function handleMissing(childResult, i) {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, {\n          [i]: childResult.missing\n        });\n      }\n      return childResult.result;\n    }\n    if (field.selectionSet) {\n      array = array.filter(item => item === undefined || context.store.canRead(item));\n    }\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          enclosingRef,\n          context\n        }), i);\n      }\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context\n        }), i);\n      }\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n      return item;\n    });\n    return {\n      result: array,\n      missing\n    };\n  }\n}\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach(value => {\n      if (isNonNullObject(value)) {\n        invariant(!isReference(value), 108, getTypenameFromStoreObject(store, value), field.name.value);\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}","map":{"version":3,"names":["Kind","wrap","addTypenameToDocument","cacheSizes","canonicalStringify","isReference","__DEV__","DeepMerger","getDefaultValues","getFragmentFromSelection","getMainDefinition","getQueryDefinition","isArray","isField","isNonNullObject","makeReference","maybeDeepFreeze","mergeDeepArray","resultKeyNameFromField","shouldInclude","invariant","newInvariantError","MissingFieldError","maybeDependOnExistenceOfEntity","supportsResultCaching","extractFragmentContext","getTypenameFromStoreObject","execSelectionSetKeyArgs","options","selectionSet","objectOrReference","context","StoreReader","constructor","config","_defineProperty","WeakMap","executeSelectionSet","peekArgs","other","peek","store","enclosingRef","__ref","execSelectionSetImpl","max","keyArgs","makeCacheKey","parent","varString","executeSubSelectedArray","execSubSelectedArrayImpl","_ref","field","array","diffQueryAgainstStore","_ref2","query","rootId","variables","returnPartialData","policies","cache","_objectSpread","rootRef","execResult","fragments","missing","firstMissing","complete","result","Object","keys","length","isFresh","knownResults","get","latest","_ref3","rootTypenamesById","has","concat","typename","getFieldValue","objectsToMerge","missingMerger","rootIdsByTypename","push","__typename","handleMissing","resultName","merge","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","added","JSON","stringify","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","add","finalResult","frozen","set","_ref4","childResult","i","filter","item","undefined","canRead","map","assertSelectionSetForIdValue","tree","_","values"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/cache/inmemory/readFromStore.ts"],"sourcesContent":["import type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type { Reference, StoreObject } from \"@apollo/client/utilities\";\nimport {\n  addTypenameToDocument,\n  cacheSizes,\n  canonicalStringify,\n  isReference,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  DeepMerger,\n  getDefaultValues,\n  getFragmentFromSelection,\n  getMainDefinition,\n  getQueryDefinition,\n  isArray,\n  isField,\n  isNonNullObject,\n  makeReference,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\n\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n} from \"./helpers.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { Policies } from \"./policies.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\ntype ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ninterface StoreReaderConfig {\n  cache: InMemoryCache;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [options.selectionSet, options.objectOrReference, options.context];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new WeakMap<Record<string, any>, SelectionSetNode>();\n\n  constructor(config: StoreReaderConfig) {\n    this.config = config;\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError | undefined;\n    if (execResult.missing) {\n      missing = new MissingFieldError(\n        firstMissing(execResult.missing)!,\n        execResult.missing,\n        query,\n        variables\n      );\n    }\n\n    const complete = !missing;\n    const { result } = execResult;\n\n    return {\n      result:\n        complete ? result\n        : returnPartialData ?\n          Object.keys(result).length === 0 ?\n            null\n          : result\n        : null,\n      complete,\n      missing,\n    } as Cache.DiffResult<T>;\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: {},\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one. Note that this field can be overridden by other\n      // merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(\n              this.executeSubSelectedArray({\n                field: selection,\n                array: fieldValue,\n                enclosingRef,\n                context,\n              }),\n              resultName\n            );\n          }\n        } else if (!selection.selectionSet) {\n          // do nothing\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen = maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(\n        (item) => item === undefined || context.store.canRead(item)\n      );\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}