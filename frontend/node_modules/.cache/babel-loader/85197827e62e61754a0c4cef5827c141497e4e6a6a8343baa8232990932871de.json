{"ast":null,"code":"import _toPropertyKey from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\";\nimport _objectWithoutProperties from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"queryType\", \"mutationType\", \"subscriptionType\"],\n  _excluded2 = [\"fields\"];\nimport { equal } from \"@wry/equality\";\nimport { disableWarningsSlot } from \"@apollo/client/masking\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { streamInfoSymbol } from \"@apollo/client/utilities/internal\";\nimport { argumentsObjectFromField, getStoreKeyName, isArray, isNonNullObject, storeKeyNameFromField, stringifyForDisplay } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError } from \"@apollo/client/utilities/invariant\";\nimport { defaultDataIdFromObject, fieldNameFromStoreName, hasOwn, selectionSetMatchesResult, storeValueIsStoreObject, TypeOrFieldNameRegExp } from \"./helpers.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nconst nullKeyFieldsFn = () => void 0;\nconst simpleKeyArgsFn = (_args, context) => context.fieldName;\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn = (existing, incoming, _ref) => {\n  let {\n    mergeObjects\n  } = _ref;\n  return mergeObjects(existing, incoming);\n};\nconst mergeFalseFn = (_, incoming) => incoming;\nexport const defaultStreamFieldMergeFn = (existing, incoming, _ref2) => {\n  let {\n    streamFieldInfo,\n    existingData\n  } = _ref2;\n  if (!existing && !existingData) {\n    return incoming;\n  }\n  const results = [];\n  const previous = existing !== null && existing !== void 0 ? existing : existingData;\n  const length = streamFieldInfo !== null && streamFieldInfo !== void 0 && streamFieldInfo.isLastChunk ? incoming.length : Math.max(previous.length, incoming.length);\n  for (let i = 0; i < length; i++) {\n    results[i] = incoming[i] === undefined ? previous[i] : incoming[i];\n  }\n  return results;\n};\nexport class Policies {\n  constructor(config) {\n    _defineProperty(this, \"config\", void 0);\n    _defineProperty(this, \"typePolicies\", {});\n    _defineProperty(this, \"toBeAdded\", {});\n    // Map from subtype names to sets of supertype names. Note that this\n    // representation inverts the structure of possibleTypes (whose keys are\n    // supertypes and whose values are arrays of subtypes) because it tends\n    // to be much more efficient to search upwards than downwards.\n    _defineProperty(this, \"supertypeMap\", new Map());\n    // Any fuzzy subtypes specified by possibleTypes will be converted to\n    // RegExp objects and recorded here. Every key of this map can also be\n    // found in supertypeMap. In many cases this Map will be empty, which\n    // means no fuzzy subtype checking will happen in fragmentMatches.\n    _defineProperty(this, \"fuzzySubtypes\", new Map());\n    _defineProperty(this, \"cache\", void 0);\n    _defineProperty(this, \"rootIdsByTypename\", {});\n    _defineProperty(this, \"rootTypenamesById\", {});\n    _defineProperty(this, \"usingPossibleTypes\", false);\n    this.config = config;\n    this.config = _objectSpread({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n  identify(object, partialContext) {\n    var _partialContext$store;\n    const policies = this;\n    const typename = partialContext && (partialContext.typename || ((_partialContext$store = partialContext.storeObject) === null || _partialContext$store === void 0 ? void 0 : _partialContext$store.__typename)) || object.__typename;\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject = partialContext && partialContext.storeObject || object;\n    const context = _objectSpread(_objectSpread({}, partialContext), {}, {\n      typename,\n      storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const options = normalizeReadFieldOptions(args, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n    let id;\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn(_objectSpread(_objectSpread({}, object), storeObject), context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n  addTypePolicies(typePolicies) {\n    Object.keys(typePolicies).forEach(typename => {\n      const _typePolicies$typenam = typePolicies[typename],\n        {\n          queryType,\n          mutationType,\n          subscriptionType\n        } = _typePolicies$typenam,\n        incoming = _objectWithoutProperties(_typePolicies$typenam, _excluded);\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n  updateTypePolicy(typename, incoming, existingFieldPolicies) {\n    const existing = this.getTypePolicy(typename);\n    const {\n      keyFields,\n      fields\n    } = incoming;\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge\n      // Pass merge:true as a shorthand for a merge implementation\n      // that returns options.mergeObjects(existing, incoming).\n      : merge === true ? mergeTrueFn\n      // Pass merge:false to make incoming always replace existing\n      // without any warnings about data clobbering.\n      : merge === false ? mergeFalseFn : existing.merge;\n    }\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n    existing.keyFn =\n    // Pass false to disable normalization for this typename.\n    keyFields === false ? nullKeyFieldsFn\n    // Pass an array of strings to use those fields to compute a\n    // composite ID for objects of this typename.\n    : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n    // Pass a function to take full control over identification.\n    : typeof keyFields === \"function\" ? keyFields\n    // Leave existing.keyFn unchanged if above cases fail.\n    : existing.keyFn;\n    if (fields) {\n      Object.keys(fields).forEach(fieldName => {\n        var _existing;\n        let existing = existingFieldPolicies[fieldName];\n        // Field policy inheritance is atomic/shallow: you can't inherit a\n        // field policy and then override just its read function, since read\n        // and merge functions often need to cooperate, so changing only one\n        // of them would be a recipe for inconsistency.\n        // So here we avoid merging an inherited field policy with an updated one.\n        if (!existing || ((_existing = existing) === null || _existing === void 0 ? void 0 : _existing.typename) !== typename) {\n          existing = existingFieldPolicies[fieldName] = {\n            typename\n          };\n        }\n        const incoming = fields[fieldName];\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const {\n            keyArgs,\n            read,\n            merge\n          } = incoming;\n          existing.keyFn =\n          // Pass false to disable argument-based differentiation of\n          // field identities.\n          keyArgs === false ? simpleKeyArgsFn\n          // Pass an array of strings to use named arguments to\n          // compute a composite identity for the field.\n          : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n          // Pass a function to take full control over field identity.\n          : typeof keyArgs === \"function\" ? keyArgs\n          // Leave existing.keyFn unchanged if above cases fail.\n          : existing.keyFn;\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n          setMerge(existing, merge);\n        }\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n  setRootTypename(which) {\n    let typename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : which;\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, 103, which);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n  addPossibleTypes(possibleTypes) {\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(supertype => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n      possibleTypes[supertype].forEach(subtype => {\n        this.getSupertypeSet(subtype, true).add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n  getTypePolicy(typename) {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy = this.typePolicies[typename] = {};\n      policy.fields = {};\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true);\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach(supertype => supertypes.add(supertype));\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(supertype => {\n          const _this$getTypePolicy = this.getTypePolicy(supertype),\n            {\n              fields\n            } = _this$getTypePolicy,\n            rest = _objectWithoutProperties(_this$getTypePolicy, _excluded2);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(policy => {\n        this.updateTypePolicy(typename, policy, this.typePolicies[typename].fields);\n      });\n    }\n    return this.typePolicies[typename];\n  }\n  getFieldPolicy(typename, fieldName) {\n    if (typename) {\n      return this.getTypePolicy(typename).fields[fieldName];\n    }\n  }\n  getSupertypeSet(subtype, createIfMissing) {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n    return supertypeSet;\n  }\n  fragmentMatches(fragment, typename, result, variables) {\n    if (!fragment.typeCondition) return true;\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = subtype => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (supertypeSet && supertypeSet.size && workQueue.indexOf(supertypeSet) < 0) {\n          workQueue.push(supertypeSet);\n        }\n      };\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              __DEV__ && invariant.warn(104, typename, supertype);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n        supertypeSet.forEach(maybeEnqueue);\n        if (needToCheckFuzzySubtypes &&\n        // Start checking fuzzy subtypes only after exhausting all\n        // non-fuzzy subtypes (after the final iteration of the loop).\n        i === workQueue.length - 1 &&\n        // We could wait to compare fragment.selectionSet to result\n        // after we verify the supertype, but this check is often less\n        // expensive than that search, and we will have to do the\n        // comparison anyway whenever we find a potential match.\n        selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n    return false;\n  }\n  hasKeyArgs(typename, fieldName) {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return !!(policy && policy.keyFn);\n  }\n  getStoreFieldName(fieldSpec) {\n    const {\n      typename,\n      fieldName\n    } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName);\n    let storeFieldName;\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  }\n  readField(options, context) {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    const policy = this.getFieldPolicy(options.typename, fieldName);\n    const read = policy && policy.read;\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n    return existing;\n  }\n  getReadFunction(typename, fieldName) {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return policy && policy.read;\n  }\n  getMergeFunction(parentTypename, fieldName, childTypename) {\n    let policy = this.getFieldPolicy(parentTypename, fieldName);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n  runMergeFunction(existing, incoming, _ref3, context, storage) {\n    var _context$extensions;\n    let {\n      field,\n      typename,\n      merge,\n      path\n    } = _ref3;\n    // Preserve the value in case `context.overwrite` is set.\n    const existingData = existing;\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n    const streamInfo = (_context$extensions = context.extensions) === null || _context$extensions === void 0 || (_context$extensions = _context$extensions[streamInfoSymbol]) === null || _context$extensions === void 0 || (_context$extensions = _context$extensions.deref()) === null || _context$extensions === void 0 ? void 0 : _context$extensions.peekArray(path);\n    if (streamInfo) {\n      const {\n        current,\n        previous\n      } = streamInfo;\n      if (previous && equal(previous.incoming, incoming) && equal(previous.streamFieldInfo, current)) {\n        return previous.result;\n      }\n    }\n    const result = merge(existing, incoming, makeMergeFieldFunctionOptions(this,\n    // Unlike options.readField for read functions, we do not fall\n    // back to the current object if no foreignObjOrRef is provided,\n    // because it's not clear what the current object should be for\n    // merge functions: the (possibly undefined) existing object, or\n    // the incoming object? If you think your merge function needs\n    // to read sibling fields in order to produce a new value for\n    // the current field, you might want to rethink your strategy,\n    // because that's a recipe for making merge behavior sensitive\n    // to the order in which fields are written into the cache.\n    // However, readField(name, ref) is useful for merge functions\n    // that need to deduplicate child objects and references.\n    void 0, {\n      typename,\n      fieldName: field.name.value,\n      field,\n      variables: context.variables,\n      path\n    }, context, storage || {}, existingData));\n    if (streamInfo) {\n      streamInfo.previous = {\n        incoming,\n        streamFieldInfo: streamInfo.current,\n        result\n      };\n    }\n    return result;\n  }\n}\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const {\n    toReference,\n    canRead\n  } = context.store;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return policies.readField(normalizeReadFieldOptions(args, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\nfunction makeMergeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage, existingData) {\n  const options = _objectSpread(_objectSpread({}, makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage)), {}, {\n    extensions: context.extensions,\n    existingData\n  });\n  const extensions = context.extensions;\n  if (extensions && streamInfoSymbol in extensions) {\n    var _streamInfo$deref;\n    const {\n        [streamInfoSymbol]: streamInfo\n      } = extensions,\n      otherExtensions = _objectWithoutProperties(extensions, [streamInfoSymbol].map(_toPropertyKey));\n    const streamFieldInfo = streamInfo === null || streamInfo === void 0 || (_streamInfo$deref = streamInfo.deref()) === null || _streamInfo$deref === void 0 ? void 0 : _streamInfo$deref.peekArray(fieldSpec.path);\n    if (streamFieldInfo) {\n      options.streamFieldInfo = streamFieldInfo.current;\n    }\n    // If the only key in `extensions` was the stream details key, we didn't\n    // receive any remote extensions, so we reset extensions back to undefined\n    options.extensions = Object.keys(otherExtensions).length === 0 ? undefined : otherExtensions;\n  }\n  return options;\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  const {\n    0: fieldNameOrOptions,\n    1: from,\n    length: argc\n  } = readFieldArgs;\n  let options;\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = _objectSpread({}, fieldNameOrOptions);\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n  if (__DEV__ && options.from === void 0) {\n    __DEV__ && invariant.warn(105, stringifyForDisplay(Array.from(readFieldArgs)));\n  }\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n  return options;\n}\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(106);\n    }\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n      if (typesDiffer) {\n        return incoming;\n      }\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return _objectSpread(_objectSpread({}, existing), incoming);\n      }\n    }\n    return incoming;\n  };\n}","map":{"version":3,"names":["equal","disableWarningsSlot","isReference","__DEV__","streamInfoSymbol","argumentsObjectFromField","getStoreKeyName","isArray","isNonNullObject","storeKeyNameFromField","stringifyForDisplay","invariant","newInvariantError","defaultDataIdFromObject","fieldNameFromStoreName","hasOwn","selectionSetMatchesResult","storeValueIsStoreObject","TypeOrFieldNameRegExp","keyArgsFnFromSpecifier","keyFieldsFnFromSpecifier","cacheSlot","argsFromFieldSpecifier","spec","args","field","variables","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","fieldName","mergeTrueFn","existing","incoming","_ref","mergeObjects","mergeFalseFn","_","defaultStreamFieldMergeFn","_ref2","streamFieldInfo","existingData","results","previous","length","isLastChunk","Math","max","i","undefined","Policies","constructor","config","_defineProperty","Map","_objectSpread","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","typePolicies","addTypePolicies","identify","object","partialContext","_partialContext$store","policies","typename","storeObject","__typename","rootTypenamesById","ROOT_QUERY","readField","_len","arguments","Array","_key","options","normalizeReadFieldOptions","store","id","policy","getTypePolicy","keyFn","withValue","specifierOrId","String","keyObject","Object","keys","forEach","_typePolicies$typenam","queryType","mutationType","subscriptionType","_objectWithoutProperties","_excluded","call","toBeAdded","push","updateTypePolicy","existingFieldPolicies","keyFields","fields","setMerge","merge","_existing","read","keyArgs","which","rootId","toUpperCase","old","rootIdsByTypename","usingPossibleTypes","supertype","getSupertypeSet","subtype","add","match","fuzzySubtypes","set","RegExp","supertypes","supertypeMap","get","size","regExp","fuzzy","test","fuzzySupertypes","_this$getTypePolicy","rest","_excluded2","assign","inbox","splice","getFieldPolicy","createIfMissing","supertypeSet","Set","fragmentMatches","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue","maybeEnqueue","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","warn","selectionSet","fuzzyString","hasKeyArgs","getStoreFieldName","fieldSpec","storeFieldName","specifierOrString","objectOrReference","from","nameOrField","getFieldValue","readOptions","makeFieldFunctionOptions","getStorage","__ref","getReadFunction","getMergeFunction","parentTypename","childTypename","runMergeFunction","_ref3","storage","_context$extensions","path","makeMergeObjectsFunction","overwrite","streamInfo","extensions","deref","peekArray","current","makeMergeFieldFunctionOptions","toReference","canRead","_len2","_key2","_streamInfo$deref","otherExtensions","map","_toPropertyKey","readFieldArgs","fieldNameOrOptions","argc","eType","iType","typesDiffer"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/cache/inmemory/policies.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { OperationVariables } from \"@apollo/client\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport { disableWarningsSlot } from \"@apollo/client/masking\";\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { FragmentMap } from \"@apollo/client/utilities/internal\";\nimport { streamInfoSymbol } from \"@apollo/client/utilities/internal\";\nimport {\n  argumentsObjectFromField,\n  getStoreKeyName,\n  isArray,\n  isNonNullObject,\n  storeKeyNameFromField,\n  stringifyForDisplay,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport type {\n  CanReadFunction,\n  FieldSpecifier,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  SafeReadonly,\n  ToReferenceFunction,\n} from \"../core/types/common.js\";\n\nimport {\n  defaultDataIdFromObject,\n  fieldNameFromStoreName,\n  hasOwn,\n  selectionSetMatchesResult,\n  storeValueIsStoreObject,\n  TypeOrFieldNameRegExp,\n} from \"./helpers.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldReadFunctionOptions definition to be overwritten by the\n  // developer\n  TReadOptions extends FieldReadFunctionOptions = FieldReadFunctionOptions,\n  // Allows FieldMergeFunctionOptions definition to be overwritten by the\n  // developer\n  TMergeOptions extends FieldMergeFunctionOptions = FieldMergeFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TReadOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TMergeOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return (\n    spec.args !== void 0 ? spec.args\n    : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n    : null\n  );\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVariables extends OperationVariables = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVariables;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\nexport interface FieldReadFunctionOptions<\n  TArgs = Record<string, any>,\n  TVariables extends OperationVariables = Record<string, any>,\n> extends FieldFunctionOptions<TArgs, TVariables> {}\n\nexport interface FieldMergeFunctionOptions<\n  TArgs = Record<string, any>,\n  TVariables extends OperationVariables = Record<string, any>,\n> extends FieldFunctionOptions<TArgs, TVariables> {\n  /**\n   * Any `extensions` provided when writing the cache.\n   */\n  extensions: Record<string, unknown> | undefined;\n\n  /**\n   * Details about the field when the `@stream` directive is used. Useful with\n   * custom merge functions to determine how to merge existing cache data with\n   * the incoming stream array.\n   *\n   * This field is only available in `merge` functions when the `@stream`\n   * directive is used on the field.\n   *\n   * > [!NOTE]\n   * > This field is not available when using the `Defer20220824Handler`\n   */\n  streamFieldInfo?: Incremental.StreamFieldInfo;\n\n  /**\n   * The same value as the `existing` argument, but preserves the `existing`\n   * value on refetches when `refetchWritePolicy` is `overwrite` (the default).\n   */\n  existingData: unknown;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldReadFunctionOptions = FieldReadFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldMergeFunctionOptions = FieldMergeFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport const defaultStreamFieldMergeFn: FieldMergeFunction<Array<any>> = (\n  existing,\n  incoming,\n  { streamFieldInfo, existingData }\n) => {\n  if (!existing && !existingData) {\n    return incoming;\n  }\n\n  const results = [];\n  const previous = existing ?? (existingData as any[]);\n  const length =\n    streamFieldInfo?.isLastChunk ?\n      incoming.length\n    : Math.max(previous.length, incoming.length);\n\n  for (let i = 0; i < length; i++) {\n    results[i] = incoming[i] === undefined ? previous[i] : incoming[i];\n  }\n\n  return results;\n};\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\ntype InternalFieldPolicy = {\n  typename: string;\n  keyFn?: KeyArgsFunction;\n  read?: FieldReadFunction<any>;\n  merge?: FieldMergeFunction<any>;\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: InternalFieldPolicy;\n      };\n    };\n  } = {};\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = {};\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = {};\n  public readonly rootTypenamesById: Record<string, string> = {};\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        (((...args) => {\n          const options = normalizeReadFieldOptions(args, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        }) satisfies ReadFieldFunction),\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(\n    typename: string,\n    incoming: TypePolicy,\n    existingFieldPolicies: Record<string, InternalFieldPolicy>\n  ) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge\n          // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n        : merge === true ? mergeTrueFn\n          // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n        : merge === false ? mergeFalseFn\n        : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n      : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n        // Pass a function to take full control over identification.\n      : typeof keyFields === \"function\" ? keyFields\n        // Leave existing.keyFn unchanged if above cases fail.\n      : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        let existing = existingFieldPolicies[fieldName] as\n          | InternalFieldPolicy\n          | undefined;\n        // Field policy inheritance is atomic/shallow: you can't inherit a\n        // field policy and then override just its read function, since read\n        // and merge functions often need to cooperate, so changing only one\n        // of them would be a recipe for inconsistency.\n        // So here we avoid merging an inherited field policy with an updated one.\n        if (!existing || existing?.typename !== typename) {\n          existing = existingFieldPolicies[fieldName] = { typename };\n        }\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n              // Pass a function to take full control over field identity.\n            : typeof keyArgs === \"function\" ? keyArgs\n              // Leave existing.keyFn unchanged if above cases fail.\n            : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = {} as any);\n      policy.fields = {};\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(\n          typename,\n          policy,\n          this.typePolicies[typename].fields\n        );\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string\n  ): InternalFieldPolicy | undefined {\n    if (typename) {\n      return this.getTypePolicy(typename).fields[fieldName];\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName =\n        fieldSpec.field ?\n          storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference) ?\n            objectOrReference.__ref\n          : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge, path }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    // Preserve the value in case `context.overwrite` is set.\n    const existingData = existing;\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    const streamInfo = context.extensions?.[streamInfoSymbol]\n      ?.deref()\n      ?.peekArray(path);\n\n    if (streamInfo) {\n      const { current, previous } = streamInfo;\n\n      if (\n        previous &&\n        equal(previous.incoming, incoming) &&\n        equal(previous.streamFieldInfo, current)\n      ) {\n        return previous.result;\n      }\n    }\n\n    const result = merge(\n      existing,\n      incoming,\n      makeMergeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n          path,\n        },\n        context,\n        storage || {},\n        existingData\n      )\n    );\n\n    if (streamInfo) {\n      streamInfo.previous = {\n        incoming,\n        streamFieldInfo: streamInfo.current,\n        result,\n      };\n    }\n\n    return result;\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>(...args: any[]) {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(args, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nfunction makeMergeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier & { path: Array<string | number> },\n  context: ReadMergeModifyContext,\n  storage: StorageType,\n  existingData?: unknown\n): FieldMergeFunctionOptions {\n  const options: FieldMergeFunctionOptions = {\n    ...makeFieldFunctionOptions(\n      policies,\n      objectOrReference,\n      fieldSpec,\n      context,\n      storage\n    ),\n    extensions: context.extensions,\n    existingData,\n  };\n\n  const extensions = context.extensions;\n\n  if (extensions && streamInfoSymbol in extensions) {\n    const { [streamInfoSymbol]: streamInfo, ...otherExtensions } = extensions;\n\n    const streamFieldInfo = streamInfo?.deref()?.peekArray(fieldSpec.path);\n    if (streamFieldInfo) {\n      options.streamFieldInfo = streamFieldInfo.current;\n    }\n\n    // If the only key in `extensions` was the stream details key, we didn't\n    // receive any remote extensions, so we reset extensions back to undefined\n    options.extensions =\n      Object.keys(otherExtensions).length === 0 ? undefined : otherExtensions;\n  }\n\n  return options;\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: any[],\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}