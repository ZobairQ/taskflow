{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { OperationTypeNode } from \"graphql\";\nimport { map } from \"rxjs\";\nimport { NotImplementedHandler } from \"@apollo/client/incremental\";\nimport { execute } from \"@apollo/client/link\";\nimport { DocumentTransform } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { checkDocument, compact, getApolloClientMemoryInternals, mapObservableFragmentMemoized, mergeOptions, removeMaskedFragmentSpreads } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { version } from \"../version.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nlet hasSuggestedDevtools = false;\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient {\n  set prioritizeCacheValues(value) {\n    this.queryManager.prioritizeCacheValues = value;\n  }\n  /**\n   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after SSR.\n   */\n  get prioritizeCacheValues() {\n    return this.queryManager.prioritizeCacheValues;\n  }\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   *\n   * ```js\n   * import { ApolloClient, InMemoryCache, HttpLink } from \"@apollo/client\";\n   *\n   * const cache = new InMemoryCache();\n   * const link = new HttpLink({ uri: \"http://localhost:4000/\" });\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   link: link,\n   *\n   *   // Provide some optional constructor fields\n   *   clientAwareness: {\n   *     name: \"react-web-client\",\n   *     version: \"1.3\",\n   *   },\n   *   queryDeduplication: false,\n   * });\n   * ```\n   */\n  constructor(options) {\n    var _devtools$enabled;\n    _defineProperty(this, \"link\", void 0);\n    _defineProperty(this, \"cache\", void 0);\n    /**\n     * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`.\n     */\n    _defineProperty(this, \"disableNetworkFetches\", void 0);\n    _defineProperty(this, \"version\", void 0);\n    _defineProperty(this, \"queryDeduplication\", void 0);\n    _defineProperty(this, \"defaultOptions\", void 0);\n    _defineProperty(this, \"devtoolsConfig\", void 0);\n    _defineProperty(this, \"queryManager\", void 0);\n    _defineProperty(this, \"devToolsHookCb\", void 0);\n    _defineProperty(this, \"resetStoreCallbacks\", []);\n    _defineProperty(this, \"clearStoreCallbacks\", []);\n    /**\n     * Refetches all of your active queries.\n     *\n     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n     *\n     * It is important to remember that `reFetchObservableQueries()` _will_ refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n     *\n     * Note: `cache-only` queries are not refetched by this function.\n     *\n     * @deprecated Please use `refetchObservableQueries` instead.\n     */\n    _defineProperty(this, \"reFetchObservableQueries\", void 0);\n    _defineProperty(this, \"maskedFragmentTransform\", new DocumentTransform(removeMaskedFragmentSpreads));\n    if (__DEV__) {\n      invariant(options.cache, 68);\n      invariant(options.link, 69);\n    }\n    const {\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      localState,\n      devtools,\n      dataMasking,\n      link,\n      incrementalHandler = new NotImplementedHandler(),\n      experiments = []\n    } = options;\n    this.link = link;\n    this.cache = cache;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.devtoolsConfig = _objectSpread(_objectSpread({}, devtools), {}, {\n      enabled: (_devtools$enabled = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _devtools$enabled !== void 0 ? _devtools$enabled : __DEV__\n    });\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.refetchObservableQueries = this.refetchObservableQueries.bind(this);\n    this.version = version;\n    this.queryManager = new QueryManager({\n      client: this,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientOptions: options,\n      incrementalHandler,\n      assumeImmutableResults,\n      onBroadcast: this.devtoolsConfig.enabled ? () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb();\n        }\n      } : void 0,\n      localState\n    });\n    this.prioritizeCacheValues = ssrMode || ssrForceFetchDelay > 0;\n    if (ssrForceFetchDelay) {\n      setTimeout(() => {\n        this.prioritizeCacheValues = false;\n      }, ssrForceFetchDelay);\n    }\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n    experiments.forEach(experiment => experiment.call(this, options));\n  }\n  connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    const windowWithDevTools = window;\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {\n        setTimeout(() => {\n          if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              __DEV__ && invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n  /**\n   * The configured `LocalState` instance used to enable the use of `@client`\n   * fields.\n   */\n  get localState() {\n    return this.queryManager.localState;\n  }\n  set localState(localState) {\n    this.queryManager.localState = localState;\n  }\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   *\n   * This method performs aggressive cleanup to prevent memory leaks:\n   *\n   * - Unsubscribes all active `ObservableQuery` instances by emitting a `completed` event\n   * - Rejects all currently running queries with \"QueryManager stopped while query was in flight\"\n   * - Removes all queryRefs from the suspense cache\n   */\n  stop() {\n    this.queryManager.stop();\n  }\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * `cache.identify`. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will _not_ be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  watchQuery(options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n    return this.queryManager.watchQuery(options);\n  }\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  query(options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n    if (__DEV__) {\n      invariant(options.fetchPolicy !== \"cache-and-network\", 70);\n      invariant(options.fetchPolicy !== \"standby\", 71);\n      invariant(options.query, 72);\n      invariant(options.query.kind === \"Document\", 73);\n      invariant(!options.returnPartialData, 74);\n      invariant(!options.pollInterval, 75);\n      invariant(!options.notifyOnNetworkStatusChange, 76);\n    }\n    return this.queryManager.query(options);\n  }\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  mutate(options) {\n    const optionsWithDefaults = mergeOptions(compact({\n      fetchPolicy: \"network-only\",\n      errorPolicy: \"none\"\n    }, this.defaultOptions.mutate), options);\n    if (__DEV__) {\n      invariant(optionsWithDefaults.mutation, 77);\n      invariant(optionsWithDefaults.fetchPolicy === \"network-only\" || optionsWithDefaults.fetchPolicy === \"no-cache\", 78);\n    }\n    checkDocument(optionsWithDefaults.mutation, OperationTypeNode.MUTATION);\n    return this.queryManager.mutate(optionsWithDefaults);\n  }\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  subscribe(options) {\n    const cause = {};\n    const observable = this.queryManager.startGraphQLSubscription(options);\n    const mapped = observable.pipe(map(result => _objectSpread(_objectSpread({}, result), {}, {\n      data: this.queryManager.maskOperation({\n        document: options.query,\n        data: result.data,\n        fetchPolicy: options.fetchPolicy,\n        cause\n      })\n    })));\n    return Object.assign(mapped, {\n      restart: observable.restart\n    });\n  }\n  readQuery(options) {\n    let optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.cache.readQuery(_objectSpread(_objectSpread({}, options), {}, {\n      query: this.transform(options.query)\n    }), optimistic);\n  }\n  watchFragment(options) {\n    const dataMasking = this.queryManager.dataMasking;\n    const observable = this.cache.watchFragment(_objectSpread(_objectSpread({}, options), {}, {\n      fragment: this.transform(options.fragment, dataMasking)\n    }));\n    if (__DEV__) {\n      return mapObservableFragmentMemoized(observable, Symbol.for(\"apollo.transform.dev.mask\"), result => _objectSpread(_objectSpread({}, result), {}, {\n        // The transform will remove fragment spreads from the fragment\n        // document when dataMasking is enabled. The `mask` function\n        // remains to apply warnings to fragments marked as\n        // `@unmask(mode: \"migrate\")`. Since these warnings are only applied\n        // in dev, we can skip the masking algorithm entirely for production.\n        data: this.queryManager.maskFragment(_objectSpread(_objectSpread({}, options), {}, {\n          data: result.data\n        }))\n      }));\n    }\n    return observable;\n  }\n  readFragment(options) {\n    let optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.cache.readFragment(_objectSpread(_objectSpread({}, options), {}, {\n      fragment: this.transform(options.fragment)\n    }), optimistic);\n  }\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `cache.identify` then use `writeFragment`.\n   */\n  writeQuery(options) {\n    const ref = this.cache.writeQuery(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  }\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  writeFragment(options) {\n    const ref = this.cache.writeFragment(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  }\n  __actionHookForDevTools(cb) {\n    this.devToolsHookCb = cb;\n  }\n  __requestRaw(request) {\n    return execute(this.link, request, {\n      client: this\n    });\n  }\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  resetStore() {\n    return Promise.resolve().then(() => this.queryManager.clearStore({\n      discardWatches: false\n    })).then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn()))).then(() => this.refetchObservableQueries());\n  }\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  clearStore() {\n    return Promise.resolve().then(() => this.queryManager.clearStore({\n      discardWatches: true\n    })).then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  onResetStore(cb) {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  onClearStore(cb) {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n  /**\n   * Refetches all of your active queries.\n   *\n   * `refetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `refetchObservableQueries()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   *\n   * Note: `cache-only` queries are not refetched by this function.\n   */\n  refetchObservableQueries(includeStandby) {\n    return this.queryManager.refetchObservableQueries(includeStandby);\n  }\n  /**\n   * Refetches specified active queries. Similar to \"refetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` _will_ refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  refetchQueries(options) {\n    const map = this.queryManager.refetchQueries(options);\n    const queries = [];\n    const results = [];\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n    const result = Promise.all(results);\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch(error => {\n      __DEV__ && invariant.debug(79, error);\n    });\n    return result;\n  }\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Set`.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   *\n   * Note: This method only returns queries that have active subscribers. Queries\n   * without subscribers are not tracked by the client.\n   */\n  getObservableQueries() {\n    let include = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"active\";\n    return this.queryManager.getObservableQueries(include);\n  }\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   *\n   * @remarks\n   *\n   * This can be useful for debugging in order to inspect the full state of the\n   * cache.\n   *\n   * @param optimistic - Determines whether the result contains data from the\n   * optimistic layer\n   */\n  extract(optimistic) {\n    return this.cache.extract(optimistic);\n  }\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  restore(serializedState) {\n    return this.cache.restore(serializedState);\n  }\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  setLink(newLink) {\n    this.link = newLink;\n  }\n  get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n  transform(document) {\n    let dataMasking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const transformed = this.queryManager.transform(document);\n    return dataMasking ? this.maskedFragmentTransform.transformDocument(transformed) : transformed;\n  }\n}\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}","map":{"version":3,"names":["OperationTypeNode","map","NotImplementedHandler","execute","DocumentTransform","__DEV__","checkDocument","compact","getApolloClientMemoryInternals","mapObservableFragmentMemoized","mergeOptions","removeMaskedFragmentSpreads","invariant","version","QueryManager","hasSuggestedDevtools","ApolloClient","prioritizeCacheValues","value","queryManager","constructor","options","_devtools$enabled","_defineProperty","cache","link","documentTransform","ssrMode","ssrForceFetchDelay","queryDeduplication","defaultOptions","defaultContext","assumeImmutableResults","localState","devtools","dataMasking","incrementalHandler","experiments","devtoolsConfig","_objectSpread","enabled","watchQuery","bind","query","mutate","watchFragment","resetStore","reFetchObservableQueries","refetchObservableQueries","client","clientOptions","onBroadcast","devToolsHookCb","setTimeout","connectToDevTools","forEach","experiment","call","window","windowWithDevTools","devtoolsSymbol","Symbol","for","push","__APOLLO_CLIENT__","document","top","self","test","location","protocol","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","nav","navigator","ua","userAgent","url","indexOf","log","stop","fetchPolicy","kind","returnPartialData","pollInterval","notifyOnNetworkStatusChange","optionsWithDefaults","errorPolicy","mutation","MUTATION","subscribe","cause","observable","startGraphQLSubscription","mapped","pipe","result","data","maskOperation","Object","assign","restart","readQuery","optimistic","arguments","length","undefined","transform","fragment","maskFragment","readFragment","writeQuery","ref","broadcast","broadcastQueries","writeFragment","__actionHookForDevTools","cb","__requestRaw","request","Promise","resolve","then","clearStore","discardWatches","all","resetStoreCallbacks","fn","clearStoreCallbacks","onResetStore","filter","c","onClearStore","includeStandby","refetchQueries","queries","results","obsQuery","catch","error","debug","getObservableQueries","include","extract","restore","serializedState","setLink","newLink","transformed","maskedFragmentTransform","transformDocument","prototype","getMemoryInternals"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/core/ApolloClient.ts"],"sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport { OperationTypeNode } from \"graphql\";\nimport type { Observable } from \"rxjs\";\nimport { map } from \"rxjs\";\n\nimport type {\n  ApolloCache,\n  Cache,\n  IgnoreModifier,\n  Reference,\n} from \"@apollo/client/cache\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport { NotImplementedHandler } from \"@apollo/client/incremental\";\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport { execute } from \"@apollo/client/link\";\nimport type { ClientAwarenessLink } from \"@apollo/client/link/client-awareness\";\nimport type { LocalState } from \"@apollo/client/local-state\";\nimport type { MaybeMasked, Unmasked } from \"@apollo/client/masking\";\nimport { DocumentTransform } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  VariablesOption,\n  variablesUnknownSymbol,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  checkDocument,\n  compact,\n  getApolloClientMemoryInternals,\n  mapObservableFragmentMemoized,\n  mergeOptions,\n  removeMaskedFragmentSpreads,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { version } from \"../version.js\";\n\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport type {\n  DefaultContext,\n  ErrorLike,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesResult,\n  MutationQueryReducersMap,\n  MutationUpdaterFunction,\n  NormalizedExecutionResult,\n  OnQueryUpdated,\n  OperationVariables,\n  RefetchQueriesInclude,\n  RefetchQueriesPromiseResults,\n  SubscriptionObservable,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  FetchPolicy,\n  MutationFetchPolicy,\n  NextFetchPolicyContext,\n  RefetchWritePolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nlet hasSuggestedDevtools = false;\n\nexport declare namespace ApolloClient {\n  export interface DefaultOptions {\n    watchQuery?: Partial<ApolloClient.WatchQueryOptions<any, any>>;\n    query?: Partial<ApolloClient.QueryOptions<any, any>>;\n    mutate?: Partial<ApolloClient.MutateOptions<any, any, any>>;\n  }\n\n  export interface Options {\n    /**\n     * An `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n     */\n    link: ApolloLink;\n    /**\n     * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n     *\n     * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n     */\n    cache: ApolloCache;\n    /**\n     * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n     *\n     * @defaultValue `0` (no delay)\n     */\n    ssrForceFetchDelay?: number;\n    /**\n     * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n     *\n     * @defaultValue `false`\n     */\n    ssrMode?: boolean;\n    /**\n     * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n     *\n     * @defaultValue `true`\n     */\n    queryDeduplication?: boolean;\n    /**\n     * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n     *\n     * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n     */\n    defaultOptions?: ApolloClient.DefaultOptions;\n    defaultContext?: Partial<DefaultContext>;\n    /**\n     * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n     *\n     * @defaultValue `false`\n     */\n    assumeImmutableResults?: boolean;\n    localState?: LocalState;\n    /** {@inheritDoc @apollo/client/link/client-awareness!ClientAwarenessLink.ClientAwarenessOptions:interface} */\n    clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;\n    /** {@inheritDoc @apollo/client/link/client-awareness!ClientAwarenessLink.EnhancedClientAwarenessOptions:interface} */\n    enhancedClientAwareness?: ClientAwarenessLink.EnhancedClientAwarenessOptions;\n    documentTransform?: DocumentTransform;\n\n    /**\n     * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n     *\n     * @since 3.11.0\n     */\n    devtools?: ApolloClient.DevtoolsOptions;\n\n    /**\n     * Determines if data masking is enabled for the client.\n     *\n     * @defaultValue false\n     */\n    dataMasking?: boolean;\n\n    /**\n     * Determines the strategy used to parse incremental chunks from `@defer`\n     * queries.\n     */\n    incrementalHandler?: Incremental.Handler<any>;\n\n    /**\n     * @experimental\n     * Allows passing in \"experiments\", experimental features that might one day\n     * become part of Apollo Client's core functionality.\n     * Keep in mind that these features might change the core of Apollo Client.\n     * Do not pass in experiments that are not provided by Apollo.\n     */\n    experiments?: ApolloClient.Experiment[];\n  }\n\n  interface DevtoolsOptions {\n    /**\n     * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n     *\n     * The default value is `false` in production and `true` in development if there is a `window` object.\n     */\n    enabled?: boolean;\n\n    /**\n     * Optional name for this `ApolloClient` instance in the devtools. This is\n     * useful when you instantiate multiple clients and want to be able to\n     * identify them by name.\n     */\n    name?: string;\n  }\n\n  export type MutateOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  > = {\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#optimisticResponse:member} */\n    optimisticResponse?:\n      | Unmasked<NoInfer<TData>>\n      | ((\n          vars: TVariables,\n          { IGNORE }: { IGNORE: IgnoreModifier }\n        ) => Unmasked<NoInfer<TData>> | IgnoreModifier);\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#updateQueries:member} */\n    updateQueries?: MutationQueryReducersMap<TData>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#refetchQueries:member} */\n    refetchQueries?:\n      | ((\n          result: NormalizedExecutionResult<Unmasked<TData>>\n        ) => InternalRefetchQueriesInclude)\n      | InternalRefetchQueriesInclude;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#awaitRefetchQueries:member} */\n    awaitRefetchQueries?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#update:member} */\n    update?: MutationUpdaterFunction<TData, TVariables, TCache>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#onQueryUpdated:member} */\n    onQueryUpdated?: OnQueryUpdated<any>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: MutationFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#keepRootFields:member} */\n    keepRootFields?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#mutation:member} */\n    mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  export interface MutateResult<TData = unknown> {\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#data:member} */\n    data: TData | undefined;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#error:member} */\n    error?: ErrorLike;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#extensions:member} */\n    extensions?: Record<string, unknown>;\n  }\n\n  /**\n   * Query options.\n   */\n  export type QueryOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: FetchPolicy;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  export interface QueryResult<TData = unknown> {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n    data: TData | undefined;\n\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n    error?: ErrorLike;\n  }\n\n  /**\n   * Options object for the `client.refetchQueries` method.\n   */\n  export interface RefetchQueriesOptions<TCache extends ApolloCache, TResult> {\n    /**\n     * Optional function that updates cached fields to trigger refetches of queries that include those fields.\n     */\n    updateCache?: (cache: TCache) => void;\n\n    /**\n     * Optional array specifying queries to refetch. Each element can be either a query's string name or a `DocumentNode` object.\n     *\n     * Pass `\"active\"` as a shorthand to refetch all active queries, or `\"all\"` to refetch all active and inactive queries.\n     *\n     * Analogous to the [`options.refetchQueries`](https://www.apollographql.com/docs/react/data/mutations/#options) array for mutations.\n     */\n    include?: RefetchQueriesInclude;\n\n    /**\n     * If `true`, the `options.updateCache` function is executed on a temporary optimistic layer of `InMemoryCache`, so its modifications can be discarded from the cache after observing which fields it invalidated.\n     *\n     * Defaults to `false`, meaning `options.updateCache` updates the cache in a lasting way.\n     */\n    optimistic?: boolean;\n\n    /**\n     * Optional callback function that's called once for each `ObservableQuery` that's either affected by `options.updateCache` or listed in `options.include` (or both).\n     *\n     * If `onQueryUpdated` is not provided, the default implementation returns the result of calling `observableQuery.refetch()`. When `onQueryUpdated` is provided, it can dynamically decide whether (and how) each query should be refetched.\n     *\n     * Returning `false` from `onQueryUpdated` prevents the associated query from being refetched.\n     */\n    onQueryUpdated?: OnQueryUpdated<TResult> | null;\n  }\n\n  /**\n   * The result of client.refetchQueries is thenable/awaitable, if you just want\n   * an array of fully resolved results, but you can also access the raw results\n   * immediately by examining the additional `queries` and `results` properties of\n   * the `RefetchQueriesResult<TResult> object`.\n   */\n  export interface RefetchQueriesResult<TResult>\n    extends Promise<RefetchQueriesPromiseResults<TResult>>,\n      RefetchQueriesResult.AdditionalProperties<TResult> {}\n\n  export namespace RefetchQueriesResult {\n    export interface AdditionalProperties<TResult> {\n      /**\n       * An array of ObservableQuery objects corresponding 1:1 to TResult values\n       * in the results arrays (both the `result` property and the resolved value).\n       */\n      queries: ObservableQuery<any>[];\n      /**\n       * An array of results that were either returned by `onQueryUpdated`, or provided by default in the absence of `onQueryUpdated`, including pending promises.\n       *\n       * If `onQueryUpdated` returns `false` for a given query, no result is provided for that query.\n       *\n       * If `onQueryUpdated` returns `true`, the resulting `Promise<ApolloQueryResult<any>>` is included in the `results` array instead of `true`.\n       */\n      results: InternalRefetchQueriesResult<TResult>[];\n    }\n  }\n\n  export type SubscribeOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: FetchPolicy;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#extensions:member} */\n    extensions?: Record<string, any>;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  export interface SubscribeResult<TData = unknown> {\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#data:member} */\n    data: TData | undefined;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#error:member} */\n    error?: ErrorLike;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#extensions:member} */\n    extensions?: Record<string, unknown>;\n  }\n\n  export type WatchFragmentOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = ApolloCache.WatchFragmentOptions<TData, TVariables>;\n\n  export type WatchFragmentResult<TData = unknown> =\n    ApolloCache.WatchFragmentResult<MaybeMasked<TData>>;\n\n  export interface ObservableFragment<TData = unknown>\n    extends Observable<ApolloClient.WatchFragmentResult<TData>> {\n    /**\n     * Return the current result for the fragment.\n     */\n    getCurrentResult: () => ApolloClient.WatchFragmentResult<TData>;\n  }\n\n  /**\n   * Watched query options.\n   */\n  export type WatchQueryOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n    initialFetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * @internal This API is meant for framework integrations only.\n     * Do not use for everyday use.\n     *\n     * Indicates that the variables are unknown at the time of query creation.\n     * This option can only be set when `fetchPolicy` is `'standby'`.\n     * Setting this to `true` will prevent `client.refetchQueries` from refetching\n     * this query before it has left the `'standby'` state, either by setting a\n     * `fetchPolicy`, or by calling `observableQuery.refetch()` explicitly.\n     *\n     * Changing this option after the query has been created will have no effect.\n     */\n    [variablesUnknownSymbol]?: boolean;\n  } & VariablesOption<NoInfer<TVariables>>;\n\n  namespace Base {\n    export interface ReadQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * The GraphQL query shape to be used constructed using the `gql` template\n       * string tag. The query will be used to determine the\n       * shape of the data to be read.\n       */\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n       * root query object. This property makes `readQuery` capable of reading data\n       * from any object in the cache.\n       */\n      id?: string;\n\n      /**\n       * Whether to return incomplete data rather than null.\n       * @defaultValue false\n       */\n      returnPartialData?: boolean;\n\n      /**\n       * Whether to read from optimistic or non-optimistic cache data.\n       * This option should be preferred over the `optimistic` parameter of the\n       * `readQuery` method.\n       * @defaultValue false\n       */\n      optimistic?: boolean;\n    }\n  }\n  export type ReadQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.ReadQueryOptions<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    export interface ReadQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.ReadQueryOptions<TData, TVariables> {\n      /**\n       * Any variables that the GraphQL query may depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  namespace Base {\n    export interface ReadFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * A GraphQL document created using the `gql` template string tag\n       * with one or more fragments which will be used to determine\n       * the shape of data to read. If you provide more than one fragment in this\n       * document then you must also specify `fragmentName` to specify which\n       * fragment is the root fragment.\n       */\n      fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The name of the fragment in your GraphQL document to be used. If you do\n       * not provide a `fragmentName` and there is only one fragment in your\n       * `fragment` document then that fragment will be used.\n       */\n      fragmentName?: string;\n\n      /**\n       * Whether to return incomplete data rather than null.\n       * @defaultValue false\n       */\n      returnPartialData?: boolean;\n      /**\n       * Whether to read from optimistic or non-optimistic cache data.\n       * This option should be preferred over the `optimistic` parameter of the\n       * `readFragment` method.\n       * @defaultValue false\n       */\n      optimistic?: boolean;\n    }\n  }\n\n  export namespace DocumentationTypes {\n    export interface ReadFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.ReadFragmentOptions<TData, TVariables> {\n      /**\n       * The root id to be used. This id should take the same form as the\n       * value returned by the `cache.identify` function. If a value with your\n       * id does not exist in the store, `null` will be returned.\n       */\n      id?: string;\n\n      /**\n       * An object containing a `__typename` and primary key fields\n       * (such as `id`) identifying the entity object from which the fragment will\n       * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n       * (uncommon).\n       *\n       * @remarks\n       * `from` is given precedence over `id` when both are provided.\n       */\n      from?: ApolloCache.FromOptionValue<TData>;\n    }\n  }\n\n  export type ReadFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.ReadFragmentOptions<TData, TVariables> &\n    VariablesOption<TVariables> &\n    Cache.CacheIdentifierOption<TData>;\n\n  export namespace DocumentationTypes {\n    export interface WriteQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.WriteQueryOptions<TData, TVariables> {\n      /**\n       * Any variables that your GraphQL fragments depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  namespace Base {\n    export interface WriteQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * The GraphQL query shape to be used constructed using the `gql` template\n       * string tag. The query will be used to determine the\n       * shape of the data to be read.\n       */\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n       * root query object. This property makes writeQuery capable of writing data\n       * to any object in the cache.\n       */\n      id?: string;\n      /**\n       * The data to write to the store.\n       */\n      data: Unmasked<TData>;\n      /**\n       * Whether to notify query watchers.\n       * @defaultValue true\n       */\n      broadcast?: boolean;\n      /**\n       * When true, ignore existing field data rather than merging it with\n       * incoming data.\n       * @defaultValue false\n       */\n      overwrite?: boolean;\n      /**\n       * GraphQL extensions for the write operation. Any provided `extensions`\n       * are available in `merge` functions.\n       */\n      extensions?: Record<string, unknown>;\n    }\n  }\n  export type WriteQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.WriteQueryOptions<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    export interface WriteQueryOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.WriteQueryOptions<TData, TVariables> {\n      /**\n       * Any variables that the GraphQL query may depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  namespace Base {\n    export interface WriteFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > {\n      /**\n       * A GraphQL document created using the `gql` template string tag from\n       * `graphql-tag` with one or more fragments which will be used to determine\n       * the shape of data to read. If you provide more than one fragment in this\n       * document then you must also specify `fragmentName` to specify which\n       * fragment is the root fragment.\n       */\n      fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The name of the fragment in your GraphQL document to be used. If you do\n       * not provide a `fragmentName` and there is only one fragment in your\n       * `fragment` document then that fragment will be used.\n       */\n      fragmentName?: string;\n\n      /**\n       * The data to write to the store.\n       */\n      data: Unmasked<TData>;\n      /**\n       * Whether to notify query watchers.\n       * @defaultValue true\n       */\n      broadcast?: boolean;\n      /**\n       * When true, ignore existing field data rather than merging it with\n       * incoming data.\n       * @defaultValue false\n       */\n      overwrite?: boolean;\n    }\n  }\n  export type WriteFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.WriteFragmentOptions<TData, TVariables> &\n    VariablesOption<TVariables> &\n    Cache.CacheIdentifierOption<TData>;\n\n  export namespace DocumentationTypes {\n    export interface WriteFragmentOptions<\n      TData,\n      TVariables extends OperationVariables,\n    > extends Base.WriteFragmentOptions<TData, TVariables> {\n      /**\n       * The root id to be used. This id should take the same form as the\n       * value returned by the `cache.identify` function. If a value with your\n       * id does not exist in the store, `null` will be returned.\n       */\n      id?: string;\n\n      /**\n       * An object containing a `__typename` and primary key fields\n       * (such as `id`) identifying the entity object from which the fragment will\n       * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n       * (uncommon).\n       *\n       * @remarks\n       * `from` is given precedence over `id` when both are provided.\n       */\n      from?: ApolloCache.FromOptionValue<TData>;\n\n      /**\n       * Any variables that your GraphQL fragments depend on.\n       */\n      variables?: TVariables;\n    }\n  }\n\n  export interface Experiment {\n    (this: ApolloClient, options: ApolloClient.Options): void;\n    v: 1;\n  }\n}\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient {\n  public link: ApolloLink;\n  public cache: ApolloCache;\n  /**\n   * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`.\n   */\n  public disableNetworkFetches!: never;\n\n  public set prioritizeCacheValues(value: boolean) {\n    this.queryManager.prioritizeCacheValues = value;\n  }\n\n  /**\n   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after SSR.\n   */\n  public get prioritizeCacheValues() {\n    return this.queryManager.prioritizeCacheValues;\n  }\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: ApolloClient.DefaultOptions;\n  public readonly devtoolsConfig: ApolloClient.DevtoolsOptions;\n\n  private queryManager: QueryManager;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   *\n   * ```js\n   * import { ApolloClient, InMemoryCache, HttpLink } from \"@apollo/client\";\n   *\n   * const cache = new InMemoryCache();\n   * const link = new HttpLink({ uri: \"http://localhost:4000/\" });\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   link: link,\n   *\n   *   // Provide some optional constructor fields\n   *   clientAwareness: {\n   *     name: \"react-web-client\",\n   *     version: \"1.3\",\n   *   },\n   *   queryDeduplication: false,\n   * });\n   * ```\n   */\n  constructor(options: ApolloClient.Options) {\n    if (__DEV__) {\n      invariant(\n        options.cache,\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n\n      invariant(\n        options.link,\n        \"To initialize Apollo Client, you must specify a 'link' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      localState,\n      devtools,\n      dataMasking,\n      link,\n      incrementalHandler = new NotImplementedHandler(),\n      experiments = [],\n    } = options;\n\n    this.link = link;\n    this.cache = cache;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled ?? __DEV__,\n    };\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.refetchObservableQueries =\n      this.refetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.queryManager = new QueryManager({\n      client: this,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientOptions: options,\n      incrementalHandler,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb();\n            }\n          }\n        : void 0,\n      localState,\n    });\n\n    this.prioritizeCacheValues = ssrMode || ssrForceFetchDelay > 0;\n    if (ssrForceFetchDelay) {\n      setTimeout(() => {\n        this.prioritizeCacheValues = false;\n      }, ssrForceFetchDelay);\n    }\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n\n    experiments.forEach((experiment) => experiment.call(this, options));\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * The configured `LocalState` instance used to enable the use of `@client`\n   * fields.\n   */\n  get localState(): LocalState | undefined {\n    return this.queryManager.localState;\n  }\n\n  set localState(localState: LocalState) {\n    this.queryManager.localState = localState;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   *\n   * This method performs aggressive cleanup to prevent memory leaks:\n   *\n   * - Unsubscribes all active `ObservableQuery` instances by emitting a `completed` event\n   * - Rejects all currently running queries with \"QueryManager stopped while query was in flight\"\n   * - Removes all queryRefs from the suspense cache\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * `cache.identify`. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will _not_ be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ): ObservableQuery<TData, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(\n        this.defaultOptions.watchQuery as Partial<\n          ApolloClient.WatchQueryOptions<TData, TVariables>\n        >,\n        options\n      );\n    }\n\n    return this.queryManager.watchQuery<TData, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.QueryOptions<TData, TVariables>\n  ): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    if (__DEV__) {\n      invariant(\n        (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n        \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n          \"client.query can only return a single result. Please use client.watchQuery \" +\n          \"to receive multiple results from the cache and the network, or consider \" +\n          \"using a different fetchPolicy, such as cache-first or network-only.\"\n      );\n\n      invariant(\n        (options.fetchPolicy as WatchQueryFetchPolicy) !== \"standby\",\n        \"The standby fetchPolicy does not work with client.query, because \" +\n          \"standby does not fetch. Consider using a different fetchPolicy, such \" +\n          \"as cache-first or network-only.\"\n      );\n\n      invariant(\n        options.query,\n        \"query option is required. You must specify your GraphQL document \" +\n          \"in the query option.\"\n      );\n\n      invariant(\n        options.query.kind === \"Document\",\n        'You must wrap the query string in a \"gql\" tag.'\n      );\n\n      invariant(\n        !(options as any).returnPartialData,\n        \"returnPartialData option only supported on watchQuery.\"\n      );\n\n      invariant(\n        !(options as any).pollInterval,\n        \"pollInterval option only supported on watchQuery.\"\n      );\n\n      invariant(\n        !(options as any).notifyOnNetworkStatusChange,\n        \"notifyOnNetworkStatusChange option only supported on watchQuery.\"\n      );\n    }\n\n    return this.queryManager.query<TData, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  >(\n    options: ApolloClient.MutateOptions<TData, TVariables, TCache>\n  ): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>> {\n    const optionsWithDefaults = mergeOptions(\n      compact(\n        {\n          fetchPolicy: \"network-only\" as MutationFetchPolicy,\n          errorPolicy: \"none\" as ErrorPolicy,\n        },\n        this.defaultOptions.mutate\n      ),\n      options\n    ) as ApolloClient.MutateOptions<TData, TVariables, TCache> & {\n      fetchPolicy: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n    };\n\n    if (__DEV__) {\n      invariant(\n        optionsWithDefaults.mutation,\n        \"The `mutation` option is required. Please provide a GraphQL document in the `mutation` option.\"\n      );\n\n      invariant(\n        optionsWithDefaults.fetchPolicy === \"network-only\" ||\n          optionsWithDefaults.fetchPolicy === \"no-cache\",\n        \"Mutations only support 'network-only' or 'no-cache' fetch policies. The default 'network-only' behavior automatically writes mutation results to the cache. Passing 'no-cache' skips the cache write.\"\n      );\n    }\n\n    checkDocument(optionsWithDefaults.mutation, OperationTypeNode.MUTATION);\n\n    return this.queryManager.mutate<TData, TVariables, TCache>(\n      optionsWithDefaults\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.SubscribeOptions<TData, TVariables>\n  ): SubscriptionObservable<ApolloClient.SubscribeResult<MaybeMasked<TData>>> {\n    const cause = {};\n\n    const observable =\n      this.queryManager.startGraphQLSubscription<TData>(options);\n\n    const mapped = observable.pipe(\n      map((result) => ({\n        ...result,\n        data: this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          cause,\n        }),\n      }))\n    );\n\n    return Object.assign(mapped, { restart: observable.restart });\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `cache.identify`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadQueryOptions<TData, TVariables>\n  ): Unmasked<TData> | null;\n\n  /**\n   * {@inheritDoc @apollo/client!ApolloClient#readQuery:member(1)}\n   *\n   * @deprecated Pass the `optimistic` argument as part of the first argument\n   * instead of passing it as a separate option.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadQueryOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadQueryOptions<TData, TVariables>,\n    optimistic: boolean = false\n  ): Unmasked<TData> | null {\n    return this.cache.readQuery<TData, TVariables>(\n      { ...options, query: this.transform(options.query) },\n      optimistic\n    );\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: Array<ApolloCache.FromOptionValue<TData>>;\n    }\n  ): ApolloClient.ObservableFragment<Array<TData>>;\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: Array<null>;\n    }\n  ): ApolloClient.ObservableFragment<Array<null>>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: Array<ApolloCache.FromOptionValue<TData> | null>;\n    }\n  ): ApolloClient.ObservableFragment<Array<TData | null>>;\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: null;\n    }\n  ): ApolloClient.ObservableFragment<null>;\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: ApolloCache.FromOptionValue<TData>;\n    }\n  ): ApolloClient.ObservableFragment<TData>;\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables>\n  ): ApolloClient.ObservableFragment<TData | null>;\n\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables>\n  ):\n    | ApolloClient.ObservableFragment<TData>\n    | ApolloClient.ObservableFragment<Array<TData>> {\n    const dataMasking = this.queryManager.dataMasking;\n    const observable = this.cache.watchFragment({\n      ...options,\n      fragment: this.transform(options.fragment, dataMasking),\n    });\n\n    if (__DEV__) {\n      return mapObservableFragmentMemoized(\n        observable,\n        Symbol.for(\"apollo.transform.dev.mask\"),\n        (\n          result: ApolloClient.WatchFragmentResult<any>\n        ): ApolloClient.WatchFragmentResult<any> => ({\n          ...result,\n          // The transform will remove fragment spreads from the fragment\n          // document when dataMasking is enabled. The `mask` function\n          // remains to apply warnings to fragments marked as\n          // `@unmask(mode: \"migrate\")`. Since these warnings are only applied\n          // in dev, we can skip the masking algorithm entirely for production.\n          data: this.queryManager.maskFragment({\n            ...options,\n            data: result.data,\n          }),\n        })\n      ) satisfies ApolloClient.ObservableFragment<any> as ApolloClient.ObservableFragment<any>;\n    }\n\n    return observable as ApolloClient.ObservableFragment<any>;\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadFragmentOptions<TData, TVariables>\n  ): Unmasked<TData> | null;\n  /**\n   * {@inheritDoc @apollo/client!ApolloClient#readFragment:member(1)}\n   *\n   * @deprecated Pass the `optimistic` argument as part of the first argument\n   * instead of passing it as a separate option.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadFragmentOptions<TData, TVariables>,\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.ReadFragmentOptions<TData, TVariables>,\n    optimistic: boolean = false\n  ): Unmasked<TData> | null {\n    return this.cache.readFragment<TData, TVariables>(\n      { ...options, fragment: this.transform(options.fragment) },\n      optimistic\n    );\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `cache.identify` then use `writeFragment`.\n   */\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    request: ApolloLink.Request\n  ): Observable<ApolloLink.Result<unknown>> {\n    return execute(this.link, request, { client: this });\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloClient.QueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.refetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   *\n   * Note: `cache-only` queries are not refetched by this function.\n   *\n   * @deprecated Please use `refetchObservableQueries` instead.\n   */\n  public reFetchObservableQueries: (\n    includeStandby?: boolean\n  ) => Promise<ApolloClient.QueryResult<any>[]>;\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `refetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `refetchObservableQueries()` _will_ refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   *\n   * Note: `cache-only` queries are not refetched by this function.\n   */\n  public refetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloClient.QueryResult<any>[]> {\n    return this.queryManager.refetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"refetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` _will_ refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache = ApolloCache,\n    TResult = Promise<ApolloClient.QueryResult<any>>,\n  >(\n    options: ApolloClient.RefetchQueriesOptions<TCache, TResult>\n  ): ApolloClient.RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as ApolloClient.RefetchQueriesOptions<ApolloCache, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as ApolloClient.RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Set`.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   *\n   * Note: This method only returns queries that have active subscribers. Queries\n   * without subscribers are not tracked by the client.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Set<ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   *\n   * @remarks\n   *\n   * This can be useful for debugging in order to inspect the full state of the\n   * cache.\n   *\n   * @param optimistic - Determines whether the result contains data from the\n   * optimistic layer\n   */\n  public extract(optimistic?: boolean) {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: unknown) {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  private maskedFragmentTransform = new DocumentTransform(\n    removeMaskedFragmentSpreads\n  );\n\n  private transform(document: DocumentNode, dataMasking = false) {\n    const transformed = this.queryManager.transform(document);\n    return dataMasking ?\n        this.maskedFragmentTransform.transformDocument(transformed)\n      : transformed;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   *\n   * ```ts\n   * console.log(client.getMemoryInternals());\n   * ```\n   *\n   * Logs output in the following JSON format:\n   * @example\n   *\n   * ```json\n   * {\n   *   \"limits\": {\n   *     \"canonicalStringify\": 1000,\n   *     \"print\": 2000,\n   *     \"documentTransform.cache\": 2000,\n   *     \"queryManager.getDocumentInfo\": 2000,\n   *     \"PersistedQueryLink.persistedQueryHashes\": 2000,\n   *     \"fragmentRegistry.transform\": 2000,\n   *     \"fragmentRegistry.lookup\": 1000,\n   *     \"fragmentRegistry.findFragmentSpreads\": 4000,\n   *     \"cache.fragmentQueryDocuments\": 1000,\n   *     \"removeTypenameFromVariables.getVariableDefinitions\": 2000,\n   *     \"inMemoryCache.maybeBroadcastWatch\": 5000,\n   *     \"inMemoryCache.executeSelectionSet\": 10000,\n   *     \"inMemoryCache.executeSubSelectedArray\": 5000\n   *   },\n   *   \"sizes\": {\n   *     \"canonicalStringify\": 4,\n   *     \"print\": 14,\n   *     \"addTypenameDocumentTransform\": [\n   *       {\n   *         \"cache\": 14\n   *       }\n   *     ],\n   *     \"queryManager\": {\n   *       \"getDocumentInfo\": 14,\n   *       \"documentTransforms\": [\n   *         {\n   *           \"cache\": 14\n   *         },\n   *         {\n   *           \"cache\": 14\n   *         }\n   *       ]\n   *     },\n   *     \"fragmentRegistry\": {\n   *       \"findFragmentSpreads\": 34,\n   *       \"lookup\": 20,\n   *       \"transform\": 14\n   *     },\n   *     \"cache\": {\n   *       \"fragmentQueryDocuments\": 22\n   *     },\n   *     \"inMemoryCache\": {\n   *       \"executeSelectionSet\": 4345,\n   *       \"executeSubSelectedArray\": 1206,\n   *       \"maybeBroadcastWatch\": 32\n   *     },\n   *     \"links\": [\n   *       {\n   *         \"PersistedQueryLink\": {\n   *           \"persistedQueryHashes\": 14\n   *         }\n   *       },\n   *       {\n   *         \"removeTypenameFromVariables\": {\n   *           \"getVariableDefinitions\": 14\n   *         }\n   *       }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  public declare getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n"],"mappings":";;AACA,SAASA,iBAAT,QAAkC,SAAS;AAE3C,SAASC,GAAT,QAAoB,MAAM;AAS1B,SAASC,qBAAT,QAAsC,4BAA4B;AAElE,SAASC,OAAT,QAAwB,qBAAqB;AAI7C,SAASC,iBAAT,QAAkC,0BAA0B;AAC5D,SAASC,OAAT,QAAwB,sCAAsC;AAK9D,SACEC,aAAa,EACbC,OAAO,EACPC,8BAA8B,EAC9BC,6BAA6B,EAC7BC,YAAY,EACZC,2BAA2B,QACtB,mCAAmC;AAC1C,SAASC,SAAT,QAA0B,oCAAoC;AAE9D,SAASC,OAAT,QAAwB,eAAe;AAGvC,SAASC,YAAT,QAA6B,mBAAmB;AAyBhD,IAAIC,oBAAJ,GAA2B,KAAK;AAunBhC;;;;;;AAMA,aAAaC,YAAb;EAQE,IAAWC,qBAAqBA,CAACC,KAAc,EAAjD;IACI,IAAI,CAACC,YAAY,CAACF,qBAAtB,GAA8CC,KAAK;EACjD;EAEA;;;;;;;EAOA,IAAWD,qBAAqBA,CAAA,EAAlC;IACI,OAAO,IAAI,CAACE,YAAY,CAACF,qBAAqB;EAChD;EAWA;;;;;;;;;;;;;;;;;;;;;;;;;EAyBAG,WAAFA,CAAcC,OAA6B,EAA3C;IAAA,IAAAC,iBAAA;IAAAC,eAAA;IAAAA,eAAA;IAtDE;;;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA,8BA0ByD,EAAE;IAAAA,eAAA,8BACF,EAAE;IA4sB3D;;;;;;;;;;;;;;;;IAAAA,eAAA;IAAAA,eAAA,kCAkJkC,IAAInB,iBAAiB,CACrDO,2BAA2B,CAC5B;IAp0BC,IAAIN,OAAO,EAAE;MACXO,SAAN,CACQS,OAAO,CAACG,KADhB,KAKO;MAEDZ,SAAN,CACQS,OAAO,CAACI,IADhB,KAKO;IACH;IAEA,MAAM;MACJD,KAAK;MACLE,iBAAiB;MACjBC,OAHN,GAGgB,KAAK;MACfC,kBAJN,GAI2B,CAAC;MACtBC,kBALN,GAK2B,IAAI;MACzBC,cAAc;MACdC,cAAc;MACdC,sBARN,GAQ+BR,KAAK,CAACQ,sBAAsB;MACrDC,UAAU;MACVC,QAAQ;MACRC,WAAW;MACXV,IAAI;MACJW,kBAbN,GAa2B,IAAIlC,qBAAqB,CAbpD,CAasD;MAChDmC,WAdN,GAcoB;IAdpB,IAeQhB,OAAO;IAEX,IAAI,CAACI,IAAT,GAAgBA,IAAI;IAChB,IAAI,CAACD,KAAT,GAAiBA,KAAK;IAClB,IAAI,CAACK,kBAAT,GAA8BA,kBAAkB;IAC5C,IAAI,CAACC,cAAT,GAA0BA,cAA1B,IAA4C,CAA5C,CAA8C;IAC1C,IAAI,CAACQ,cAAT,GAAAC,aAAA,CAAAA,aAAA,KACSL,QAAQ;MACXM,OAAO,GAAAlB,iBAAA,GAAEY,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEM,OAAzB,cAAAlB,iBAAA,cAAAA,iBAAA,GAAoCjB;IAAO,EACtC;IAED,IAAI,CAACoC,UAAT,GAAsB,IAAI,CAACA,UAAU,CAACC,IAAI,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACC,KAAT,GAAiB,IAAI,CAACA,KAAK,CAACD,IAAI,CAAC,IAAI,CAAC;IAClC,IAAI,CAACE,MAAT,GAAkB,IAAI,CAACA,MAAM,CAACF,IAAI,CAAC,IAAI,CAAC;IACpC,IAAI,CAACG,aAAT,GAAyB,IAAI,CAACA,aAAa,CAACH,IAAI,CAAC,IAAI,CAAC;IAClD,IAAI,CAACI,UAAT,GAAsB,IAAI,CAACA,UAAU,CAACJ,IAAI,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACK,wBAAT,GAAoC,IAAI,CAACC,wBAAzC,GACM,IAAI,CAACA,wBAAwB,CAACN,IAAI,CAAC,IAAI,CAAC;IAE1C,IAAI,CAAC7B,OAAT,GAAmBA,OAAO;IAEtB,IAAI,CAACM,YAAT,GAAwB,IAAIL,YAAY,CAAC;MACnCmC,MAAM,EAAE,IAAI;MACZnB,cAAc,EAAE,IAAI,CAACA,cAAc;MACnCC,cAAc;MACdL,iBAAiB;MACjBG,kBAAkB;MAClBF,OAAO;MACPQ,WAAW,EAAE,CAAC,CAACA,WAAW;MAC1Be,aAAa,EAAE7B,OAAO;MACtBe,kBAAkB;MAClBJ,sBAAsB;MACtBmB,WAAW,EACT,IAAI,CAACb,cAAc,CAACE,OAD5B,GAEU,MAAV;QACY,IAAI,IAAI,CAACY,cAAc,EAAE;UACvB,IAAI,CAACA,cAAc,CAAjC,CAAmC;QACvB;MACF,IACA,KAAK,CAAC;MACVnB;IACN,CAAK,CAAC;IAEF,IAAI,CAAChB,qBAAT,GAAiCU,OAAjC,IAA4CC,kBAA5C,GAAiE,CAAC;IAC9D,IAAIA,kBAAkB,EAAE;MACtByB,UAAU,CAAC,MAAjB;QACQ,IAAI,CAACpC,qBAAb,GAAqC,KAAK;MACpC,CAAC,EAAEW,kBAAkB,CAAC;IACxB;IAEA,IAAI,IAAI,CAACU,cAAc,CAACE,OAAO,EAAE,IAAI,CAACc,iBAAiB,CAA3D,CAA6D;IAEzDjB,WAAW,CAACkB,OAAO,CAAEC,UAAU,IAAKA,UAAU,CAACC,IAAI,CAAC,IAAI,EAAEpC,OAAO,CAAC,CAAC;EACrE;EAEQiC,iBAAiBA,CAAA,EAA3B;IACI,IAAI,OAAOI,MAAf,KAA0B,WAAW,EAAE;MACjC;IACF;IAKA,MAAMC,kBAAV,GAA+BD,MAG1B;IACD,MAAME,cAAV,GAA2BC,MAAM,CAACC,GAAG,CAAC,iBAAiB,CAAC;IACpD,CAACH,kBAAkB,CAACC,cAAc,IAChCD,kBAAkB,CAACC,cAAc,KAAM,EAAwB,EAAEG,IAAI,CACrE,IAAI,CACL;IACDJ,kBAAkB,CAACK,iBAAvB,GAA2C,IAAI;IAE3C;;;IAGA,IAAI,CAACjD,oBAAT,IAAiCV,OAAO,EAAE;MACpCU,oBAAN,GAA6B,IAAI;MAC3B,IACE2C,MAAM,CAACO,QADf,IAEQP,MAAM,CAACQ,GAAf,KAAuBR,MAAM,CAACS,IAA9B,I,kBAC0B,CAACC,IAAI,CAACV,MAAM,CAACW,QAAQ,CAACC,QAAQ,CAAC,EACjD;QACAjB,UAAU,CAAC,MAAnB;UACU,IAAI,CAAEK,MAAc,CAACa,+BAA+B,EAAE;YACpD,MAAMC,GAAlB,GAAwBd,MAAM,CAACe,SAAS;YAC5B,MAAMC,EAAlB,GAAuBF,GAAvB,IAA8BA,GAAG,CAACG,SAAS;YAC/B,IAAIC,GAAuB;YAC3B,IAAI,OAAOF,EAAvB,KAA8B,QAAQ,EAAE;cAC1B,IAAIA,EAAE,CAACG,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC,EAAE;gBAC9BD,GAAhB,GACkB,4CAAlB,GACkB,4DAA4D;cAChE,OAAO,IAAIF,EAAE,CAACG,OAAO,CAAC,UAAU,IAAI,CAAC,CAAC,EAAE;gBACtCD,GAAhB,GACkB,wEAAwE;cAC5E;YACF;YACA,IAAIA,GAAG,EAAE;yBACPhE,SAAS,CAACkE,GAAxB,CACgB,wDADhB,GAEkB,gBAAlB,EACgBF,GADhB,CAEe;YACH;UACF;QACF,CAAC,EAAE,KAAK,CAAC;MACX;IACF;EACF;EAEA;;;;;EAKA,IAAIlD,iBAAiBA,CAAA,EAAvB;IACI,OAAO,IAAI,CAACP,YAAY,CAACO,iBAAiB;EAC5C;EAEA;;;;EAIA,IAAIO,UAAUA,CAAA,EAAhB;IACI,OAAO,IAAI,CAACd,YAAY,CAACc,UAAU;EACrC;EAEA,IAAIA,UAAUA,CAACA,UAAsB,EAAvC;IACI,IAAI,CAACd,YAAY,CAACc,UAAtB,GAAmCA,UAAU;EAC3C;EAEA;;;;;;;;;;EAUO8C,IAAIA,CAAA,EAAb;IACI,IAAI,CAAC5D,YAAY,CAAC4D,IAAI,CAA1B,CAA4B;EAC1B;EAEA;;;;;;;;;;;;;;;;;;;EAmBOtC,UAAUA,CAIfpB,OAA0D,EAJ9D;IAMI,IAAI,IAAI,CAACS,cAAc,CAACW,UAAU,EAAE;MAClCpB,OAAN,GAAgBX,YAAY,CACpB,IAAI,CAACoB,cAAc,CAACW,UAEnB,EACDpB,OAAO,CACR;IACH;IAEA,OAAO,IAAI,CAACF,YAAY,CAACsB,UAAU,CAAoBpB,OAAO,CAAC;EACjE;EAEA;;;;;;;;;EASOsB,KAAKA,CAIVtB,OAAqD,EAJzD;IAMI,IAAI,IAAI,CAACS,cAAc,CAACa,KAAK,EAAE;MAC7BtB,OAAN,GAAgBX,YAAY,CAAC,IAAI,CAACoB,cAAc,CAACa,KAAK,EAAEtB,OAAO,CAAC;IAC5D;IAEA,IAAIhB,OAAO,EAAE;MACXO,SAAN,CACSS,OAAO,CAAC2D,WADjB,KAC2D,mBAD3D,KAMO;MAEDpE,SAAN,CACSS,OAAO,CAAC2D,WADjB,KAC2D,SAD3D,KAKO;MAEDpE,SAAN,CACQS,OAAO,CAACsB,KADhB,KAIO;MAED/B,SAAN,CACQS,OAAO,CAACsB,KAAK,CAACsC,IADtB,KAC+B,UAD/B,KAGO;MAEDrE,SAAN,CACQ,CAAES,OAAe,CAAC6D,iBAD1B,KAGO;MAEDtE,SAAN,CACQ,CAAES,OAAe,CAAC8D,YAD1B,KAGO;MAEDvE,SAAN,CACQ,CAAES,OAAe,CAAC+D,2BAD1B,KAGO;IACH;IAEA,OAAO,IAAI,CAACjE,YAAY,CAACwB,KAAK,CAAoBtB,OAAO,CAAC;EAC5D;EAEA;;;;;;;;EAQOuB,MAAMA,CAKXvB,OAA8D,EALlE;IAOI,MAAMgE,mBAAV,GAAgC3E,YAAY,CACtCH,OAAO,CACL;MACEyE,WAAW,EAAE,cAAqC;MAClDM,WAAW,EAAE;IACvB,CAAS,EACD,IAAI,CAACxD,cAAc,CAACc,MAAM,CAC3B,EACDvB,OAAO,CAIR;IAED,IAAIhB,OAAO,EAAE;MACXO,SAAN,CACQyE,mBAAmB,CAACE,QAD5B,KAGO;MAED3E,SAAN,CACQyE,mBAAmB,CAACL,WAD5B,KAC4C,cAD5C,IAEUK,mBAAmB,CAACL,WAA9B,KAA8C,UAA9C,KAEO;IACH;IAEA1E,aAAa,CAAC+E,mBAAmB,CAACE,QAAQ,EAAEvF,iBAAiB,CAACwF,QAAQ,CAAC;IAEvE,OAAO,IAAI,CAACrE,YAAY,CAACyB,MAAM,CAC7ByC,mBAAmB,CACpB;EACH;EAEA;;;;EAIOI,SAASA,CAIdpE,OAAyD,EAJ7D;IAMI,MAAMqE,KAAV,GAAkB,CAAlB,CAAoB;IAEhB,MAAMC,UAAV,GACM,IAAI,CAACxE,YAAY,CAACyE,wBAAwB,CAAQvE,OAAO,CAAC;IAE5D,MAAMwE,MAAV,GAAmBF,UAAU,CAACG,IAAI,CAC5B7F,GAAG,CAAE8F,MAAM,IAAAxD,aAAA,CAAAA,aAAA,KACNwD,MAAM;MACTC,IAAI,EAAE,IAAI,CAAC7E,YAAY,CAAC8E,aAAa,CAAC;QACpChC,QAAQ,EAAE5C,OAAO,CAACsB,KAAK;QACvBqD,IAAI,EAAED,MAAM,CAACC,IAAI;QACjBhB,WAAW,EAAE3D,OAAO,CAAC2D,WAAW;QAChCU;MACV,CAAS;IAAC,EACF,CAAC,CACJ;IAED,OAAOQ,MAAM,CAACC,MAAM,CAACN,MAAM,EAAE;MAAEO,OAAO,EAAET,UAAU,CAACS;IAAvD,CAAgE,CAAC;EAC/D;EAoCOC,SAASA,CAIdhF,OAAyD,EAJ7D;IAAA,IAKIiF,UALJ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAK0B,KAAK;IAE3B,OAAO,IAAI,CAAC/E,KAAK,CAAC6E,SAAS,CAAA9D,aAAA,CAAAA,aAAA,KACpBlB,OAAO;MAAEsB,KAAK,EAAE,IAAI,CAAC+D,SAAS,CAACrF,OAAO,CAACsB,KAAK;IAAA,IACjD2D,UAAU,CACX;EACH;EA0EOzD,aAAaA,CAIlBxB,OAA6D,EAJjE;IAQI,MAAMc,WAAV,GAAwB,IAAI,CAAChB,YAAY,CAACgB,WAAW;IACjD,MAAMwD,UAAV,GAAuB,IAAI,CAACnE,KAAK,CAACqB,aAAa,CAAAN,aAAA,CAAAA,aAAA,KACtClB,OAAO;MACVsF,QAAQ,EAAE,IAAI,CAACD,SAAS,CAACrF,OAAO,CAACsF,QAAQ,EAAExE,WAAW;IAAC,EACxD,CAAC;IAEF,IAAI9B,OAAO,EAAE;MACX,OAAOI,6BAA6B,CAClCkF,UAAU,EACV9B,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC,EAErCiC,MAA6C,IAAAxD,aAAA,CAAAA,aAAA,KAE1CwD,MAAM;QACT;QACA;QACA;QACA;QACA;QACAC,IAAI,EAAE,IAAI,CAAC7E,YAAY,CAACyF,YAAY,CAAArE,aAAA,CAAAA,aAAA,KAC/BlB,OAAO;UACV2E,IAAI,EAAED,MAAM,CAACC;QAAI,EAClB;MAAC,EACF,CACoF;IAC1F;IAEA,OAAOL,UAAkD;EAC3D;EAoCOkB,YAAYA,CAIjBxF,OAA4D,EAJhE;IAAA,IAKIiF,UALJ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAK0B,KAAK;IAE3B,OAAO,IAAI,CAAC/E,KAAK,CAACqF,YAAY,CAAAtE,aAAA,CAAAA,aAAA,KACvBlB,OAAO;MAAEsF,QAAQ,EAAE,IAAI,CAACD,SAAS,CAACrF,OAAO,CAACsF,QAAQ;IAAA,IACvDL,UAAU,CACX;EACH;EAEA;;;;;EAKOQ,UAAUA,CAIfzF,OAA0D,EAJ9D;IAMI,MAAM0F,GAAV,GAAgB,IAAI,CAACvF,KAAK,CAACsF,UAAU,CAAoBzF,OAAO,CAAC;IAE7D,IAAIA,OAAO,CAAC2F,SAAhB,KAA8B,KAAK,EAAE;MAC/B,IAAI,CAAC7F,YAAY,CAAC8F,gBAAgB,CAAxC,CAA0C;IACtC;IAEA,OAAOF,GAAG;EACZ;EAEA;;;;;;;;;;;EAWOG,aAAaA,CAIlB7F,OAA6D,EAJjE;IAMI,MAAM0F,GAAV,GAAgB,IAAI,CAACvF,KAAK,CAAC0F,aAAa,CAAoB7F,OAAO,CAAC;IAEhE,IAAIA,OAAO,CAAC2F,SAAhB,KAA8B,KAAK,EAAE;MAC/B,IAAI,CAAC7F,YAAY,CAAC8F,gBAAgB,CAAxC,CAA0C;IACtC;IAEA,OAAOF,GAAG;EACZ;EAEOI,uBAAuBA,CAACC,EAAa,EAA9C;IACI,IAAI,CAAChE,cAAT,GAA0BgE,EAAE;EAC1B;EAEOC,YAAYA,CACjBC,OAA2B,EAD/B;IAGI,OAAOnH,OAAO,CAAC,IAAI,CAACsB,IAAI,EAAE6F,OAAO,EAAE;MAAErE,MAAM,EAAE;IAAjD,CAAuD,CAAC;EACtD;EAEA;;;;;;;;;;;;;;;;EAgBOH,UAAUA,CAAA,EAAnB;IACI,OAAOyE,OAAO,CAACC,OAAO,CAA1B,EACOC,IAAI,CAAC,MACJ,IAAI,CAACtG,YAAY,CAACuG,UAAU,CAAC;MAC3BC,cAAc,EAAE;IAC1B,CAAS,CAAC,EAEHF,IAAI,CAAC,MAAMF,OAAO,CAACK,GAAG,CAAC,IAAI,CAACC,mBAAmB,CAAC5H,GAAG,CAAE6H,EAAE,IAAKA,EAAE,CAArE,CAAuE,CAAC,CAAC,EAClEL,IAAI,CAAC,MAAM,IAAI,CAACzE,wBAAwB,CAA/C,CAAiD,CAAC;EAChD;EAEA;;;;EAIO0E,UAAUA,CAAA,EAAnB;IACI,OAAOH,OAAO,CAACC,OAAO,CAA1B,EACOC,IAAI,CAAC,MACJ,IAAI,CAACtG,YAAY,CAACuG,UAAU,CAAC;MAC3BC,cAAc,EAAE;IAC1B,CAAS,CAAC,EAEHF,IAAI,CAAC,MAAMF,OAAO,CAACK,GAAG,CAAC,IAAI,CAACG,mBAAmB,CAAC9H,GAAG,CAAE6H,EAAE,IAAKA,EAAE,CAArE,CAAuE,CAAC,CAAC,CAAC;EACxE;EAEA;;;;;EAKOE,YAAYA,CAACZ,EAAsB,EAA5C;IACI,IAAI,CAACS,mBAAmB,CAAC9D,IAAI,CAACqD,EAAE,CAAC;IACjC,OAAO,MAAX;MACM,IAAI,CAACS,mBAAX,GAAiC,IAAI,CAACA,mBAAmB,CAACI,MAAM,CACvDC,CAAC,IAAKA,CAAA,KAAMd,EAAE,CAChB;IACH,CAAC;EACH;EAEA;;;;;EAKOe,YAAYA,CAACf,EAAsB,EAA5C;IACI,IAAI,CAACW,mBAAmB,CAAChE,IAAI,CAACqD,EAAE,CAAC;IACjC,OAAO,MAAX;MACM,IAAI,CAACW,mBAAX,GAAiC,IAAI,CAACA,mBAAmB,CAACE,MAAM,CACvDC,CAAC,IAAKA,CAAA,KAAMd,EAAE,CAChB;IACH,CAAC;EACH;EAsBA;;;;;;;;;;;;;;EAcOpE,wBAAwBA,CAC7BoF,cAAwB,EAD5B;IAGI,OAAO,IAAI,CAACjH,YAAY,CAAC6B,wBAAwB,CAACoF,cAAc,CAAC;EACnE;EAEA;;;;;;;;;;;EAWOC,cAAcA,CAInBhH,OAA4D,EAJhE;IAMI,MAAMpB,GAAV,GAAgB,IAAI,CAACkB,YAAY,CAACkH,cAAc,CAC1ChH,OAAmE,CACpE;IACD,MAAMiH,OAAV,GAA4C,EAAE;IAC1C,MAAMC,OAAV,GAA6D,EAAE;IAE3DtI,GAAG,CAACsD,OAAO,CAAC,CAACwC,MAAM,EAAEyC,QAAQ,KAAjC;MACMF,OAAO,CAACvE,IAAI,CAACyE,QAAQ,CAAC;MACtBD,OAAO,CAACxE,IAAI,CAACgC,MAAM,CAAC;IACtB,CAAC,CAAC;IAEF,MAAMA,MAAV,GAAmBwB,OAAO,CAACK,GAAG,CACxBW,OAAoB,CACyB;IAE/C;IACA;IACAxC,MAAM,CAACuC,OAAX,GAAqBA,OAAO;IACxBvC,MAAM,CAACwC,OAAX,GAAqBA,OAAO;IAExB;IACA;IACA;IACAxC,MAAM,CAAC0C,KAAK,CAAEC,KAAK,IAAvB;iBACM9H,SAAS,CAAC+H,KAAhB,KAEQD,KAFR,CAGO;IACH,CAAC,CAAC;IAEF,OAAO3C,MAAM;EACf;EAEA;;;;;;;;;;;;;EAaO6C,oBAAoBA,CAAA,EAA7B;IAAA,IACIC,OADJ,GAAAtC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MACqC,QAAQ;IAEzC,OAAO,IAAI,CAACpF,YAAY,CAACyH,oBAAoB,CAACC,OAAO,CAAC;EACxD;EAEA;;;;;;;;;;;EAWOC,OAAOA,CAACxC,UAAoB,EAArC;IACI,OAAO,IAAI,CAAC9E,KAAK,CAACsH,OAAO,CAACxC,UAAU,CAAC;EACvC;EAEA;;;;;;;EAOOyC,OAAOA,CAACC,eAAwB,EAAzC;IACI,OAAO,IAAI,CAACxH,KAAK,CAACuH,OAAO,CAACC,eAAe,CAAC;EAC5C;EAEA;;;EAGOC,OAAOA,CAACC,OAAmB,EAApC;IACI,IAAI,CAACzH,IAAT,GAAgByH,OAAO;EACrB;EAEA,IAAWnH,cAAcA,CAAA,EAA3B;IACI,OAAO,IAAI,CAACZ,YAAY,CAACY,cAAc;EACzC;EAMQ2E,SAASA,CAACzC,QAAsB,EAA1C;IAAA,IAA4C9B,WAA5C,GAAAoE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0D,KAAK;IAC3D,MAAM4C,WAAV,GAAwB,IAAI,CAAChI,YAAY,CAACuF,SAAS,CAACzC,QAAQ,CAAC;IACzD,OAAO9B,WAAX,GACQ,IAAI,CAACiH,uBAAuB,CAACC,iBAAiB,CAACF,WAAW,IAC1DA,WAAW;EACjB;AAoFF;AAEA,IAAI9I,OAAO,EAAE;EACXW,YAAY,CAACsI,SAAS,CAACC,kBAAzB,GAA8C/I,8BAA8B;AAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}