{"ast":null,"code":"/**\n * Recurrence Utilities - Logic for calculating and managing recurring tasks\n */// Day names for weekly patterns\nexport const DAY_NAMES=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];export const DAY_NAMES_FULL=['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];export const MONTH_NAMES=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];/**\n * Get the default recurrence pattern\n */export function getDefaultPattern(){return{frequency:'daily',interval:1};}/**\n * Get pattern from preset\n */export function getPatternFromPreset(preset){switch(preset){case'every_day':return{frequency:'daily',interval:1};case'every_weekday':return{frequency:'weekly',interval:1,daysOfWeek:[1,2,3,4,5]};case'every_week':return{frequency:'weekly',interval:1};case'every_2_weeks':return{frequency:'weekly',interval:2};case'every_month':return{frequency:'monthly',interval:1};case'every_quarter':return{frequency:'monthly',interval:3};case'every_year':return{frequency:'yearly',interval:1};case'custom':default:return{frequency:'custom',interval:1};}}/**\n * Generate the next instance date from a pattern\n */export function generateNextInstance(pattern){let fromDate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Date();const next=new Date(fromDate);switch(pattern.frequency){case'daily':next.setDate(next.getDate()+pattern.interval);break;case'weekly':if(pattern.daysOfWeek&&pattern.daysOfWeek.length>0){// Find the next day that matches daysOfWeek\nconst sortedDays=[...pattern.daysOfWeek].sort((a,b)=>a-b);const currentDay=next.getDay();// Find next day in the same week\nconst nextDayInWeek=sortedDays.find(d=>d>currentDay);if(nextDayInWeek!==undefined){next.setDate(next.getDate()+(nextDayInWeek-currentDay));}else{// Move to next week and use first day\nnext.setDate(next.getDate()+(7-currentDay)+sortedDays[0]+(pattern.interval-1)*7);}}else{next.setDate(next.getDate()+7*pattern.interval);}break;case'monthly':if(pattern.dayOfMonth){next.setMonth(next.getMonth()+pattern.interval);next.setDate(pattern.dayOfMonth);// Handle months with fewer days\nif(next.getDate()!==pattern.dayOfMonth){next.setDate(0);// Last day of previous month\n}}else{next.setMonth(next.getMonth()+pattern.interval);}break;case'yearly':if(pattern.monthOfYear){next.setFullYear(next.getFullYear()+pattern.interval);next.setMonth(pattern.monthOfYear-1);if(pattern.dayOfMonth){next.setDate(pattern.dayOfMonth);}}else{next.setFullYear(next.getFullYear()+pattern.interval);}break;case'custom':if(pattern.customDays&&pattern.customDays.length>0){// customDays represents days from now\nnext.setDate(next.getDate()+pattern.customDays[0]);}break;}return next;}/**\n * Generate instances for a date range\n */export function generateInstancesForRange(pattern,startDate,endDate){let maxInstances=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;const instances=[];let currentDate=new Date(startDate);let occurrenceNumber=1;// Check if we've exceeded maxOccurrences\nconst maxAllowed=pattern.maxOccurrences||maxInstances;while(currentDate<=endDate&&instances.length<maxAllowed){// Check end date constraint\nif(pattern.endDate&&currentDate>new Date(pattern.endDate)){break;}instances.push({dueDate:new Date(currentDate),occurrenceNumber,isValid:true});currentDate=generateNextInstance(pattern,currentDate);occurrenceNumber++;}return instances;}/**\n * Get a human-readable description of the recurrence pattern\n */export function getRecurrenceDescription(pattern){switch(pattern.frequency){case'daily':return pattern.interval===1?'Daily':\"Every \".concat(pattern.interval,\" days\");case'weekly':if(pattern.daysOfWeek&&pattern.daysOfWeek.length>0){if(pattern.daysOfWeek.length===7){return'Daily';}if(JSON.stringify(pattern.daysOfWeek.sort())===JSON.stringify([1,2,3,4,5])){return'Weekdays';}if(JSON.stringify(pattern.daysOfWeek.sort())===JSON.stringify([0,6])){return'Weekends';}const days=pattern.daysOfWeek.map(d=>DAY_NAMES[d]).join(', ');return pattern.interval===1?\"Weekly on \".concat(days):\"Every \".concat(pattern.interval,\" weeks on \").concat(days);}return pattern.interval===1?'Weekly':\"Every \".concat(pattern.interval,\" weeks\");case'monthly':if(pattern.dayOfMonth){const ordinal=getOrdinal(pattern.dayOfMonth);return pattern.interval===1?\"Monthly on the \".concat(ordinal):\"Every \".concat(pattern.interval,\" months on the \").concat(ordinal);}return pattern.interval===1?'Monthly':\"Every \".concat(pattern.interval,\" months\");case'yearly':if(pattern.monthOfYear&&pattern.dayOfMonth){const month=MONTH_NAMES[pattern.monthOfYear-1];return pattern.interval===1?\"Yearly on \".concat(month,\" \").concat(pattern.dayOfMonth):\"Every \".concat(pattern.interval,\" years on \").concat(month,\" \").concat(pattern.dayOfMonth);}return pattern.interval===1?'Yearly':\"Every \".concat(pattern.interval,\" years\");case'custom':return'Custom schedule';default:return'Recurring';}}/**\n * Get ordinal suffix for a number (1st, 2nd, 3rd, etc.)\n */export function getOrdinal(n){const s=['th','st','nd','rd'];const v=n%100;return n+(s[(v-20)%10]||s[v]||s[0]);}/**\n * Check if a task should generate a new instance\n */export function shouldGenerateInstance(instances,pattern){let checkDate=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Date();if(!pattern)return false;// Check if we've exceeded max occurrences\nif(pattern.maxOccurrences&&instances.length>=pattern.maxOccurrences){return false;}// Check if we've passed the end date\nif(pattern.endDate&&checkDate>new Date(pattern.endDate)){return false;}// Find the last instance\nconst lastInstance=instances.length>0?instances.reduce((latest,current)=>new Date(current.dueDate)>new Date(latest.dueDate)?current:latest):null;if(!lastInstance){return true;}// Check if enough time has passed since the last instance\nconst lastDueDate=new Date(lastInstance.dueDate);const nextDueDate=generateNextInstance(pattern,lastDueDate);return checkDate>=nextDueDate;}/**\n * Create a new recurring task instance\n */export function createRecurringInstance(parentId,dueDate,occurrenceNumber){return{instanceId:\"\".concat(parentId,\"-\").concat(Date.now(),\"-\").concat(Math.random().toString(36).substr(2,9)),parentTaskId:parentId,dueDate:dueDate.toISOString(),generatedAt:Date.now(),occurrenceNumber,modified:false,completed:false};}/**\n * Validate a recurrence pattern\n */export function validatePattern(pattern){const errors=[];if(!pattern.frequency){errors.push('Frequency is required');}if(pattern.interval<1){errors.push('Interval must be at least 1');}if(pattern.frequency==='weekly'&&pattern.daysOfWeek){if(pattern.daysOfWeek.some(d=>d<0||d>6)){errors.push('Days of week must be between 0 (Sunday) and 6 (Saturday)');}}if(pattern.frequency==='monthly'&&pattern.dayOfMonth){if(pattern.dayOfMonth<1||pattern.dayOfMonth>31){errors.push('Day of month must be between 1 and 31');}}if(pattern.frequency==='yearly'&&pattern.monthOfYear){if(pattern.monthOfYear<1||pattern.monthOfYear>12){errors.push('Month of year must be between 1 and 12');}}if(pattern.endDate&&pattern.maxOccurrences){errors.push('Cannot have both end date and max occurrences');}return{valid:errors.length===0,errors};}/**\n * Get upcoming instances for preview\n */export function getUpcomingInstances(pattern){let count=arguments.length>1&&arguments[1]!==undefined?arguments[1]:5;const instances=[];let currentDate=new Date();for(let i=0;i<count;i++){currentDate=generateNextInstance(pattern,currentDate);instances.push(new Date(currentDate));}return instances;}/**\n * Check if two patterns are equal\n */export function patternsEqual(a,b){var _a$daysOfWeek,_b$daysOfWeek;if(!a&&!b)return true;if(!a||!b)return false;return a.frequency===b.frequency&&a.interval===b.interval&&JSON.stringify((_a$daysOfWeek=a.daysOfWeek)===null||_a$daysOfWeek===void 0?void 0:_a$daysOfWeek.sort())===JSON.stringify((_b$daysOfWeek=b.daysOfWeek)===null||_b$daysOfWeek===void 0?void 0:_b$daysOfWeek.sort())&&a.dayOfMonth===b.dayOfMonth&&a.monthOfYear===b.monthOfYear&&a.endDate===b.endDate&&a.maxOccurrences===b.maxOccurrences;}","map":{"version":3,"names":["DAY_NAMES","DAY_NAMES_FULL","MONTH_NAMES","getDefaultPattern","frequency","interval","getPatternFromPreset","preset","daysOfWeek","generateNextInstance","pattern","fromDate","arguments","length","undefined","Date","next","setDate","getDate","sortedDays","sort","a","b","currentDay","getDay","nextDayInWeek","find","d","dayOfMonth","setMonth","getMonth","monthOfYear","setFullYear","getFullYear","customDays","generateInstancesForRange","startDate","endDate","maxInstances","instances","currentDate","occurrenceNumber","maxAllowed","maxOccurrences","push","dueDate","isValid","getRecurrenceDescription","concat","JSON","stringify","days","map","join","ordinal","getOrdinal","month","n","s","v","shouldGenerateInstance","checkDate","lastInstance","reduce","latest","current","lastDueDate","nextDueDate","createRecurringInstance","parentId","instanceId","now","Math","random","toString","substr","parentTaskId","toISOString","generatedAt","modified","completed","validatePattern","errors","some","valid","getUpcomingInstances","count","i","patternsEqual","_a$daysOfWeek","_b$daysOfWeek"],"sources":["/home/zobair-qauomi/todo_app/frontend/src/utils/recurrenceUtils.ts"],"sourcesContent":["/**\n * Recurrence Utilities - Logic for calculating and managing recurring tasks\n */\n\nimport {\n  RecurrencePattern,\n  RecurrencePreset,\n  RecurringTaskInstance,\n  GeneratedInstance,\n} from '../types/recurrence.types';\n\n// Day names for weekly patterns\nexport const DAY_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\nexport const DAY_NAMES_FULL = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nexport const MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n/**\n * Get the default recurrence pattern\n */\nexport function getDefaultPattern(): RecurrencePattern {\n  return {\n    frequency: 'daily',\n    interval: 1,\n  };\n}\n\n/**\n * Get pattern from preset\n */\nexport function getPatternFromPreset(preset: RecurrencePreset): RecurrencePattern {\n  switch (preset) {\n    case 'every_day':\n      return { frequency: 'daily', interval: 1 };\n    case 'every_weekday':\n      return { frequency: 'weekly', interval: 1, daysOfWeek: [1, 2, 3, 4, 5] };\n    case 'every_week':\n      return { frequency: 'weekly', interval: 1 };\n    case 'every_2_weeks':\n      return { frequency: 'weekly', interval: 2 };\n    case 'every_month':\n      return { frequency: 'monthly', interval: 1 };\n    case 'every_quarter':\n      return { frequency: 'monthly', interval: 3 };\n    case 'every_year':\n      return { frequency: 'yearly', interval: 1 };\n    case 'custom':\n    default:\n      return { frequency: 'custom', interval: 1 };\n  }\n}\n\n/**\n * Generate the next instance date from a pattern\n */\nexport function generateNextInstance(\n  pattern: RecurrencePattern,\n  fromDate: Date = new Date()\n): Date {\n  const next = new Date(fromDate);\n\n  switch (pattern.frequency) {\n    case 'daily':\n      next.setDate(next.getDate() + pattern.interval);\n      break;\n\n    case 'weekly':\n      if (pattern.daysOfWeek && pattern.daysOfWeek.length > 0) {\n        // Find the next day that matches daysOfWeek\n        const sortedDays = [...pattern.daysOfWeek].sort((a, b) => a - b);\n        const currentDay = next.getDay();\n\n        // Find next day in the same week\n        const nextDayInWeek = sortedDays.find(d => d > currentDay);\n\n        if (nextDayInWeek !== undefined) {\n          next.setDate(next.getDate() + (nextDayInWeek - currentDay));\n        } else {\n          // Move to next week and use first day\n          next.setDate(next.getDate() + (7 - currentDay) + sortedDays[0] + ((pattern.interval - 1) * 7));\n        }\n      } else {\n        next.setDate(next.getDate() + (7 * pattern.interval));\n      }\n      break;\n\n    case 'monthly':\n      if (pattern.dayOfMonth) {\n        next.setMonth(next.getMonth() + pattern.interval);\n        next.setDate(pattern.dayOfMonth);\n        // Handle months with fewer days\n        if (next.getDate() !== pattern.dayOfMonth) {\n          next.setDate(0); // Last day of previous month\n        }\n      } else {\n        next.setMonth(next.getMonth() + pattern.interval);\n      }\n      break;\n\n    case 'yearly':\n      if (pattern.monthOfYear) {\n        next.setFullYear(next.getFullYear() + pattern.interval);\n        next.setMonth(pattern.monthOfYear - 1);\n        if (pattern.dayOfMonth) {\n          next.setDate(pattern.dayOfMonth);\n        }\n      } else {\n        next.setFullYear(next.getFullYear() + pattern.interval);\n      }\n      break;\n\n    case 'custom':\n      if (pattern.customDays && pattern.customDays.length > 0) {\n        // customDays represents days from now\n        next.setDate(next.getDate() + pattern.customDays[0]);\n      }\n      break;\n  }\n\n  return next;\n}\n\n/**\n * Generate instances for a date range\n */\nexport function generateInstancesForRange(\n  pattern: RecurrencePattern,\n  startDate: Date,\n  endDate: Date,\n  maxInstances: number = 100\n): GeneratedInstance[] {\n  const instances: GeneratedInstance[] = [];\n  let currentDate = new Date(startDate);\n  let occurrenceNumber = 1;\n\n  // Check if we've exceeded maxOccurrences\n  const maxAllowed = pattern.maxOccurrences || maxInstances;\n\n  while (currentDate <= endDate && instances.length < maxAllowed) {\n    // Check end date constraint\n    if (pattern.endDate && currentDate > new Date(pattern.endDate)) {\n      break;\n    }\n\n    instances.push({\n      dueDate: new Date(currentDate),\n      occurrenceNumber,\n      isValid: true,\n    });\n\n    currentDate = generateNextInstance(pattern, currentDate);\n    occurrenceNumber++;\n  }\n\n  return instances;\n}\n\n/**\n * Get a human-readable description of the recurrence pattern\n */\nexport function getRecurrenceDescription(pattern: RecurrencePattern): string {\n  switch (pattern.frequency) {\n    case 'daily':\n      return pattern.interval === 1 ? 'Daily' : `Every ${pattern.interval} days`;\n\n    case 'weekly':\n      if (pattern.daysOfWeek && pattern.daysOfWeek.length > 0) {\n        if (pattern.daysOfWeek.length === 7) {\n          return 'Daily';\n        }\n        if (JSON.stringify(pattern.daysOfWeek.sort()) === JSON.stringify([1, 2, 3, 4, 5])) {\n          return 'Weekdays';\n        }\n        if (JSON.stringify(pattern.daysOfWeek.sort()) === JSON.stringify([0, 6])) {\n          return 'Weekends';\n        }\n        const days = pattern.daysOfWeek.map(d => DAY_NAMES[d]).join(', ');\n        return pattern.interval === 1 ? `Weekly on ${days}` : `Every ${pattern.interval} weeks on ${days}`;\n      }\n      return pattern.interval === 1 ? 'Weekly' : `Every ${pattern.interval} weeks`;\n\n    case 'monthly':\n      if (pattern.dayOfMonth) {\n        const ordinal = getOrdinal(pattern.dayOfMonth);\n        return pattern.interval === 1\n          ? `Monthly on the ${ordinal}`\n          : `Every ${pattern.interval} months on the ${ordinal}`;\n      }\n      return pattern.interval === 1 ? 'Monthly' : `Every ${pattern.interval} months`;\n\n    case 'yearly':\n      if (pattern.monthOfYear && pattern.dayOfMonth) {\n        const month = MONTH_NAMES[pattern.monthOfYear - 1];\n        return pattern.interval === 1\n          ? `Yearly on ${month} ${pattern.dayOfMonth}`\n          : `Every ${pattern.interval} years on ${month} ${pattern.dayOfMonth}`;\n      }\n      return pattern.interval === 1 ? 'Yearly' : `Every ${pattern.interval} years`;\n\n    case 'custom':\n      return 'Custom schedule';\n\n    default:\n      return 'Recurring';\n  }\n}\n\n/**\n * Get ordinal suffix for a number (1st, 2nd, 3rd, etc.)\n */\nexport function getOrdinal(n: number): string {\n  const s = ['th', 'st', 'nd', 'rd'];\n  const v = n % 100;\n  return n + (s[(v - 20) % 10] || s[v] || s[0]);\n}\n\n/**\n * Check if a task should generate a new instance\n */\nexport function shouldGenerateInstance(\n  instances: RecurringTaskInstance[],\n  pattern: RecurrencePattern,\n  checkDate: Date = new Date()\n): boolean {\n  if (!pattern) return false;\n\n  // Check if we've exceeded max occurrences\n  if (pattern.maxOccurrences && instances.length >= pattern.maxOccurrences) {\n    return false;\n  }\n\n  // Check if we've passed the end date\n  if (pattern.endDate && checkDate > new Date(pattern.endDate)) {\n    return false;\n  }\n\n  // Find the last instance\n  const lastInstance = instances.length > 0\n    ? instances.reduce((latest, current) =>\n      new Date(current.dueDate) > new Date(latest.dueDate) ? current : latest\n    )\n    : null;\n\n  if (!lastInstance) {\n    return true;\n  }\n\n  // Check if enough time has passed since the last instance\n  const lastDueDate = new Date(lastInstance.dueDate);\n  const nextDueDate = generateNextInstance(pattern, lastDueDate);\n\n  return checkDate >= nextDueDate;\n}\n\n/**\n * Create a new recurring task instance\n */\nexport function createRecurringInstance(\n  parentId: number,\n  dueDate: Date,\n  occurrenceNumber: number\n): RecurringTaskInstance {\n  return {\n    instanceId: `${parentId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    parentTaskId: parentId,\n    dueDate: dueDate.toISOString(),\n    generatedAt: Date.now(),\n    occurrenceNumber,\n    modified: false,\n    completed: false,\n  };\n}\n\n/**\n * Validate a recurrence pattern\n */\nexport function validatePattern(pattern: RecurrencePattern): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!pattern.frequency) {\n    errors.push('Frequency is required');\n  }\n\n  if (pattern.interval < 1) {\n    errors.push('Interval must be at least 1');\n  }\n\n  if (pattern.frequency === 'weekly' && pattern.daysOfWeek) {\n    if (pattern.daysOfWeek.some(d => d < 0 || d > 6)) {\n      errors.push('Days of week must be between 0 (Sunday) and 6 (Saturday)');\n    }\n  }\n\n  if (pattern.frequency === 'monthly' && pattern.dayOfMonth) {\n    if (pattern.dayOfMonth < 1 || pattern.dayOfMonth > 31) {\n      errors.push('Day of month must be between 1 and 31');\n    }\n  }\n\n  if (pattern.frequency === 'yearly' && pattern.monthOfYear) {\n    if (pattern.monthOfYear < 1 || pattern.monthOfYear > 12) {\n      errors.push('Month of year must be between 1 and 12');\n    }\n  }\n\n  if (pattern.endDate && pattern.maxOccurrences) {\n    errors.push('Cannot have both end date and max occurrences');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Get upcoming instances for preview\n */\nexport function getUpcomingInstances(\n  pattern: RecurrencePattern,\n  count: number = 5\n): Date[] {\n  const instances: Date[] = [];\n  let currentDate = new Date();\n\n  for (let i = 0; i < count; i++) {\n    currentDate = generateNextInstance(pattern, currentDate);\n    instances.push(new Date(currentDate));\n  }\n\n  return instances;\n}\n\n/**\n * Check if two patterns are equal\n */\nexport function patternsEqual(\n  a: RecurrencePattern | undefined,\n  b: RecurrencePattern | undefined\n): boolean {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n\n  return (\n    a.frequency === b.frequency &&\n    a.interval === b.interval &&\n    JSON.stringify(a.daysOfWeek?.sort()) === JSON.stringify(b.daysOfWeek?.sort()) &&\n    a.dayOfMonth === b.dayOfMonth &&\n    a.monthOfYear === b.monthOfYear &&\n    a.endDate === b.endDate &&\n    a.maxOccurrences === b.maxOccurrences\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}