{"ast":null,"code":"import _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Trie } from \"@wry/trie\";\nimport { FragmentReference } from \"./FragmentReference.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nexport class SuspenseCache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"queryRefs\", new Trie());\n    _defineProperty(this, \"fragmentRefs\", new Trie());\n    _defineProperty(this, \"options\", void 0);\n    this.options = options;\n  }\n  getQueryRef(cacheKey, createObservable) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        }\n      });\n    }\n    return ref.current;\n  }\n  getFragmentRef(cacheKey, client, options) {\n    const ref = this.fragmentRefs.lookupArray(cacheKey);\n    if (!ref.current) {\n      ref.current = new FragmentReference(client, options, {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        }\n      });\n    }\n    return ref.current;\n  }\n  add(cacheKey, queryRef) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n    ref.current = queryRef;\n  }\n}","map":{"version":3,"names":["Trie","FragmentReference","InternalQueryReference","SuspenseCache","constructor","options","arguments","length","undefined","_defineProperty","getQueryRef","cacheKey","createObservable","ref","queryRefs","lookupArray","current","autoDisposeTimeoutMs","onDispose","getFragmentRef","client","fragmentRefs","add","queryRef"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/react/internal/cache/SuspenseCache.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ObservableQuery,\n  OperationVariables,\n} from \"@apollo/client\";\n\nimport { FragmentReference } from \"./FragmentReference.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey, FragmentCacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>();\n  private fragmentRefs = new Trie<{ current?: FragmentReference }>();\n\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = {}) {\n    this.options = options;\n  }\n\n  getQueryRef<\n    TData = unknown,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  >(cacheKey: CacheKey, createObservable: () => ObservableQuery<TData>) {\n    const ref = this.queryRefs.lookupArray(cacheKey) as {\n      current?: InternalQueryReference<TData, TStates>;\n    };\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  getFragmentRef<TData, TVariables extends OperationVariables>(\n    cacheKey: FragmentCacheKey,\n    client: ApolloClient,\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: string | null | Array<string | null>;\n    }\n  ) {\n    const ref = this.fragmentRefs.lookupArray(cacheKey) as {\n      current?: FragmentReference<TData, TVariables>;\n    };\n\n    if (!ref.current) {\n      ref.current = new FragmentReference(client, options, {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  add(cacheKey: CacheKey, queryRef: InternalQueryReference<any, any>) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n    ref.current = queryRef;\n  }\n}\n"],"mappings":";AAAA,SAASA,IAAI,QAAQ,WAAW;AAShC,SAASC,iBAAiB,QAAQ,wBAAwB;AAC1D,SAASC,sBAAsB,QAAQ,qBAAqB;AAiB5D,OAAM,MAAOC,aAAa;EAMxBC,YAAA,EAA8C;IAAA,IAAlCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAgC,EAAE;IAAAG,eAAA,oBAL1B,IAAIT,IAAI,EAAwC;IAAAS,eAAA,uBAC7C,IAAIT,IAAI,EAAmC;IAAAS,eAAA;IAKhE,IAAI,CAACJ,OAAO,GAAGA,OAAO;EACxB;EAEAK,WAAWA,CAITC,QAAkB,EAAEC,gBAA8C;IAClE,MAAMC,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,WAAW,CAACJ,QAAQ,CAE9C;IAED,IAAI,CAACE,GAAG,CAACG,OAAO,EAAE;MAChBH,GAAG,CAACG,OAAO,GAAG,IAAId,sBAAsB,CAACU,gBAAgB,EAAE,EAAE;QAC3DK,oBAAoB,EAAE,IAAI,CAACZ,OAAO,CAACY,oBAAoB;QACvDC,SAAS,EAAEA,CAAA,KAAK;UACd,OAAOL,GAAG,CAACG,OAAO;QACpB;OACD,CAAC;IACJ;IAEA,OAAOH,GAAG,CAACG,OAAO;EACpB;EAEAG,cAAcA,CACZR,QAA0B,EAC1BS,MAAoB,EACpBf,OAEC;IAED,MAAMQ,GAAG,GAAG,IAAI,CAACQ,YAAY,CAACN,WAAW,CAACJ,QAAQ,CAEjD;IAED,IAAI,CAACE,GAAG,CAACG,OAAO,EAAE;MAChBH,GAAG,CAACG,OAAO,GAAG,IAAIf,iBAAiB,CAACmB,MAAM,EAAEf,OAAO,EAAE;QACnDY,oBAAoB,EAAE,IAAI,CAACZ,OAAO,CAACY,oBAAoB;QACvDC,SAAS,EAAEA,CAAA,KAAK;UACd,OAAOL,GAAG,CAACG,OAAO;QACpB;OACD,CAAC;IACJ;IAEA,OAAOH,GAAG,CAACG,OAAO;EACpB;EAEAM,GAAGA,CAACX,QAAkB,EAAEY,QAA0C;IAChE,MAAMV,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,WAAW,CAACJ,QAAQ,CAAC;IAChDE,GAAG,CAACG,OAAO,GAAGO,QAAQ;EACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}