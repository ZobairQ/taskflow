{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { assertWrappedQueryRef, getWrappedPromise, InternalQueryReference, wrapQueryRef } from \"@apollo/client/react/internal\";\nimport { FinalizationRegistry } from \"@apollo/client/utilities/internal/ponyfills\";\nimport { wrapHook } from \"../hooks/internal/index.js\";\n/**\n * A higher order function that returns a `preloadQuery` function which\n * can be used to begin loading a query with the given `client`. This is useful\n * when you want to start loading a query as early as possible outside of a\n * React component.\n *\n * > Refer to the [Suspense - Initiating queries outside React](https://www.apollographql.com/docs/react/data/suspense#initiating-queries-outside-react) section for a more in-depth overview.\n *\n * @param client - The `ApolloClient` instance that will be used to load queries\n * from the returned `preloadQuery` function.\n * @returns The `preloadQuery` function.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * ```\n */\nexport function createQueryPreloader(client) {\n  return wrapHook(\"createQueryPreloader\", _createQueryPreloader, client)(client);\n}\nconst _createQueryPreloader = client => {\n  function preloadQuery(query) {\n    var _client$defaultOption;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queryRef = new InternalQueryReference(client.watchQuery(_objectSpread(_objectSpread({}, options), {}, {\n      query,\n      notifyOnNetworkStatusChange: false\n    })), {\n      autoDisposeTimeoutMs: (_client$defaultOption = client.defaultOptions.react) === null || _client$defaultOption === void 0 || (_client$defaultOption = _client$defaultOption.suspense) === null || _client$defaultOption === void 0 ? void 0 : _client$defaultOption.autoDisposeTimeoutMs\n    });\n    const wrapped = wrapQueryRef(queryRef);\n    softRetainWhileReferenced(wrapped, queryRef);\n    return wrapped;\n  }\n  return Object.assign(preloadQuery, {\n    toPromise(queryRef) {\n      assertWrappedQueryRef(queryRef);\n      return getWrappedPromise(queryRef).then(() => queryRef);\n    }\n  });\n};\n/**\n * Soft-retains the underlying `InternalQueryReference` while the `PreloadedQueryRef`\n * is still reachable.\n * When the `PreloadedQueryRef` is garbage collected, the soft retain is\n * disposed of, but only after the initial query has finished loading.\n * Once the `InternalQueryReference` is properly retained, the check for garbage\n * collection is unregistered and the soft retain is disposed of immediately.\n */\n// this is an individual function to avoid closing over any values more than necessary\nfunction softRetainWhileReferenced(wrapped, queryRef) {\n  const {\n    softDispose,\n    delayedSoftDispose\n  } = getCleanup(queryRef);\n  registry.register(wrapped, delayedSoftDispose, queryRef);\n  // This will unregister the cleanup from the finalization registry when\n  // the queryRef is properly retained.\n  // This is mostly done to keep the FinalizationRegistry from holding too many\n  // cleanup functions, as our React Native polyfill has to iterate all of them regularly.\n  queryRef.retain = unregisterOnRetain(queryRef.retain, softDispose);\n}\n// this is an individual function to avoid closing over any values more than necessary\nfunction unregisterOnRetain(originalRetain, softDispose) {\n  return function () {\n    registry.unregister(this);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const dispose = originalRetain.apply(this, args);\n    softDispose();\n    return dispose;\n  };\n}\n// this is an individual function to avoid closing over any values more than necessary\nfunction getCleanup(queryRef) {\n  const softDispose = queryRef.softRetain();\n  const initialPromise = queryRef.promise;\n  return {\n    softDispose,\n    delayedSoftDispose: () => initialPromise.finally(softDispose).catch(() => {})\n  };\n}\nconst registry = new FinalizationRegistry(cleanup => cleanup());","map":{"version":3,"names":["assertWrappedQueryRef","getWrappedPromise","InternalQueryReference","wrapQueryRef","FinalizationRegistry","wrapHook","createQueryPreloader","client","_createQueryPreloader","preloadQuery","query","_client$defaultOption","options","arguments","length","undefined","queryRef","watchQuery","_objectSpread","notifyOnNetworkStatusChange","autoDisposeTimeoutMs","defaultOptions","react","suspense","wrapped","softRetainWhileReferenced","Object","assign","toPromise","then","softDispose","delayedSoftDispose","getCleanup","registry","register","retain","unregisterOnRetain","originalRetain","unregister","_len","args","Array","_key","dispose","apply","softRetain","initialPromise","promise","finally","catch","cleanup"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/react/query-preloader/createQueryPreloader.ts"],"sourcesContent":["import type {\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { PreloadedQueryRef } from \"@apollo/client/react\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  InternalQueryReference,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport type {\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport { FinalizationRegistry } from \"@apollo/client/utilities/internal/ponyfills\";\n\nimport { wrapHook } from \"../hooks/internal/index.js\";\n\nexport type PreloadQueryFetchPolicy = Extract<\n  WatchQueryFetchPolicy,\n  \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n>;\n\nexport type PreloadQueryOptions<\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n  context?: DefaultContext;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n  errorPolicy?: ErrorPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n  fetchPolicy?: PreloadQueryFetchPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n  returnPartialData?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n  refetchWritePolicy?: RefetchWritePolicy;\n} & VariablesOption<TVariables>;\n\n/**\n * A function that will begin loading a query when called. It's result can be\n * read by `useReadQuery` which will suspend until the query is loaded.\n * This is useful when you want to start loading a query as early as possible\n * outside of a React component.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * const queryRef = preloadQuery(query, { variables, ...otherOptions });\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<div>Loading</div>}>\n *       <MyQuery />\n *     </Suspense>\n *   );\n * }\n *\n * function MyQuery() {\n *   const { data } = useReadQuery(queryRef);\n *\n *   // do something with `data`\n * }\n * ```\n */\nexport interface PreloadQueryFunction {\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<\n    TData,\n    TVariables,\n    \"complete\" | \"streaming\" | \"partial\" | \"empty\"\n  >;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n    }\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\">;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: {} extends TVariables ?\n      [options?: PreloadQueryOptions<NoInfer<TVariables>>]\n    : [options: PreloadQueryOptions<NoInfer<TVariables>>]\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\">;\n\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   *\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return preloadQuery.toPromise(queryRef);\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   */\n  toPromise<TQueryRef extends PreloadedQueryRef<any, any, any>>(\n    queryRef: TQueryRef\n  ): Promise<TQueryRef>;\n}\n\n/**\n * A higher order function that returns a `preloadQuery` function which\n * can be used to begin loading a query with the given `client`. This is useful\n * when you want to start loading a query as early as possible outside of a\n * React component.\n *\n * > Refer to the [Suspense - Initiating queries outside React](https://www.apollographql.com/docs/react/data/suspense#initiating-queries-outside-react) section for a more in-depth overview.\n *\n * @param client - The `ApolloClient` instance that will be used to load queries\n * from the returned `preloadQuery` function.\n * @returns The `preloadQuery` function.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * ```\n */\nexport function createQueryPreloader(\n  client: ApolloClient\n): PreloadQueryFunction {\n  return wrapHook(\n    \"createQueryPreloader\",\n    _createQueryPreloader,\n    client\n  )(client);\n}\n\nconst _createQueryPreloader: typeof createQueryPreloader = (client) => {\n  function preloadQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      VariablesOption<TVariables> = {} as any\n  ): PreloadedQueryRef<TData, TVariables> {\n    const queryRef = new InternalQueryReference(\n      client.watchQuery({\n        ...options,\n        query,\n        notifyOnNetworkStatusChange: false,\n      } as ApolloClient.WatchQueryOptions<any, any>),\n      {\n        autoDisposeTimeoutMs:\n          client.defaultOptions.react?.suspense?.autoDisposeTimeoutMs,\n      }\n    );\n\n    const wrapped = wrapQueryRef(queryRef) as unknown as PreloadedQueryRef<\n      TData,\n      TVariables\n    >;\n    softRetainWhileReferenced(wrapped, queryRef);\n    return wrapped;\n  }\n\n  return Object.assign(preloadQuery, {\n    toPromise<TQueryRef extends PreloadedQueryRef<any, any, any>>(\n      queryRef: TQueryRef\n    ) {\n      assertWrappedQueryRef(queryRef);\n      return getWrappedPromise(queryRef).then(() => queryRef);\n    },\n  });\n};\n\n/**\n * Soft-retains the underlying `InternalQueryReference` while the `PreloadedQueryRef`\n * is still reachable.\n * When the `PreloadedQueryRef` is garbage collected, the soft retain is\n * disposed of, but only after the initial query has finished loading.\n * Once the `InternalQueryReference` is properly retained, the check for garbage\n * collection is unregistered and the soft retain is disposed of immediately.\n */\n// this is an individual function to avoid closing over any values more than necessary\nfunction softRetainWhileReferenced(\n  wrapped: PreloadedQueryRef<any, any, any>,\n  queryRef: InternalQueryReference\n) {\n  const { softDispose, delayedSoftDispose } = getCleanup(queryRef);\n  registry.register(wrapped, delayedSoftDispose, queryRef);\n  // This will unregister the cleanup from the finalization registry when\n  // the queryRef is properly retained.\n  // This is mostly done to keep the FinalizationRegistry from holding too many\n  // cleanup functions, as our React Native polyfill has to iterate all of them regularly.\n  queryRef.retain = unregisterOnRetain(queryRef.retain, softDispose);\n}\n\ntype RetainFunction = (\n  this: InternalQueryReference,\n  ...args: Parameters<InternalQueryReference[\"retain\"]>\n) => ReturnType<InternalQueryReference[\"retain\"]>;\n\n// this is an individual function to avoid closing over any values more than necessary\nfunction unregisterOnRetain(\n  originalRetain: RetainFunction,\n  softDispose: () => void\n): RetainFunction {\n  return function (...args) {\n    registry.unregister(this);\n    const dispose = originalRetain.apply(this, args);\n    softDispose();\n    return dispose;\n  };\n}\n\n// this is an individual function to avoid closing over any values more than necessary\nfunction getCleanup(queryRef: InternalQueryReference) {\n  const softDispose = queryRef.softRetain();\n  const initialPromise = queryRef.promise;\n\n  return {\n    softDispose,\n    delayedSoftDispose: () =>\n      initialPromise.finally(softDispose).catch(() => {}),\n  };\n}\n\nconst registry = new FinalizationRegistry<() => void>((cleanup) => cleanup());\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}