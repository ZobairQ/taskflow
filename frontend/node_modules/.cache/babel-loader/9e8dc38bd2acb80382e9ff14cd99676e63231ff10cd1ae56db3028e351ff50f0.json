{"ast":null,"code":"import { mergeDeepArray } from \"./mergeDeepArray.js\";\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function mergeDeep() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  return mergeDeepArray(sources);\n}","map":{"version":3,"names":["mergeDeepArray","mergeDeep","_len","arguments","length","sources","Array","_key"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/utilities/internal/mergeDeep.ts"],"sourcesContent":["import { mergeDeepArray } from \"./mergeDeepArray.js\";\nimport type { TupleToIntersection } from \"./types/TupleToIntersection.js\";\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\n\n/** @internal */\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n"],"mappings":"AAAA,SAASA,cAAT,QAA+B,qBAAqB;AAGpD;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA,gBAAgBC,SAASA,CAAA,EAAzB;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EACKC,OAAU,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAVF,OAAU,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;EAAA;EAEb,OAAOP,cAAc,CAACK,OAAO,CAAC;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}