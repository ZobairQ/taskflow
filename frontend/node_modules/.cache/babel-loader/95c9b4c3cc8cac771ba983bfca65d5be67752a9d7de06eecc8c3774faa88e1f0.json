{"ast":null,"code":"import _objectSpread from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zobair-qauomi/todo_app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { isNonNullObject } from \"./isNonNullObject.js\";\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst defaultReconciler = function (target, source, property) {\n  return this.merge(target[property], source[property]);\n};\nconst objForKey = key => {\n  return isNaN(+key) ? {} : [];\n};\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport class DeepMerger {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"reconciler\", void 0);\n    _defineProperty(this, \"isObject\", isNonNullObject);\n    _defineProperty(this, \"pastCopies\", new Set());\n    this.options = options;\n    this.reconciler = options.reconciler || defaultReconciler;\n  }\n  merge(target, source) {\n    let mergeOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const atPath = mergeOptions.atPath;\n    if (atPath !== null && atPath !== void 0 && atPath.length) {\n      const [head, ...tail] = atPath;\n      if (target === undefined) {\n        target = objForKey(head);\n      }\n      let nestedTarget = target[head];\n      if (nestedTarget === undefined && tail.length) {\n        nestedTarget = objForKey(tail[0]);\n      }\n      const nestedSource = this.merge(nestedTarget, source, _objectSpread(_objectSpread({}, mergeOptions), {}, {\n        atPath: tail\n      }));\n      if (nestedTarget !== nestedSource) {\n        target = this.shallowCopyForMerge(target);\n        target[head] = nestedSource;\n      }\n      return target;\n    }\n    if (Array.isArray(target) && Array.isArray(source) && this.options.arrayMerge === \"truncate\" && target.length > source.length) {\n      target = target.slice(0, source.length);\n      this.pastCopies.add(target);\n    }\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach(sourceKey => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(target, source, sourceKey);\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n      return target;\n    }\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n  shallowCopyForMerge(value) {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = value.slice(0);\n        } else {\n          value = _objectSpread({\n            __proto__: Object.getPrototypeOf(value)\n          }, value);\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}","map":{"version":3,"names":["isNonNullObject","hasOwnProperty","Object","prototype","defaultReconciler","target","source","property","merge","objForKey","key","isNaN","DeepMerger","constructor","options","arguments","length","undefined","_defineProperty","Set","reconciler","mergeOptions","atPath","head","tail","nestedTarget","nestedSource","_objectSpread","shallowCopyForMerge","Array","isArray","arrayMerge","slice","pastCopies","add","keys","forEach","sourceKey","call","targetValue","result","value","has","__proto__","getPrototypeOf"],"sources":["/home/zobair-qauomi/todo_app/node_modules/@apollo/src/utilities/internal/DeepMerger.ts"],"sourcesContent":["import { isNonNullObject } from \"./isNonNullObject.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\ntype ReconcilerFunction = (\n  this: DeepMerger,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number\n) => any;\n\nconst defaultReconciler: ReconcilerFunction = function (\n  target,\n  source,\n  property\n) {\n  return this.merge(target[property], source[property]);\n};\n\n/** @internal */\nexport declare namespace DeepMerger {\n  export interface Options {\n    arrayMerge?: DeepMerger.ArrayMergeStrategy;\n    reconciler?: ReconcilerFunction;\n  }\n\n  export interface MergeOptions {\n    atPath?: ReadonlyArray<string | number>;\n  }\n\n  export type ArrayMergeStrategy =\n    // Truncate the target array to the source length, then deep merge the array\n    // items at the same index\n    | \"truncate\"\n    // Combine arrays and deep merge array items for items at the same index.\n    // This is the default\n    | \"combine\";\n}\n\nconst objForKey = (key: string | number) => {\n  return isNaN(+key) ? {} : [];\n};\n\n/** @internal */\nexport class DeepMerger {\n  private reconciler: ReconcilerFunction;\n  constructor(private options: DeepMerger.Options = {}) {\n    this.reconciler = options.reconciler || defaultReconciler;\n  }\n\n  public merge(\n    target: any,\n    source: any,\n    mergeOptions: DeepMerger.MergeOptions = {}\n  ): any {\n    const atPath = mergeOptions.atPath;\n\n    if (atPath?.length) {\n      const [head, ...tail] = atPath;\n      if (target === undefined) {\n        target = objForKey(head);\n      }\n      let nestedTarget = target[head];\n      if (nestedTarget === undefined && tail.length) {\n        nestedTarget = objForKey(tail[0]);\n      }\n      const nestedSource = this.merge(nestedTarget, source, {\n        ...mergeOptions,\n        atPath: tail,\n      });\n      if (nestedTarget !== nestedSource) {\n        target = this.shallowCopyForMerge(target);\n        target[head] = nestedSource;\n      }\n      return target;\n    }\n\n    if (\n      Array.isArray(target) &&\n      Array.isArray(source) &&\n      this.options.arrayMerge === \"truncate\" &&\n      target.length > source.length\n    ) {\n      target = target.slice(0, source.length);\n      this.pastCopies.add(target);\n    }\n\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach((sourceKey) => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(target, source, sourceKey);\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}